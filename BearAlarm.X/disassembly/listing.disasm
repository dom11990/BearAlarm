Disassembly Listing for BearAlarm
Generated From:
C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/dist/default/debug/BearAlarm.X.debug.elf
Jun 17, 2015 7:15:19 PM

---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/LCD_Board.X/source/c/LCD.c  ----------
1:                 #include "LCD.h"
2:                 
3:                 /**
4:                  * Configures SPI module and Pins 21-25 for the LCD Board's use.
5:                  * @return  0 on success
6:                  */
7:                 int LCD_ConfigSPI(void)
8:                 {
00468C  FA0000     LNK #0x0
9:                     //All pins used by the module need to be set to DIGITAL by clearing
10:                    //their respective ANSEL registers
11:                
12:                    //If the device has a Peripheral Pin Select (PPS) feature, the SCKx pin must
13:                    //be mapped as both input and output in Master mode
14:                
15:                    //SPIxCON1 configuration
16:                    SPI2CON1bits.DISSCK = 0b0;      //master mode
00468E  A98263     BCLR 0x263, #4
17:                    SPI2CON1bits.DISSDO = 0;        //using SDO
004690  A96263     BCLR 0x263, #3
18:                    SPI2CON1bits.MODE16 = 0;        //communication is byte-wide
004692  A94263     BCLR 0x263, #2
19:                    SPI2CON1bits.SMP = 0;           //data is sampled at middle of data
004694  A92263     BCLR 0x263, #1
20:                                                    //output time
21:                    SPI2CON1bits.CKE = 1;           //data changes when clock goes from idle to
004696  A80263     BSET 0x263, #0
22:                                                    //active (in this config, low to high)
23:                    SPI2CON1bits.SSEN = 0;          //this module is master, no need for SS
004698  A9E262     BCLR SPI2CON1, #7
24:                    SPI2CON1bits.CKP = 0;           //clock idle is low, active is high
00469A  A9C262     BCLR SPI2CON1, #6
25:                    SPI2CON1bits.MSTEN = 1;         //module is in master mode
00469C  A8A262     BSET SPI2CON1, #5
26:                    SPI2CON1bits.SPRE = 0b111;      //1:1 secondary prescaler
00469E  801314     MOV SPI2CON1, W4
0046A0  A02004     BSET W4, #2
0046A2  A03004     BSET W4, #3
0046A4  A04004     BSET W4, #4
0046A6  881314     MOV W4, SPI2CON1
27:                    SPI2CON1bits.PPRE = 0b00;       //64:1 primary prescaler
0046A8  801314     MOV SPI2CON1, W4
0046AA  A10004     BCLR W4, #0
0046AC  A11004     BCLR W4, #1
0046AE  881314     MOV W4, SPI2CON1
28:                
29:                    //SPIxCON2 configuration
30:                    SPI2CON2bits.FRMEN = 0;         //Frame SPI support is disabled
0046B0  A9E265     BCLR 0x265, #7
31:                    SPI2CON2bits.SPIFSD = 0;        //Frame sync pulse output (master)
0046B2  A9C265     BCLR 0x265, #6
32:                    SPI2CON2bits.FRMPOL = 0;        //Frame sync pulse is active low
0046B4  A9A265     BCLR 0x265, #5
33:                    SPI2CON2bits.FRMDLY = 0;        //Frame sync pulse coincides with first bit
0046B6  A92264     BCLR SPI2CON2, #1
34:                    SPI2CON2bits.SPIBEN = 1;        //Enhanced buffer mode enabled
0046B8  A80264     BSET SPI2CON2, #0
35:                
36:                    //RB14  =   25  =   SS
37:                    //RB13  =   24  =   RS
38:                    //RPI44 =   23  =   SDI
39:                    //RP32  =   22  =   SDO
40:                    //RP42  =   21  =   SCK
41:                
42:                    RPINR22bits.SDI2R = 0b0101100;  //RPI44 SDI
0046BA  803665     MOV RPINR22, W5
0046BC  2FF804     MOV #0xFF80, W4
0046BE  628284     AND W5, W4, W5
0046C0  2002C4     MOV #0x2C, W4
0046C2  720205     IOR W4, W5, W4
0046C4  883664     MOV W4, RPINR22
43:                    RPOR4bits.RP43R = 0b001000;     //RP43 SDO
0046C6  803445     MOV RPOR4, W5
0046C8  2C0FF4     MOV #0xC0FF, W4
0046CA  628284     AND W5, W4, W5
0046CC  208004     MOV #0x800, W4
0046CE  720205     IOR W4, W5, W4
0046D0  883444     MOV W4, RPOR4
44:                    RPINR22bits.SCK2R = 0b0101010;  //RP42 CLK in?
0046D2  803665     MOV RPINR22, W5
0046D4  280FF4     MOV #0x80FF, W4
0046D6  628284     AND W5, W4, W5
0046D8  22A004     MOV #0x2A00, W4
0046DA  720205     IOR W4, W5, W4
0046DC  883664     MOV W4, RPINR22
45:                    RPOR4bits.RP42R = 0b001001;     //RP42 CLK out
0046DE  803445     MOV RPOR4, W5
0046E0  2FFC04     MOV #0xFFC0, W4
0046E2  628204     AND W5, W4, W4
0046E4  B30094     IOR #0x9, W4
0046E6  883444     MOV W4, RPOR4
46:                
47:                    CONFIG_CHIP_SELECT
0046E8  A9CE11     BCLR 0xE11, #6
48:                    CONFIG_RS
0046EA  A9AE11     BCLR 0xE11, #5
49:                
50:                    SPI2STATbits.SPISIDL = 0;       //module continues operation in idle mode
0046EC  A9A261     BCLR 0x261, #5
51:                    SPI2STATbits.SPIEN = 1;         //Enables the module
0046EE  A8E261     BSET 0x261, #7
52:                
53:                    return 0;
0046F0  EB0200     CLR W4
54:                }
0046F2  780004     MOV W4, W0
0046F4  FA8000     ULNK
0046F6  060000     RETURN
55:                
56:                /**
57:                 *
58:                 * @return 0 on success
59:                 */
60:                int LCD_InitiaizeLCD(void)
61:                {
0046F8  FA0000     LNK #0x0
62:                    LCD_WriteCommand(LCD_CMD_CLEAR_DISPLAY);
0046FA  B3C010     MOV.B #0x1, W0
0046FC  07002E     RCALL LCD_WriteCommand
63:                    LCD_WriteCommand(LCD_CMD_FUNCTION_8B_2L_FSML);
0046FE  B3C380     MOV.B #0x38, W0
004700  07002C     RCALL LCD_WriteCommand
64:                    LCD_WriteCommand(LCD_CMD_DISPLAY_DON_COFF_BOFF);
004702  B3C0C0     MOV.B #0xC, W0
004704  07002A     RCALL LCD_WriteCommand
65:                    LCD_WriteCommand(LCD_CMD_ENTRY_MODE_INC_NO_S);
004706  B3C060     MOV.B #0x6, W0
004708  070028     RCALL LCD_WriteCommand
66:                    LCD_WriteCommand(LCD_CMD_RETURN_HOME);
00470A  B3C020     MOV.B #0x2, W0
00470C  070026     RCALL LCD_WriteCommand
67:                
68:                    return 0;
00470E  EB0200     CLR W4
69:                }
004710  780004     MOV W4, W0
004712  FA8000     ULNK
004714  060000     RETURN
70:                
71:                /**
72:                 * Writes a string to the LCD, expect null terminator in the string ('\0')
73:                 * @param string null terminated string to write to the LCD
74:                 * @return 0 on success
75:                 */
76:                int LCD_WriteStringNullTerm(char * string)
77:                {
004716  FA0002     LNK #0x2
004718  780F00     MOV W0, [W14]
78:                    while(string)
00471A  370005     BRA 0x4726
004726  78021E     MOV [W14], W4
004728  520FE0     SUB W4, #0x0, [W15]
00472A  3AFFF8     BRA NZ, 0x471C
79:                    {
80:                        LCD_WriteData(*string);
00471C  78021E     MOV [W14], W4
00471E  784214     MOV.B [W4], W4
004720  784004     MOV.B W4, W0
004722  070036     RCALL LCD_WriteData
81:                        string++;
004724  E80F1E     INC [W14], [W14]
82:                    }
83:                
84:                    return 0;
00472C  EB0200     CLR W4
85:                }
00472E  780004     MOV W4, W0
004730  FA8000     ULNK
004732  060000     RETURN
86:                
87:                /**
88:                 * Writes a sequence of chars to the display.
89:                 * @param buffer the char[] to be written to the LCD
90:                 * @param length number of elements to write
91:                 * @return 0 on success
92:                 */
93:                int LCD_WriteBuffer(char * buffer, char length)
94:                {
004734  FA0004     LNK #0x4
004736  780F00     MOV W0, [W14]
004738  984721     MOV.B W1, [W14+2]
95:                    while(length)
00473A  370008     BRA 0x474C
00474C  90422E     MOV.B [W14+2], W4
00474E  524FE0     SUB.B W4, #0x0, [W15]
004750  3AFFF5     BRA NZ, 0x473C
96:                    {
97:                        LCD_WriteData(*buffer);
00473C  78021E     MOV [W14], W4
00473E  784214     MOV.B [W4], W4
004740  784004     MOV.B W4, W0
004742  070026     RCALL LCD_WriteData
98:                        buffer++;
004744  E80F1E     INC [W14], [W14]
99:                        length--;
004746  90422E     MOV.B [W14+2], W4
004748  E94204     DEC.B W4, W4
00474A  984724     MOV.B W4, [W14+2]
100:                   }
101:               
102:                   return 0;
004752  EB0200     CLR W4
103:               }
004754  780004     MOV W4, W0
004756  FA8000     ULNK
004758  060000     RETURN
104:               
105:               /**
106:                * Writes a command (RS = 0) to the LCD. Used for configuring various LCD
107:                * settings.
108:                * @param byte
109:                * @return 0 on success
110:                */
111:               int LCD_WriteCommand(char byte)
112:               {
00475A  FA0004     LNK #0x4
00475C  984720     MOV.B W0, [W14+2]
113:                   char temp;
114:                   //byte = reverseByte(byte);
115:                   ACTIVATE_CHIP_SELECT
00475E  A8CE15     BSET 0xE15, #6
116:                   CLEAR_RS
004760  A9AE15     BCLR 0xE15, #5
117:                   SPIBUF = byte;
004762  90422E     MOV.B [W14+2], W4
004764  FB0204     SE W4, W4
004766  881344     MOV W4, SPI2BUF
118:               
119:                   //wait for the shift operation to complete
120:                   while(SPI2STATbits.SRXMPT)
004768  370001     BRA 0x476C
00476C  801305     MOV SPI2STAT, W5
00476E  200204     MOV #0x20, W4
004770  628204     AND W5, W4, W4
004772  520FE0     SUB W4, #0x0, [W15]
004774  3AFFFA     BRA NZ, 0x476A
121:                       Nop();
00476A  000000     NOP
122:               
123:                   __delay_us(100);
004776  217700     MOV #0x1770, W0
004778  200001     MOV #0x0, W1
00477A  0703EF     RCALL ___delay32
124:                   //read out the empty byte that is now sitting in the read buffer
125:                   temp = SPIBUF;
00477C  801344     MOV SPI2BUF, W4
00477E  784F04     MOV.B W4, [W14]
126:                   RELEASE_CHIP_SELECT
004780  A9CE15     BCLR 0xE15, #6
127:                   __delay_ms(2);
004782  2D4C00     MOV #0xD4C0, W0
004784  200011     MOV #0x1, W1
004786  0703E9     RCALL ___delay32
128:                   return 0;
004788  EB0200     CLR W4
129:               }
00478A  780004     MOV W4, W0
00478C  FA8000     ULNK
00478E  060000     RETURN
130:               
131:               /**
132:                * Writes to the data memory of the LCD (RS = 1). Use this function to write
133:                * text to be displayed.
134:                * @param byte
135:                * @return 0 on success
136:                */
137:               int LCD_WriteData(char byte)
138:               {
004790  FA0004     LNK #0x4
004792  984720     MOV.B W0, [W14+2]
139:                   char temp;
140:               
141:                   ACTIVATE_CHIP_SELECT
004794  A8CE15     BSET 0xE15, #6
142:                   SET_RS
004796  A8AE15     BSET 0xE15, #5
143:                   SPIBUF = byte;
004798  90422E     MOV.B [W14+2], W4
00479A  FB0204     SE W4, W4
00479C  881344     MOV W4, SPI2BUF
144:               
145:                   //wait for the shift operation to complete
146:                   while(SPI2STATbits.SRXMPT)
00479E  370001     BRA 0x47A2
0047A2  801305     MOV SPI2STAT, W5
0047A4  200204     MOV #0x20, W4
0047A6  628204     AND W5, W4, W4
0047A8  520FE0     SUB W4, #0x0, [W15]
0047AA  3AFFFA     BRA NZ, 0x47A0
147:                       Nop();
0047A0  000000     NOP
148:               
149:                   __delay_us(100);
0047AC  217700     MOV #0x1770, W0
0047AE  200001     MOV #0x0, W1
0047B0  0703D4     RCALL ___delay32
150:                   //read out the empty byte that is now sitting in the read buffer
151:                   temp = SPIBUF;
0047B2  801344     MOV SPI2BUF, W4
0047B4  784F04     MOV.B W4, [W14]
152:                   RELEASE_CHIP_SELECT
0047B6  A9CE15     BCLR 0xE15, #6
153:                   CLEAR_RS
0047B8  A9AE15     BCLR 0xE15, #5
154:                           
155:                   return 0;
0047BA  EB0200     CLR W4
156:               }
0047BC  780004     MOV W4, W0
0047BE  FA8000     ULNK
0047C0  060000     RETURN
157:               
158:               /**
159:                * Sets the DDRAM address to the specified row and column. This is where text
160:                * will be written to.
161:                * @param row 0 indexed row
162:                * @param column 0 indexed column
163:                * @return 0 on success
164:                */
165:               int LCD_SetPosition(char row, char column)
166:               {
0047C2  FA0004     LNK #0x4
0047C4  984720     MOV.B W0, [W14+2]
0047C6  984731     MOV.B W1, [W14+3]
167:                   char DDRAM_address;
168:                   //for a 2x16 display:
169:                   //row 0 is DDRAM 0x00 to 0x0F
170:                   //row 1 is DDRAM 0x40 to 0x4F
171:                   row = (row)?0x40:0x00;
0047C8  90422E     MOV.B [W14+2], W4
0047CA  524FE0     SUB.B W4, #0x0, [W15]
0047CC  320002     BRA Z, 0x47D2
0047CE  B3C404     MOV.B #0x40, W4
0047D0  370001     BRA 0x47D4
0047D2  EB4200     CLR.B W4
0047D4  984724     MOV.B W4, [W14+2]
172:               
173:                   DDRAM_address = row+column;
0047D6  9042AE     MOV.B [W14+2], W5
0047D8  90423E     MOV.B [W14+3], W4
0047DA  42C204     ADD.B W5, W4, W4
0047DC  784F04     MOV.B W4, [W14]
174:               
175:                   //only perform the LCD operation if the address is valid
176:                   if(DDRAM_address <= 0x4F)
0047DE  B3C4F4     MOV.B #0x4F, W4
0047E0  78429E     MOV.B [W14], W5
0047E2  52CF84     SUB.B W5, W4, [W15]
0047E4  3C0006     BRA GT, 0x47F2
177:                       LCD_WriteCommand(LCD_CMD_SET_DDRAM_ADDRESS|DDRAM_address);
0047E6  B3C804     MOV.B #0x80, W4
0047E8  72421E     IOR.B W4, [W14], W4
0047EA  784004     MOV.B W4, W0
0047EC  07FFB6     RCALL LCD_WriteCommand
178:                   else
179:                       return LCD_ERROR_INVALID_DDRAM_ADDRESS;
0047F2  2FC184     MOV #0xFC18, W4
180:                   return 0;
0047EE  EB0200     CLR W4
0047F0  370001     BRA 0x47F4
181:               }
0047F4  780004     MOV W4, W0
0047F6  FA8000     ULNK
0047F8  060000     RETURN
182:               
183:               
184:               /**
185:                * Configures the SPI module, and writes some test text to the LCD.
186:                * Effectively tests the basic functionality of the display.
187:                * @return
188:                */
189:               int LCD_TEST(void)
190:               {
0047FA  FA0000     LNK #0x0
191:                   LCD_ConfigSPI();
0047FC  07FF47     RCALL LCD_ConfigSPI
192:                   LCD_InitiaizeLCD();
0047FE  07FF7C     RCALL LCD_InitiaizeLCD
193:                   LCD_WriteData('L');
004800  B3C4C0     MOV.B #0x4C, W0
004802  07FFC6     RCALL LCD_WriteData
194:                   LCD_WriteData('i');
004804  B3C690     MOV.B #0x69, W0
004806  07FFC4     RCALL LCD_WriteData
195:                   LCD_WriteData('n');
004808  B3C6E0     MOV.B #0x6E, W0
00480A  07FFC2     RCALL LCD_WriteData
196:                   LCD_WriteData('e');
00480C  B3C650     MOV.B #0x65, W0
00480E  07FFC0     RCALL LCD_WriteData
197:                   LCD_WriteData(' ');
004810  B3C200     MOV.B #0x20, W0
004812  07FFBE     RCALL LCD_WriteData
198:                   LCD_WriteData('1');
004814  B3C310     MOV.B #0x31, W0
004816  07FFBC     RCALL LCD_WriteData
199:                   LCD_WriteCommand(LCD_CMD_RETURN_LINE2);
004818  B3CC00     MOV.B #0xC0, W0
00481A  07FF9F     RCALL LCD_WriteCommand
200:                   LCD_WriteData('L');
00481C  B3C4C0     MOV.B #0x4C, W0
00481E  07FFB8     RCALL LCD_WriteData
201:                   LCD_WriteData('i');
004820  B3C690     MOV.B #0x69, W0
004822  07FFB6     RCALL LCD_WriteData
202:                   LCD_WriteData('n');
004824  B3C6E0     MOV.B #0x6E, W0
004826  07FFB4     RCALL LCD_WriteData
203:                   LCD_WriteData('e');
004828  B3C650     MOV.B #0x65, W0
00482A  07FFB2     RCALL LCD_WriteData
204:                   LCD_WriteData(' ');
00482C  B3C200     MOV.B #0x20, W0
00482E  07FFB0     RCALL LCD_WriteData
205:                   LCD_WriteData('2');
004830  B3C320     MOV.B #0x32, W0
004832  07FFAE     RCALL LCD_WriteData
206:               
207:                   LCD_SetPosition(0,0xA);
004834  B3C0A1     MOV.B #0xA, W1
004836  EB4000     CLR.B W0
004838  07FFC4     RCALL LCD_SetPosition
208:                   LCD_WriteData('T');
00483A  B3C540     MOV.B #0x54, W0
00483C  07FFA9     RCALL LCD_WriteData
209:                   LCD_WriteData('e');
00483E  B3C650     MOV.B #0x65, W0
004840  07FFA7     RCALL LCD_WriteData
210:                   LCD_WriteData('x');
004842  B3C780     MOV.B #0x78, W0
004844  07FFA5     RCALL LCD_WriteData
211:                   LCD_WriteData('t');
004846  B3C740     MOV.B #0x74, W0
004848  07FFA3     RCALL LCD_WriteData
212:                   LCD_WriteData(' ');
00484A  B3C200     MOV.B #0x20, W0
00484C  07FFA1     RCALL LCD_WriteData
213:                   LCD_WriteData('1');
00484E  B3C310     MOV.B #0x31, W0
004850  07FF9F     RCALL LCD_WriteData
214:               
215:                   LCD_SetPosition(1,0xA);
004852  B3C0A1     MOV.B #0xA, W1
004854  B3C010     MOV.B #0x1, W0
004856  07FFB5     RCALL LCD_SetPosition
216:                   LCD_WriteData('T');
004858  B3C540     MOV.B #0x54, W0
00485A  07FF9A     RCALL LCD_WriteData
217:                   LCD_WriteData('e');
00485C  B3C650     MOV.B #0x65, W0
00485E  07FF98     RCALL LCD_WriteData
218:                   LCD_WriteData('x');
004860  B3C780     MOV.B #0x78, W0
004862  07FF96     RCALL LCD_WriteData
219:                   LCD_WriteData('t');
004864  B3C740     MOV.B #0x74, W0
004866  07FF94     RCALL LCD_WriteData
220:                   LCD_WriteData(' ');
004868  B3C200     MOV.B #0x20, W0
00486A  07FF92     RCALL LCD_WriteData
221:                   LCD_WriteData('2');
00486C  B3C320     MOV.B #0x32, W0
00486E  07FF90     RCALL LCD_WriteData
222:               
223:               
224:                   return 0;
004870  EB0200     CLR W4
225:               }
004872  780004     MOV W4, W0
004874  FA8000     ULNK
004876  060000     RETURN
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/c/main.c  ---------
1:                 /* 
2:                  * File:   main.c
3:                  * Author: Dominik
4:                  * Created on June 8th, 2015
5:                  */
6:                 
7:                 
8:                 #include "main.h"
9:                 #include "LCD.h"
10:                
11:                
12:                static QueueHandle_t TopQueue;
13:                
14:                //TODO: create semaphores for modules i.e the SPI2 engine, ADC etc
15:                int main()
16:                {
0049DE  FA0016     LNK #0x16
17:                    //Task Handles
18:                    TaskHandle_t MonitorTaskRef;
19:                    TaskHandle_t LCDTaskRef;
20:                    TaskHandle_t TemperatureTaskRef;
21:                    TaskHandle_t CC2500TaskRef;
22:                    TaskHandle_t TopTaskRef;
23:                    
24:                    
25:                
26:                    //Task Data
27:                    MonitorTaskData_t * MonitorTaskData = 0;
0049E0  EB0200     CLR W4
0049E2  980764     MOV W4, [W14+12]
28:                    LCDTaskData_t * LCDTaskData = 0;
0049E4  EB0200     CLR W4
0049E6  980774     MOV W4, [W14+14]
29:                    TemperatureTaskData_t * TemperatureTaskData = 0;
0049E8  EB0200     CLR W4
0049EA  980F04     MOV W4, [W14+16]
30:                    CC2500TaskData_t * CC2500TaskData = 0;
0049EC  EB0200     CLR W4
0049EE  980F14     MOV W4, [W14+18]
31:                    TopTaskData_t * TopTaskData = 0;
0049F0  EB0200     CLR W4
0049F2  980F24     MOV W4, [W14+20]
32:                    
33:                    //initialize the clock speed and the output latches of the pic
34:                    PICInit();
0049F4  070091     RCALL PICInit
35:                
36:                    
37:                    //create any shared variables
38:                    char * SPIConfigured = pvPortMalloc(sizeof(char));
0049F6  200010     MOV #0x1, W0
0049F8  024240     CALL pvPortMalloc
0049FA  000000     NOP
0049FC  780200     MOV W0, W4
0049FE  780F04     MOV W4, [W14]
39:                    
40:                    CreateLCDTask(&LCDTaskData,&LCDTaskRef, SPIConfigured);
004A00  4702E4     ADD W14, #0x4, W5
004A02  47026E     ADD W14, #0xE, W4
004A04  78011E     MOV [W14], W2
004A06  780085     MOV W5, W1
004A08  780004     MOV W4, W0
004A0A  02448C     CALL CreateLCDTask
004A0C  000000     NOP
41:                    
42:                    CreateTemperatureTask(&TemperatureTaskData,&TemperatureTaskRef,
004A10  780314     MOV [W4], W6
004A12  4702E6     ADD W14, #0x6, W5
004A14  470270     ADD W14, #0x10, W4
004A16  780106     MOV W6, W2
004A18  780085     MOV W5, W1
004A1A  780004     MOV W4, W0
004A1C  023CFE     CALL CreateTemperatureTask
004A1E  000000     NOP
43:                            LCDTaskData->LCDQueue);
004A0E  90027E     MOV [W14+14], W4
44:                    
45:                    CreateCC2500Task(&CC2500TaskData, &CC2500TaskRef, LCDTaskData->LCDQueue,
004A20  90027E     MOV [W14+14], W4
004A22  780314     MOV [W4], W6
004A24  4702E8     ADD W14, #0x8, W5
004A26  470272     ADD W14, #0x12, W4
004A28  78019E     MOV [W14], W3
004A2A  780106     MOV W6, W2
004A2C  780085     MOV W5, W1
004A2E  780004     MOV W4, W0
004A30  023FC4     CALL CreateCC2500Task
004A32  000000     NOP
46:                            SPIConfigured);
47:                    
48:                    CreateMonitorTask(&MonitorTaskData,&MonitorTaskRef,5,LCDTaskData->LCDQueue);
004A34  90027E     MOV [W14+14], W4
004A36  780314     MOV [W4], W6
004A38  E8828E     INC2 W14, W5
004A3A  47026C     ADD W14, #0xC, W4
004A3C  780186     MOV W6, W3
004A3E  B3C052     MOV.B #0x5, W2
004A40  780085     MOV W5, W1
004A42  780004     MOV W4, W0
004A44  024C58     CALL CreateMonitorTask
004A46  000000     NOP
49:                    MonitorTaskData->Tasks[MONITOR_TASK] = MonitorTaskRef;
004A48  90026E     MOV [W14+12], W4
004A4A  780214     MOV [W4], W4
004A4C  90029E     MOV [W14+2], W5
004A4E  780A05     MOV W5, [W4]
50:                    MonitorTaskData->Tasks[LCD_TASK] = LCDTaskRef;
004A50  90026E     MOV [W14+12], W4
004A52  780214     MOV [W4], W4
004A54  E88204     INC2 W4, W4
004A56  9002AE     MOV [W14+4], W5
004A58  780A05     MOV W5, [W4]
51:                    MonitorTaskData->Tasks[TEMPERATURE_TASK] = TemperatureTaskRef;
004A5A  90026E     MOV [W14+12], W4
004A5C  780214     MOV [W4], W4
004A5E  420264     ADD W4, #0x4, W4
004A60  9002BE     MOV [W14+6], W5
004A62  780A05     MOV W5, [W4]
52:                    MonitorTaskData->Tasks[CC2500_TASK] = CC2500TaskRef;
004A64  90026E     MOV [W14+12], W4
004A66  780214     MOV [W4], W4
004A68  420266     ADD W4, #0x6, W4
004A6A  9002CE     MOV [W14+8], W5
004A6C  780A05     MOV W5, [W4]
53:                    MonitorTaskData->Tasks[TOP_TASK] = 0;
004A6E  90026E     MOV [W14+12], W4
004A70  780214     MOV [W4], W4
004A72  420268     ADD W4, #0x8, W4
004A74  EB0280     CLR W5
004A76  780A05     MOV W5, [W4]
54:                
55:                    CreateTopTask(&TopTaskData,&TopTaskRef,MonitorTaskData->Tasks);
004A78  90026E     MOV [W14+12], W4
004A7A  780314     MOV [W4], W6
004A7C  4702EA     ADD W14, #0xA, W5
004A7E  470274     ADD W14, #0x14, W4
004A80  780106     MOV W6, W2
004A82  780085     MOV W5, W1
004A84  780004     MOV W4, W0
004A86  070025     RCALL CreateTopTask
56:                    
57:                    
58:                    MonitorTaskData->Tasks[TOP_TASK] = TopTaskRef;
004A88  90026E     MOV [W14+12], W4
004A8A  780214     MOV [W4], W4
004A8C  420268     ADD W4, #0x8, W4
004A8E  9002DE     MOV [W14+10], W5
004A90  780A05     MOV W5, [W4]
59:                    
60:                
61:                    
62:                    
63:                    vTaskStartScheduler();
004A92  0218CE     CALL vTaskStartScheduler
004A94  000000     NOP
64:                    while(1)
65:                        Nop();
004A96  000000     NOP
004A98  37FFFE     BRA 0x4A96
66:                    
67:                    return 0;
68:                }
69:                
70:                void DebounceTimer(TimerHandle_t xTimer)
71:                {
004A9A  FA0002     LNK #0x2
004A9C  780F00     MOV W0, [W14]
72:                    
73:                }
004A9E  FA8000     ULNK
004AA0  060000     RETURN
74:                void TopTask(void * parameters)
75:                {
004AA2  FA0006     LNK #0x6
004AA4  980720     MOV W0, [W14+4]
76:                    pMessage Message = 0;
004AA6  EB0200     CLR W4
004AA8  980714     MOV W4, [W14+2]
77:                    TopTaskData_t * Data = (TopTaskData_t*) parameters;
004AAA  90022E     MOV [W14+4], W4
004AAC  780F04     MOV W4, [W14]
78:                    TopQueue = MessageQueueCreate(10);
004AAE  B3C0A0     MOV.B #0xA, W0
004AB0  024E9E     CALL MessageQueueCreate
004AB2  000000     NOP
004AB4  780200     MOV W0, W4
004AB6  8B02E4     MOV W4, TopQueue
79:                    Data->TopQueue = TopQueue;
004AB8  8302E5     MOV TopQueue, W5
004ABA  78021E     MOV [W14], W4
004ABC  980235     MOV W5, [W4+6]
80:                
81:                    //xTimerCreate("Debounce",300,pdFALSE,0,DebounceTimer);
82:                    while(1)
83:                    {
84:                        MessageReceive(Data->TopQueue,&Message,1000);
004ABE  78021E     MOV [W14], W4
004AC0  900234     MOV [W4+6], W4
004AC2  E8828E     INC2 W14, W5
004AC4  203E82     MOV #0x3E8, W2
004AC6  780085     MOV W5, W1
004AC8  780004     MOV W4, W0
004ACA  024ED2     CALL MessageReceive
004ACC  000000     NOP
85:                        Nop();
004ACE  000000     NOP
86:                    }
004AD0  37FFF6     BRA 0x4ABE
87:                }
88:                
89:                BaseType_t CreateTopTask(TopTaskData_t ** TopTaskData,
90:                        TaskHandle_t * TaskRef, TaskHandle_t * Tasks)
91:                {
004AD2  FA0008     LNK #0x8
004AD4  980710     MOV W0, [W14+2]
004AD6  980721     MOV W1, [W14+4]
004AD8  980732     MOV W2, [W14+6]
92:                    BaseType_t pass = pdFAIL;
004ADA  EB0200     CLR W4
004ADC  780F04     MOV W4, [W14]
93:                    (*TopTaskData) = pvPortMalloc(sizeof(TopTaskData));
004ADE  200020     MOV #0x2, W0
004AE0  024240     CALL pvPortMalloc
004AE2  000000     NOP
004AE4  780200     MOV W0, W4
004AE6  780284     MOV W4, W5
004AE8  90021E     MOV [W14+2], W4
004AEA  780A05     MOV W5, [W4]
94:                    
95:                    (*TopTaskData)->Tasks = Tasks;
004AEC  90021E     MOV [W14+2], W4
004AEE  780214     MOV [W4], W4
004AF0  9002BE     MOV [W14+6], W5
004AF2  780A05     MOV W5, [W4]
96:                    
97:                    pass = xTaskCreate(TopTask,"Top",200,(*TopTaskData),
004AF4  90021E     MOV [W14+2], W4
004AF6  780014     MOV [W4], W0
004AF8  EB0380     CLR W7
004AFA  EB0300     CLR W6
004AFC  9002AE     MOV [W14+4], W5
004AFE  200044     MOV #0x4, W4
004B00  780180     MOV W0, W3
004B02  200C82     MOV #0xC8, W2
004B04  294161     MOV #0x9416, W1
004B06  24AA20     MOV #0x4AA2, W0
004B08  021422     CALL xTaskGenericCreate
004B0A  000000     NOP
004B0C  780200     MOV W0, W4
004B0E  780F04     MOV W4, [W14]
98:                            configMAX_PRIORITIES-1,TaskRef);
99:                    
100:                   return pass;
004B10  78021E     MOV [W14], W4
101:                   
102:               }
004B12  780004     MOV W4, W0
004B14  FA8000     ULNK
004B16  060000     RETURN
103:                   
104:                   
105:               
106:               
107:               
108:               /**
109:                * Initializes the PIC, sets pins to input and Fcy to 60MHz
110:                */
111:               void PICInit(void)
112:               {
004B18  FA0000     LNK #0x0
113:                   CLKDIV = 0x00;
004B1A  EB0200     CLR W4
004B1C  883A24     MOV W4, CLKDIV
114:                   PLLFBD = 63;            //somehow 63 puts Fcy close to 60MHz -> (60.24-59.88)
004B1E  2003F4     MOV #0x3F, W4
004B20  883A34     MOV W4, PLLFBD
115:               
116:                   //configure output ports
117:                   TRISA = 0xFFFF;         //set to HIGH-Z
004B22  EB8200     SETM W4
004B24  887004     MOV W4, TRISA
118:                   TRISB = 0xFFFF;         //set to HIGH-Z
004B26  EB8200     SETM W4
004B28  887084     MOV W4, TRISB
119:               }
004B2A  FA8000     ULNK
004B2C  060000     RETURN
120:               
121:               /*
122:               void __attribute__((__interrupt__, auto_psv)) _INT0Interrupt( void )
123:               {
124:               
125:               portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
126:               
127:                   pMessage Message = MessageCreate(0);
128:                   pMessage->Command = TOP_COMMAND_INT;
129:                   
130:                   xQueueSendFromISR(TopQueue,&Message,&xHigherPriorityTaskWoken);
131:               
132:                   
133:                   
134:                   //if we woke a higher priority task than the one that was interrupted
135:                   //via the interrupt, we need to exit this ISR in a way that will cause
136:                   //a context switch
137:               	if( xHigherPriorityTaskWoken != pdFALSE )
138:               	{
139:               		taskYIELD();
140:               	}
141:               }
142:                * 
143:                * */
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/c/TemperatureTask.c
1:                 #include "TemperatureTask.h"
2:                 
3:                 
4:                 
5:                 BaseType_t CreateTemperatureTask(TemperatureTaskData_t ** TemperatureTaskData,
6:                         TaskHandle_t * TaskRef, QueueHandle_t LCDQueue)
7:                 {
003CFE  FA0008     LNK #0x8
003D00  980710     MOV W0, [W14+2]
003D02  980721     MOV W1, [W14+4]
003D04  980732     MOV W2, [W14+6]
8:                     BaseType_t pass = pdFAIL;
003D06  EB0200     CLR W4
003D08  780F04     MOV W4, [W14]
9:                     (*TemperatureTaskData) = pvPortMalloc(sizeof(TemperatureTaskData_t));
003D0A  200120     MOV #0x12, W0
003D0C  024240     CALL pvPortMalloc
003D0E  000000     NOP
003D10  780200     MOV W0, W4
003D12  780284     MOV W4, W5
003D14  90021E     MOV [W14+2], W4
003D16  780A05     MOV W5, [W4]
10:                    (*TemperatureTaskData)->LCDQueue = LCDQueue;
003D18  90021E     MOV [W14+2], W4
003D1A  780214     MOV [W4], W4
003D1C  9002BE     MOV [W14+6], W5
003D1E  780A05     MOV W5, [W4]
11:                    pass = xTaskCreate(TemperatureTask,"Temp",200,
003D20  90021E     MOV [W14+2], W4
003D22  780014     MOV [W4], W0
003D24  EB0380     CLR W7
003D26  EB0300     CLR W6
003D28  9002AE     MOV [W14+4], W5
003D2A  200014     MOV #0x1, W4
003D2C  780180     MOV W0, W3
003D2E  200C82     MOV #0xC8, W2
003D30  294101     MOV #0x9410, W1
003D32  23D440     MOV #0x3D44, W0
003D34  021422     CALL xTaskGenericCreate
003D36  000000     NOP
003D38  780200     MOV W0, W4
003D3A  780F04     MOV W4, [W14]
12:                            (*TemperatureTaskData),TEMPERATURE_TASK_PRIORITY,TaskRef);
13:                    
14:                    return pass;
003D3C  78021E     MOV [W14], W4
15:                }
003D3E  780004     MOV W4, W0
003D40  FA8000     ULNK
003D42  060000     RETURN
16:                
17:                
18:                void TemperatureTask(void * parameters)
19:                {
003D44  FA0008     LNK #0x8
003D46  980730     MOV W0, [W14+6]
20:                
21:                    double average;
22:                    //char string[16];
23:                    //LCDMessage_t * Message;
24:                    TemperatureTaskData_t * Data = (TemperatureTaskData_t * )parameters;
003D48  90023E     MOV [W14+6], W4
003D4A  780F04     MOV W4, [W14]
25:                    
26:                    ConfigADC();
003D4C  070051     RCALL ConfigADC
27:                    
28:                    while(1)
29:                    {
30:                        IFS0bits.AD1IF = 0;
003D4E  A9A801     BCLR 0x801, #5
31:                
32:                        AD1CON1bits.SAMP = 1;
003D50  A82320     BSET AD1CON1, #1
33:                
34:                        while(IFS0bits.AD1IF < 1)
003D52  370001     BRA 0x3D56
003D56  804004     MOV IFS0, W4
003D58  DE224D     LSR W4, #13, W4
003D5A  624261     AND.B W4, #0x1, W4
003D5C  FB8204     ZE W4, W4
003D5E  520FE0     SUB W4, #0x0, [W15]
003D60  34FFF9     BRA LE, 0x3D54
35:                            Nop();
003D54  000000     NOP
36:                
37:                        average = RemoveOutliersAverage();
003D62  070081     RCALL RemoveOutliersAverage
003D64  BE0200     MOV.D W0, W4
003D66  980714     MOV W4, [W14+2]
003D68  980725     MOV W5, [W14+4]
38:                
39:                
40:                        Data->Volts = average/4096.0 * 3.3;
003D6A  200002     MOV #0x0, W2
003D6C  245803     MOV #0x4580, W3
003D6E  90001E     MOV [W14+2], W0
003D70  9000AE     MOV [W14+4], W1
003D72  02045E     CALL ___divsf3
003D74  000000     NOP
003D76  BE0200     MOV.D W0, W4
003D78  233332     MOV #0x3333, W2
003D7A  240533     MOV #0x4053, W3
003D7C  BE0004     MOV.D W4, W0
003D7E  020568     CALL ___mulsf3
003D80  000000     NOP
003D82  BE0200     MOV.D W0, W4
003D84  78031E     MOV [W14], W6
003D86  980374     MOV W4, [W6+14]
003D88  980B05     MOV W5, [W6+16]
41:                        Data->Kelvin = Data->Volts * 2 * 100;
003D8A  78021E     MOV [W14], W4
003D8C  900A84     MOV [W4+16], W5
003D8E  900274     MOV [W4+14], W4
003D90  BE0104     MOV.D W4, W2
003D92  BE0004     MOV.D W4, W0
003D94  0203A4     CALL ___addsf3
003D96  000000     NOP
003D98  BE0200     MOV.D W0, W4
003D9A  200002     MOV #0x0, W2
003D9C  242C83     MOV #0x42C8, W3
003D9E  BE0004     MOV.D W4, W0
003DA0  020568     CALL ___mulsf3
003DA2  000000     NOP
003DA4  BE0200     MOV.D W0, W4
003DA6  78031E     MOV [W14], W6
003DA8  980314     MOV W4, [W6+2]
003DAA  980325     MOV W5, [W6+4]
42:                        Data->Celsius = Data->Kelvin - 273.15;
003DAC  78021E     MOV [W14], W4
003DAE  9002A4     MOV [W4+4], W5
003DB0  900214     MOV [W4+2], W4
003DB2  293332     MOV #0x9333, W2
003DB4  243883     MOV #0x4388, W3
003DB6  BE0004     MOV.D W4, W0
003DB8  0203A2     CALL ___subsf3
003DBA  000000     NOP
003DBC  BE0200     MOV.D W0, W4
003DBE  78031E     MOV [W14], W6
003DC0  980354     MOV W4, [W6+10]
003DC2  980365     MOV W5, [W6+12]
43:                        Data->Fahrenheit = 32 + 1.8 * Data->Celsius;
003DC4  78021E     MOV [W14], W4
003DC6  9002E4     MOV [W4+12], W5
003DC8  900254     MOV [W4+10], W4
003DCA  266662     MOV #0x6666, W2
003DCC  23FE63     MOV #0x3FE6, W3
003DCE  BE0004     MOV.D W4, W0
003DD0  020568     CALL ___mulsf3
003DD2  000000     NOP
003DD4  BE0200     MOV.D W0, W4
003DD6  200002     MOV #0x0, W2
003DD8  242003     MOV #0x4200, W3
003DDA  BE0004     MOV.D W4, W0
003DDC  0203A4     CALL ___addsf3
003DDE  000000     NOP
003DE0  BE0200     MOV.D W0, W4
003DE2  78031E     MOV [W14], W6
003DE4  980334     MOV W4, [W6+6]
003DE6  980345     MOV W5, [W6+8]
44:                        
45:                        /*
46:                        Message = CreateWriteLineLCDMessage(string,
47:                                sprintf(string,"Volts: %.3f",Data->Volts),0);
48:                        MessageSend(Data->LCDQueue,&Message,0);
49:                        
50:                        Message = CreateWriteLineLCDMessage(string,
51:                                sprintf(string,"Temp: %.1f",Data->Fahrenheit),1);
52:                        MessageSend(Data->LCDQueue,&Message,0);
53:                        */
54:                        vTaskDelay(8000);
003DE8  21F400     MOV #0x1F40, W0
003DEA  021602     CALL vTaskDelay
003DEC  000000     NOP
55:                    }
003DEE  37FFAF     BRA 0x3D4E
56:                    
57:                }
58:                
59:                
60:                int ConfigADC()
61:                {
003DF0  FA0000     LNK #0x0
62:                    AD1CON1bits.ADSIDL = 1;     //disable module in idle mode
003DF2  A8A321     BSET 0x321, #5
63:                    AD1CON1bits.ADDMABM = 1;    //DMA buffers are written in order of
003DF4  A88321     BSET 0x321, #4
64:                                                //conversion (not used)
65:                    AD1CON1bits.AD12B = 1;      //12 bit mode
003DF6  A84321     BSET 0x321, #2
66:                    AD1CON1bits.FORM = 0b00;    //Integer 0000 xxxx xxxx xxxx
003DF8  801904     MOV AD1CON1, W4
003DFA  A18004     BCLR W4, #8
003DFC  A19004     BCLR W4, #9
003DFE  881904     MOV W4, AD1CON1
67:                    AD1CON1bits.SSRC = 0b111;   //internal counter handles conversion (auto)
003E00  801904     MOV AD1CON1, W4
003E02  A05004     BSET W4, #5
003E04  A06004     BSET W4, #6
003E06  A07004     BSET W4, #7
003E08  881904     MOV W4, AD1CON1
68:                    AD1CON1bits.SSRCG = 0b0;    //needed for SSRC
003E0A  A98320     BCLR AD1CON1, #4
69:                    AD1CON1bits.SIMSAM = 0;     //channels sampled in sequence
003E0C  A96320     BCLR AD1CON1, #3
70:                    AD1CON1bits.ASAM = 1;       //auto sample after conversion
003E0E  A84320     BSET AD1CON1, #2
71:                
72:                    AD1CON2bits.VCFG = 0b000;   //AVdd and AVss used as references
003E10  801914     MOV AD1CON2, W4
003E12  A1D004     BCLR W4, #13
003E14  A1E004     BCLR W4, #14
003E16  A1F004     BCLR W4, #15
003E18  881914     MOV W4, AD1CON2
73:                    AD1CON2bits.CSCNA = 0;      //dont scan inputs, only convert one channel
003E1A  A94323     BCLR 0x323, #2
74:                    AD1CON2bits.CHPS = 0b00;    //converts channel 0
003E1C  801914     MOV AD1CON2, W4
003E1E  A18004     BCLR W4, #8
003E20  A19004     BCLR W4, #9
003E22  881914     MOV W4, AD1CON2
75:                    AD1CON2bits.SMPI = 0xf; //generate interrupt after every 16th sample
003E24  801915     MOV AD1CON2, W5
003E26  2FF834     MOV #0xFF83, W4
003E28  628284     AND W5, W4, W5
003E2A  2003C4     MOV #0x3C, W4
003E2C  720205     IOR W4, W5, W4
003E2E  881914     MOV W4, AD1CON2
76:                    AD1CON2bits.BUFM = 0;       //always start filling the buffer from start
003E30  A92322     BCLR AD1CON2, #1
77:                    AD1CON2bits.ALTS = 0;       //always use channel input from MUXA
003E32  A90322     BCLR AD1CON2, #0
78:                
79:                    AD1CON3bits.ADRC = 0;       //use ADC internal RC clock
003E34  A9E325     BCLR 0x325, #7
80:                    AD1CON3bits.SAMC = 0b11111; //auto sample time bits: 31 T_AD
003E36  801925     MOV AD1CON3, W5
003E38  21F004     MOV #0x1F00, W4
003E3A  720205     IOR W4, W5, W4
003E3C  881924     MOV W4, AD1CON3
81:                    AD1CON3bits.ADCS = 0xFF;    //TP*(ADCS<7:0> + 1) = TP*256 = TAD
003E3E  EBC200     SETM.B W4
003E40  780004     MOV W4, W0
003E42  B7E324     MOV.B WREG, AD1CON3
82:                
83:                
84:                    AD1CON4bits.ADDMAEN = 0;    //dont use DMA, just use ADCBUFF
003E44  A90333     BCLR 0x333, #0
85:                
86:                    AD1CHS123bits.CH123NA = 0;  //VREFL for negative input
003E46  801934     MOV AD1CHS123, W4
003E48  A11004     BCLR W4, #1
003E4A  A12004     BCLR W4, #2
003E4C  881934     MOV W4, AD1CHS123
87:                    AD1CHS0bits.CH0NA = 0;      //channel 0 negative input is VRFL
003E4E  A9E328     BCLR AD1CHS0, #7
88:                    AD1CHS0bits.CH0SA = 0;      //channel 0 = AN0
003E50  801945     MOV AD1CHS0, W5
003E52  2FFE04     MOV #0xFFE0, W4
003E54  628204     AND W5, W4, W4
003E56  881944     MOV W4, AD1CHS0
89:                    ANSELAbits.ANSA0 = 1;       //enable analog buffer
003E58  A80E0E     BSET ANSELA, #0
90:                    TRISAbits.TRISA0 = 1;       //set as input
003E5A  A80E00     BSET TRISA, #0
91:                
92:                    AD1CON1bits.ADON = 1;           //AD module is on
003E5C  A8E321     BSET 0x321, #7
93:                
94:                    return 0;
003E5E  EB0200     CLR W4
95:                }
003E60  780004     MOV W4, W0
003E62  FA8000     ULNK
003E64  060000     RETURN
96:                
97:                
98:                
99:                
100:               /**
101:                * Computes the average of the non-outlying ADCBUF registers. This is 
102:                * accomplished by first finding the value with the least sum differential
103:                * to the other 15 values. Then, any ADCBUF value that is within 5 points
104:                * of the min-differential value is considered good, all others are considered
105:                * outliers and are not used in the average calculation.
106:                * @return The computed average. Returns 0 if no coherent data was found
107:                */
108:               double RemoveOutliersAverage(void)
109:               {
003E66  FA0010     LNK #0x10
110:                   double retval;
111:                   unsigned char i,j, index;
112:                   long * differential = pvPortMalloc(sizeof(long)*16);
003E68  200400     MOV #0x40, W0
003E6A  024240     CALL pvPortMalloc
003E6C  000000     NOP
003E6E  780200     MOV W0, W4
003E70  980774     MOV W4, [W14+14]
113:                   long min;
114:                   
115:                   //loop through each item in the ADC buffer and find the value with the
116:                   //lowest sum of differences to the other values
117:                   for(j=0;j<16;j++)
003E72  EB4200     CLR.B W4
003E74  984754     MOV.B W4, [W14+5]
003E76  37004D     BRA 0x3F12
003F0C  90425E     MOV.B [W14+5], W4
003F0E  E84204     INC.B W4, W4
003F10  984754     MOV.B W4, [W14+5]
003F12  90425E     MOV.B [W14+5], W4
003F14  524FEF     SUB.B W4, #0xF, [W15]
003F16  36FFB0     BRA LEU, 0x3E78
118:                   {
119:                       differential[j] = 0;
003E78  90425E     MOV.B [W14+5], W4
003E7A  FB8204     ZE W4, W4
003E7C  DD2242     SL W4, #2, W4
003E7E  9002FE     MOV [W14+14], W5
003E80  428304     ADD W5, W4, W6
003E82  B82260     MUL.UU W4, #0, W4
003E84  BE8B04     MOV.D W4, [W6]
120:                       for(i=0;i<16;i++)
003E86  EB4200     CLR.B W4
003E88  984744     MOV.B W4, [W14+4]
003E8A  370023     BRA 0x3ED2
003ECC  90424E     MOV.B [W14+4], W4
003ECE  E84204     INC.B W4, W4
003ED0  984744     MOV.B W4, [W14+4]
003ED2  90424E     MOV.B [W14+4], W4
003ED4  524FEF     SUB.B W4, #0xF, [W15]
003ED6  36FFDA     BRA LEU, 0x3E8C
121:                           differential[j] += abs((&ADC1BUF0)[j]-(&ADC1BUF0)[i]);
003E8C  90425E     MOV.B [W14+5], W4
003E8E  FB8204     ZE W4, W4
003E90  DD2242     SL W4, #2, W4
003E92  9002FE     MOV [W14+14], W5
003E94  428004     ADD W5, W4, W0
003E96  90425E     MOV.B [W14+5], W4
003E98  FB8204     ZE W4, W4
003E9A  DD2242     SL W4, #2, W4
003E9C  9002FE     MOV [W14+14], W5
003E9E  428204     ADD W5, W4, W4
003EA0  BE0314     MOV.D [W4], W6
003EA2  90425E     MOV.B [W14+5], W4
003EA4  FB8204     ZE W4, W4
003EA6  420204     ADD W4, W4, W4
003EA8  780284     MOV W4, W5
003EAA  203004     MOV #0x300, W4
003EAC  428204     ADD W5, W4, W4
003EAE  780294     MOV [W4], W5
003EB0  90424E     MOV.B [W14+4], W4
003EB2  FB8204     ZE W4, W4
003EB4  420204     ADD W4, W4, W4
003EB6  780084     MOV W4, W1
003EB8  203004     MOV #0x300, W4
003EBA  408204     ADD W1, W4, W4
003EBC  780214     MOV [W4], W4
003EBE  528204     SUB W5, W4, W4
003EC0  A7F004     BTSC W4, #15
003EC2  EA0204     NEG W4, W4
003EC4  DEA2CF     ASR W4, #15, W5
003EC6  420206     ADD W4, W6, W4
003EC8  4A8287     ADDC W5, W7, W5
003ECA  BE8804     MOV.D W4, [W0]
122:                       
123:                       if(0==j)
003ED8  90425E     MOV.B [W14+5], W4
003EDA  524FE0     SUB.B W4, #0x0, [W15]
003EDC  3A0007     BRA NZ, 0x3EEC
124:                       {
125:                           min = differential[0];
003EDE  90027E     MOV [W14+14], W4
003EE0  BE0314     MOV.D [W4], W6
003EE2  980746     MOV W6, [W14+8]
003EE4  980757     MOV W7, [W14+10]
126:                           index = 0;
003EE6  EB4200     CLR.B W4
003EE8  984764     MOV.B W4, [W14+6]
003EEA  370010     BRA 0x3F0C
127:                       }
128:                       else
129:                       {
130:                           //update the minimum index and value as needed
131:                           min = (min < differential[j])?min:differential[j];
003EEC  90425E     MOV.B [W14+5], W4
003EEE  FB8204     ZE W4, W4
003EF0  DD2242     SL W4, #2, W4
003EF2  9002FE     MOV [W14+14], W5
003EF4  428204     ADD W5, W4, W4
003EF6  BE0214     MOV.D [W4], W4
003EF8  90034E     MOV [W14+8], W6
003EFA  9003DE     MOV [W14+10], W7
003EFC  520F86     SUB W4, W6, [W15]
003EFE  5A8F87     SUBB W5, W7, [W15]
003F00  340001     BRA LE, 0x3F04
003F02  BE0206     MOV.D W6, W4
003F04  980744     MOV W4, [W14+8]
003F06  980755     MOV W5, [W14+10]
132:                           index = j;
003F08  9043DE     MOV.B [W14+5], W7
003F0A  984767     MOV.B W7, [W14+6]
133:                       }
134:                   }
135:                   //now convert min to contain the actually value of the ADC value with 
136:                   //the lowest differential
137:                   min = (&ADC1BUF0)[index];
003F18  90426E     MOV.B [W14+6], W4
003F1A  FB8204     ZE W4, W4
003F1C  420204     ADD W4, W4, W4
003F1E  780284     MOV W4, W5
003F20  203004     MOV #0x300, W4
003F22  428204     ADD W5, W4, W4
003F24  780214     MOV [W4], W4
003F26  200005     MOV #0x0, W5
003F28  980744     MOV W4, [W14+8]
003F2A  980755     MOV W5, [W14+10]
138:                   
139:                   char count = 0;
003F2C  EB4200     CLR.B W4
003F2E  984F44     MOV.B W4, [W14+12]
140:                   retval = 0;
003F30  B82260     MUL.UU W4, #0, W4
003F32  BE8F04     MOV.D W4, [W14]
141:                   for(i=0;i<16;i++)
003F34  EB4200     CLR.B W4
003F36  984744     MOV.B W4, [W14+4]
003F38  370029     BRA 0x3F8C
003F86  90424E     MOV.B [W14+4], W4
003F88  E84204     INC.B W4, W4
003F8A  984744     MOV.B W4, [W14+4]
003F8C  90424E     MOV.B [W14+4], W4
003F8E  524FEF     SUB.B W4, #0xF, [W15]
003F90  36FFD4     BRA LEU, 0x3F3A
142:                   {
143:                       if(min-(&ADC1BUF0)[i] < 5)
003F3A  90424E     MOV.B [W14+4], W4
003F3C  FB8204     ZE W4, W4
003F3E  420204     ADD W4, W4, W4
003F40  780284     MOV W4, W5
003F42  203004     MOV #0x300, W4
003F44  428204     ADD W5, W4, W4
003F46  780214     MOV [W4], W4
003F48  200005     MOV #0x0, W5
003F4A  90034E     MOV [W14+8], W6
003F4C  9003DE     MOV [W14+10], W7
003F4E  530304     SUB W6, W4, W6
003F50  5B8385     SUBB W7, W5, W7
003F52  200044     MOV #0x4, W4
003F54  200005     MOV #0x0, W5
003F56  530F84     SUB W6, W4, [W15]
003F58  5B8F85     SUBB W7, W5, [W15]
003F5A  3C0015     BRA GT, 0x3F86
144:                       {
145:                           retval += (&ADC1BUF0)[i];
003F5C  90424E     MOV.B [W14+4], W4
003F5E  FB8204     ZE W4, W4
003F60  420204     ADD W4, W4, W4
003F62  780284     MOV W4, W5
003F64  203004     MOV #0x300, W4
003F66  428204     ADD W5, W4, W4
003F68  780214     MOV [W4], W4
003F6A  200005     MOV #0x0, W5
003F6C  BE0004     MOV.D W4, W0
003F6E  0204E8     CALL ___floatunsisf
003F70  000000     NOP
003F72  BE0200     MOV.D W0, W4
003F74  BE0104     MOV.D W4, W2
003F76  BE001E     MOV.D [W14], W0
003F78  0203A4     CALL ___addsf3
003F7A  000000     NOP
003F7C  BE0200     MOV.D W0, W4
003F7E  BE8F04     MOV.D W4, [W14]
146:                           count++;
003F80  904A4E     MOV.B [W14+12], W4
003F82  E84204     INC.B W4, W4
003F84  984F44     MOV.B W4, [W14+12]
147:                       }
148:                   }
149:                   //compute the average of non-outlying data set
150:                   //return 0 if count = 0;
151:                   retval = (count)?retval / count:0;
003F92  904A4E     MOV.B [W14+12], W4
003F94  524FE0     SUB.B W4, #0x0, [W15]
003F96  32000D     BRA Z, 0x3FB2
003F98  904A4E     MOV.B [W14+12], W4
003F9A  FB0204     SE W4, W4
003F9C  DEA2CF     ASR W4, #15, W5
003F9E  BE0004     MOV.D W4, W0
003FA0  0204E2     CALL ___floatsisf
003FA2  000000     NOP
003FA4  BE0200     MOV.D W0, W4
003FA6  BE0104     MOV.D W4, W2
003FA8  BE001E     MOV.D [W14], W0
003FAA  02045E     CALL ___divsf3
003FAC  000000     NOP
003FAE  BE0200     MOV.D W0, W4
003FB0  370001     BRA 0x3FB4
003FB2  B82260     MUL.UU W4, #0, W4
003FB4  BE8F04     MOV.D W4, [W14]
152:                   //clean up
153:                   vPortFree(differential);
003FB6  90007E     MOV [W14+14], W0
003FB8  024330     CALL vPortFree
003FBA  000000     NOP
154:                   
155:                   return retval;
003FBC  BE021E     MOV.D [W14], W4
156:               }
003FBE  BE0004     MOV.D W4, W0
003FC0  FA8000     ULNK
003FC2  060000     RETURN
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/c/MonitorTask.c  --
1:                 #include "MonitorTask.h"
2:                 
3:                 /**
4:                  * Creates the Monitor Task. The user may modify it's data after calling this
5:                  * method.
6:                  * @param MonitorTaskData Pointer to the Monitor Task data. This function
7:                  * will allocate the necessary space under the hood.
8:                  * @param TaskRef Reference to the Monitor Task
9:                  * @param TaskCount The number of tasks that Monitor Task will be managing
10:                 * @param LCDQueue Reference to the LCD Queue that this task should use to send
11:                 * updated
12:                 * @return  pdPASS (1) on success, pdFAIL(0) on failure
13:                 */
14:                BaseType_t CreateMonitorTask(MonitorTaskData_t ** MonitorTaskData,
15:                        TaskHandle_t * TaskRef, unsigned char TaskCount, QueueHandle_t LCDQueue)
16:                {
004C58  FA000A     LNK #0xA
004C5A  781F88     MOV W8, [W15++]
004C5C  980710     MOV W0, [W14+2]
004C5E  980721     MOV W1, [W14+4]
004C60  984762     MOV.B W2, [W14+6]
004C62  980743     MOV W3, [W14+8]
17:                    BaseType_t pass;
18:                    
19:                    //allocate space for the task data
20:                    (*MonitorTaskData) = pvPortMalloc(sizeof(MonitorTaskData_t));
004C64  200080     MOV #0x8, W0
004C66  024240     CALL pvPortMalloc
004C68  000000     NOP
004C6A  780200     MOV W0, W4
004C6C  780284     MOV W4, W5
004C6E  90021E     MOV [W14+2], W4
004C70  780A05     MOV W5, [W4]
21:                     
22:                    (*MonitorTaskData)->NumberOfTasks = TaskCount;
004C72  90021E     MOV [W14+2], W4
004C74  780294     MOV [W4], W5
004C76  90426E     MOV.B [W14+6], W4
004C78  9842A4     MOV.B W4, [W5+2]
23:                    //Monitor needs this to send LCD updates
24:                    (*MonitorTaskData)->LCDQueue = LCDQueue;
004C7A  90021E     MOV [W14+2], W4
004C7C  780214     MOV [W4], W4
004C7E  9002CE     MOV [W14+8], W5
004C80  980225     MOV W5, [W4+4]
25:                    (*MonitorTaskData)->Enabled = 1;
004C82  90021E     MOV [W14+2], W4
004C84  780294     MOV [W4], W5
004C86  B3C014     MOV.B #0x1, W4
004C88  9842E4     MOV.B W4, [W5+6]
26:                    //Create the Monitor task, pass in its data, hold on to the task ref
27:                    pass = xTaskCreate(MonitorTask,"Monitor",200,(*MonitorTaskData),
004C8A  90021E     MOV [W14+2], W4
004C8C  780014     MOV [W4], W0
004C8E  EB0380     CLR W7
004C90  EB0300     CLR W6
004C92  9002AE     MOV [W14+4], W5
004C94  EB0200     CLR W4
004C96  780180     MOV W0, W3
004C98  200C82     MOV #0xC8, W2
004C9A  293FA1     MOV #0x93FA, W1
004C9C  24CC40     MOV #0x4CC4, W0
004C9E  021422     CALL xTaskGenericCreate
004CA0  000000     NOP
004CA2  780200     MOV W0, W4
004CA4  780F04     MOV W4, [W14]
28:                            MONITOR_TASK_PRIORITY,TaskRef);
29:                    (*MonitorTaskData)->Tasks = pvPortMalloc(sizeof(TaskHandle_t)*TaskCount);
004CA6  90021E     MOV [W14+2], W4
004CA8  780414     MOV [W4], W8
004CAA  90426E     MOV.B [W14+6], W4
004CAC  FB8204     ZE W4, W4
004CAE  420204     ADD W4, W4, W4
004CB0  780004     MOV W4, W0
004CB2  024240     CALL pvPortMalloc
004CB4  000000     NOP
004CB6  780200     MOV W0, W4
004CB8  780C04     MOV W4, [W8]
30:                
31:                    return pass;
004CBA  78021E     MOV [W14], W4
32:                }
004CBC  780004     MOV W4, W0
004CBE  78044F     MOV [--W15], W8
004CC0  FA8000     ULNK
004CC2  060000     RETURN
33:                
34:                
35:                void MonitorTask(void * parameters)
36:                {
004CC4  FA002C     LNK #0x2C
004CC6  981750     MOV W0, [W14+42]
37:                    unsigned int remaining_stack;
38:                    unsigned int remaining_heap;
39:                    unsigned char loop_count;
40:                    
41:                    char * task_name;
42:                    char text[32];
43:                    MonitorTaskData_t * Data;
44:                    pMessage Message;
45:                
46:                    Data = (MonitorTaskData_t*) parameters;
004CC8  90125E     MOV [W14+42], W4
004CCA  980714     MOV W4, [W14+2]
004CCC  370001     BRA 0x4CD0
47:                    
48:                    while(1)
49:                    {
50:                        if(Data->Enabled)
004CD0  90021E     MOV [W14+2], W4
004CD2  904264     MOV.B [W4+6], W4
004CD4  524FE0     SUB.B W4, #0x0, [W15]
004CD6  32FFFB     BRA Z, 0x4CCE
51:                        {
52:                            for(loop_count = 0;loop_count<Data->NumberOfTasks;loop_count++)
004CD8  EB4200     CLR.B W4
004CDA  784F04     MOV.B W4, [W14]
004CDC  37003E     BRA 0x4D5A
004D58  E84F1E     INC.B [W14], [W14]
004D5A  78421E     MOV.B [W14], W4
004D5C  FB8284     ZE W4, W5
004D5E  90021E     MOV [W14+2], W4
004D60  904224     MOV.B [W4+2], W4
004D62  FB0204     SE W4, W4
004D64  528F84     SUB W5, W4, [W15]
004D66  35FFBB     BRA LT, 0x4CDE
53:                            {
54:                                remaining_stack = uxTaskGetStackHighWaterMark(Data->Tasks[loop_count]);
004CDE  90021E     MOV [W14+2], W4
004CE0  780294     MOV [W4], W5
004CE2  78431E     MOV.B [W14], W6
004CE4  FB8206     ZE W6, W4
004CE6  420204     ADD W4, W4, W4
004CE8  428204     ADD W5, W4, W4
004CEA  780214     MOV [W4], W4
004CEC  780004     MOV W4, W0
004CEE  022192     CALL uxTaskGetStackHighWaterMark
004CF0  000000     NOP
004CF2  780200     MOV W0, W4
004CF4  980724     MOV W4, [W14+4]
55:                
56:                
57:                                //get the task name
58:                                task_name = pcTaskGetTaskName(Data->Tasks[loop_count]);
004CF6  90021E     MOV [W14+2], W4
004CF8  780294     MOV [W4], W5
004CFA  78431E     MOV.B [W14], W6
004CFC  FB8206     ZE W6, W4
004CFE  420204     ADD W4, W4, W4
004D00  428204     ADD W5, W4, W4
004D02  780214     MOV [W4], W4
004D04  780004     MOV W4, W0
004D06  021A16     CALL pcTaskGetTaskName
004D08  000000     NOP
004D0A  780200     MOV W0, W4
004D0C  980734     MOV W4, [W14+6]
59:                               
60:                                sprintf(text,"%s:%d",task_name,remaining_stack);
004D0E  470268     ADD W14, #0x8, W4
004D10  9002AE     MOV [W14+4], W5
004D12  781F85     MOV W5, [W15++]
004D14  90033E     MOV [W14+6], W6
004D16  781F86     MOV W6, [W15++]
004D18  294025     MOV #0x9402, W5
004D1A  781F85     MOV W5, [W15++]
004D1C  780004     MOV W4, W0
004D1E  020862     CALL __sprintf_cdnopsuxX
004D20  000000     NOP
004D22  5787E6     SUB W15, #0x6, W15
61:                
62:                                Message  = CreateWriteLineLCDMessage(text,strlen(text),1);
004D24  470268     ADD W14, #0x8, W4
004D26  780004     MOV W4, W0
004D28  020850     CALL _strlen
004D2A  000000     NOP
004D2C  780200     MOV W0, W4
004D2E  784204     MOV.B W4, W4
004D30  4702E8     ADD W14, #0x8, W5
004D32  B3C012     MOV.B #0x1, W2
004D34  784084     MOV.B W4, W1
004D36  780005     MOV W5, W0
004D38  02462A     CALL CreateWriteLineLCDMessage
004D3A  000000     NOP
004D3C  780200     MOV W0, W4
004D3E  981744     MOV W4, [W14+40]
63:                                MessageSend(Data->LCDQueue,&Message,0);
004D40  90021E     MOV [W14+2], W4
004D42  900224     MOV [W4+4], W4
004D44  200285     MOV #0x28, W5
004D46  42828E     ADD W5, W14, W5
004D48  EB0100     CLR W2
004D4A  780085     MOV W5, W1
004D4C  780004     MOV W4, W0
004D4E  024EB6     CALL MessageSend
004D50  000000     NOP
64:                
65:                                //write Heap:remaining_heap
66:                                //5 because Heap: is 5 chars, 8 for ':' '\\0' and the number
67:                                //remaining_heap = xPortGetFreeHeapSize();
68:                                //sprintf(text,"Heap:%d",remaining_heap);
69:                                //Message = CreateWriteLineLCDMessage(text,strlen(text),1);
70:                                //MessageSend(Data->LCDQueue,&Message,0);
71:                                vTaskDelay(1000);
004D52  203E80     MOV #0x3E8, W0
004D54  021602     CALL vTaskDelay
004D56  000000     NOP
72:                            } 
73:                        }
74:                    }    
004CCE  000000     NOP
004D68  37FFB3     BRA 0x4CD0
75:                }    
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/c/MessageQueue.c  -
1:                 #include "MessageQueue.h"
2:                 
3:                 pMessage MessageCreate(char size)
4:                 {
004E6C  FA0004     LNK #0x4
004E6E  984720     MOV.B W0, [W14+2]
5:                     pMessage retval = 0;
004E70  EB0200     CLR W4
004E72  780F04     MOV W4, [W14]
6:                     retval = pvPortMalloc(sizeof(Message_t));
004E74  200040     MOV #0x4, W0
004E76  024240     CALL pvPortMalloc
004E78  000000     NOP
004E7A  780200     MOV W0, W4
004E7C  780F04     MOV W4, [W14]
7:                     retval->Size = size;
004E7E  78021E     MOV [W14], W4
004E80  9042AE     MOV.B [W14+2], W5
004E82  984215     MOV.B W5, [W4+1]
8:                     retval->Data = pvPortMalloc(size);
004E84  90422E     MOV.B [W14+2], W4
004E86  FB0204     SE W4, W4
004E88  780004     MOV W4, W0
004E8A  024240     CALL pvPortMalloc
004E8C  000000     NOP
004E8E  780200     MOV W0, W4
004E90  780284     MOV W4, W5
004E92  78021E     MOV [W14], W4
004E94  980215     MOV W5, [W4+2]
9:                     return retval;
004E96  78021E     MOV [W14], W4
10:                }
004E98  780004     MOV W4, W0
004E9A  FA8000     ULNK
004E9C  060000     RETURN
11:                
12:                /**
13:                 * Creates a queue that uses pMessages.
14:                 * @param QueueSize The number of elements that can be in the queue at a time.
15:                 * @return Returns a QueueHandle_t to the queue.
16:                 */
17:                QueueHandle_t MessageQueueCreate(char QueueSize)
18:                {
004E9E  FA0002     LNK #0x2
004EA0  784F00     MOV.B W0, [W14]
19:                    return xQueueCreate(QueueSize,sizeof(pMessage));
004EA2  FB021E     SE [W14], W4
004EA4  EB4100     CLR.B W2
004EA6  200021     MOV #0x2, W1
004EA8  780004     MOV W4, W0
004EAA  0224A0     CALL xQueueGenericCreate
004EAC  000000     NOP
004EAE  780200     MOV W0, W4
20:                }
004EB0  780004     MOV W4, W0
004EB2  FA8000     ULNK
004EB4  060000     RETURN
21:                
22:                BaseType_t MessageSend(QueueHandle_t Queue, const pMessage * ppMessage,
23:                        TickType_t TicksToWait)
24:                {
004EB6  FA0006     LNK #0x6
004EB8  780F00     MOV W0, [W14]
004EBA  980711     MOV W1, [W14+2]
004EBC  980722     MOV W2, [W14+4]
25:                    return xQueueSend(Queue, ppMessage, TicksToWait);
004EBE  EB0180     CLR W3
004EC0  90012E     MOV [W14+4], W2
004EC2  90009E     MOV [W14+2], W1
004EC4  78001E     MOV [W14], W0
004EC6  022584     CALL xQueueGenericSend
004EC8  000000     NOP
004ECA  780200     MOV W0, W4
26:                }
004ECC  780004     MOV W4, W0
004ECE  FA8000     ULNK
004ED0  060000     RETURN
27:                
28:                
29:                BaseType_t MessageReceive(QueueHandle_t Queue, pMessage * ppMessage, 
30:                        TickType_t TicksToWait)
31:                {
004ED2  FA0006     LNK #0x6
004ED4  780F00     MOV W0, [W14]
004ED6  980711     MOV W1, [W14+2]
004ED8  980722     MOV W2, [W14+4]
32:                    return xQueueReceive(Queue, ppMessage, TicksToWait);
004EDA  EB0180     CLR W3
004EDC  90012E     MOV [W14+4], W2
004EDE  90009E     MOV [W14+2], W1
004EE0  78001E     MOV [W14], W0
004EE2  0226FA     CALL xQueueGenericReceive
004EE4  000000     NOP
004EE6  780200     MOV W0, W4
33:                }
004EE8  780004     MOV W4, W0
004EEA  FA8000     ULNK
004EEC  060000     RETURN
34:                
35:                /**
36:                 * Frees the memory occupied by the Message
37:                 * @param Message
38:                 */
39:                void MessageDelete(pMessage Message)
40:                {
004EEE  FA0002     LNK #0x2
004EF0  780F00     MOV W0, [W14]
41:                    vPortFree(Message->Data);
004EF2  78021E     MOV [W14], W4
004EF4  900214     MOV [W4+2], W4
004EF6  780004     MOV W4, W0
004EF8  024330     CALL vPortFree
004EFA  000000     NOP
42:                    vPortFree(Message);
004EFC  78001E     MOV [W14], W0
004EFE  024330     CALL vPortFree
004F00  000000     NOP
43:                }
004F02  FA8000     ULNK
004F04  060000     RETURN
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/c/LCDTask.c  ------
1:                 
2:                 #include "LCDTask.h"
3:                 
4:                 BaseType_t CreateLCDTask(LCDTaskData_t ** LCDTaskData,TaskHandle_t * TaskRef,
5:                         char * SPIConfigured)
6:                 {
00448C  FA0008     LNK #0x8
00448E  781F88     MOV W8, [W15++]
004490  980710     MOV W0, [W14+2]
004492  980721     MOV W1, [W14+4]
004494  980732     MOV W2, [W14+6]
7:                     //Create the LCD task, pass in its data, hold on to the task ref for the monitor task
8:                     (*LCDTaskData) = pvPortMalloc(sizeof(LCDTaskData_t));
004496  200040     MOV #0x4, W0
004498  024240     CALL pvPortMalloc
00449A  000000     NOP
00449C  780200     MOV W0, W4
00449E  780284     MOV W4, W5
0044A0  90021E     MOV [W14+2], W4
0044A2  780A05     MOV W5, [W4]
9:                     //this is used to signal when the PIC has had it's SPI module configured
10:                    (*LCDTaskData)->SPIConfigured = SPIConfigured;
0044A4  90021E     MOV [W14+2], W4
0044A6  780214     MOV [W4], W4
0044A8  9002BE     MOV [W14+6], W5
0044AA  980215     MOV W5, [W4+2]
11:                    
12:                    BaseType_t pass = xTaskCreate(LCDTask,"LCD",200,(*LCDTaskData),
0044AC  90021E     MOV [W14+2], W4
0044AE  780014     MOV [W4], W0
0044B0  EB0380     CLR W7
0044B2  EB0300     CLR W6
0044B4  9002AE     MOV [W14+4], W5
0044B6  200034     MOV #0x3, W4
0044B8  780180     MOV W0, W3
0044BA  200C82     MOV #0xC8, W2
0044BC  2941A1     MOV #0x941A, W1
0044BE  244E00     MOV #0x44E0, W0
0044C0  021422     CALL xTaskGenericCreate
0044C2  000000     NOP
0044C4  780200     MOV W0, W4
0044C6  780F04     MOV W4, [W14]
13:                            LCD_TASK_PRIORITY,TaskRef);
14:                    (*LCDTaskData)->LCDQueue = MessageQueueCreate(20);
0044C8  90021E     MOV [W14+2], W4
0044CA  780414     MOV [W4], W8
0044CC  B3C140     MOV.B #0x14, W0
0044CE  024E9E     CALL MessageQueueCreate
0044D0  000000     NOP
0044D2  780200     MOV W0, W4
0044D4  780C04     MOV W4, [W8]
15:                    return pass;
0044D6  78021E     MOV [W14], W4
16:                }
0044D8  780004     MOV W4, W0
0044DA  78044F     MOV [--W15], W8
0044DC  FA8000     ULNK
0044DE  060000     RETURN
17:                
18:                /**
19:                 * This task manages the LCD board. It receives messages and performs
20:                 * the appropriate actions such as writing text to the LCD or turning it off.
21:                 * @param parameters
22:                 */
23:                void LCDTask(void * parameters)
24:                {
0044E0  FA0006     LNK #0x6
0044E2  980720     MOV W0, [W14+4]
25:                    LCDTaskData_t * Data;
26:                
27:                    pMessage Message = 0;
0044E4  EB0200     CLR W4
0044E6  980714     MOV W4, [W14+2]
28:                    Data = (LCDTaskData_t*) parameters;
0044E8  90022E     MOV [W14+4], W4
0044EA  780F04     MOV W4, [W14]
29:                
30:                    LCD_TEST();
0044EC  0247FA     CALL LCD_TEST
0044EE  000000     NOP
31:                    *Data->SPIConfigured = 1;
0044F0  78021E     MOV [W14], W4
0044F2  900294     MOV [W4+2], W5
0044F4  B3C014     MOV.B #0x1, W4
0044F6  784A84     MOV.B W4, [W5]
32:                    
33:                    while(1)
34:                    {
35:                        //process all pending messages
36:                        while(MessageReceive(Data->LCDQueue,&Message,1000))
0044F8  370056     BRA 0x45A6
0045A6  78021E     MOV [W14], W4
0045A8  780214     MOV [W4], W4
0045AA  E8828E     INC2 W14, W5
0045AC  203E82     MOV #0x3E8, W2
0045AE  780085     MOV W5, W1
0045B0  780004     MOV W4, W0
0045B2  024ED2     CALL MessageReceive
0045B4  000000     NOP
0045B6  780200     MOV W0, W4
0045B8  520FE0     SUB W4, #0x0, [W15]
0045BA  3AFF9F     BRA NZ, 0x44FA
0045C4  37FFF0     BRA 0x45A6
37:                        {
38:                            switch(Message->Command)
0044FA  90021E     MOV [W14+2], W4
0044FC  784214     MOV.B [W4], W4
0044FE  FB0204     SE W4, W4
004500  B92361     MUL.SU W4, #1, W6
004502  EB8200     SETM W4
004504  EB8280     SETM W5
004506  420206     ADD W4, W6, W4
004508  4A8287     ADDC W5, W7, W5
00450A  200086     MOV #0x8, W6
00450C  200007     MOV #0x0, W7
00450E  520F86     SUB W4, W6, [W15]
004510  5A8F87     SUBB W5, W7, [W15]
004512  3E0042     BRA GTU, 0x4598
004514  010604     BRA W4
004516  370042     BRA 0x459C
004518  370007     BRA 0x4528
00451A  37000A     BRA 0x4530
00451C  37000D     BRA 0x4538
00451E  370010     BRA 0x4540
004520  370013     BRA 0x4548
004522  370018     BRA 0x4554
004524  370039     BRA 0x4598
004526  37002C     BRA 0x4580
39:                            {
40:                                case COMMAND_INIT:
41:                                    break;
00459C  000000     NOP
42:                                case COMMAND_OFF:
43:                                    LCD_WriteCommand(LCD_CMD_DISPLAY_DOFF_COFF_BOFF);
004528  B3C080     MOV.B #0x8, W0
00452A  02475A     CALL LCD_WriteCommand
00452C  000000     NOP
44:                                    break;
00452E  370037     BRA 0x459E
45:                                case COMMAND_ON:
46:                                    LCD_WriteCommand(LCD_CMD_DISPLAY_DON_COFF_BOFF);
004530  B3C0C0     MOV.B #0xC, W0
004532  02475A     CALL LCD_WriteCommand
004534  000000     NOP
47:                                    break;
004536  370033     BRA 0x459E
48:                                case COMMAND_CLEAR:
49:                                    LCD_WriteCommand(LCD_CMD_CLEAR_DISPLAY);
004538  B3C010     MOV.B #0x1, W0
00453A  02475A     CALL LCD_WriteCommand
00453C  000000     NOP
50:                                    break;
00453E  37002F     BRA 0x459E
51:                                case COMMAND_HOME:
52:                                    LCD_WriteCommand(LCD_CMD_RETURN_HOME);
004540  B3C020     MOV.B #0x2, W0
004542  02475A     CALL LCD_WriteCommand
004544  000000     NOP
53:                                    break;
004546  37002B     BRA 0x459E
54:                                case COMMAND_WRITE:
55:                                    LCD_WriteStringNullTerm(Message->Data);
004548  90021E     MOV [W14+2], W4
00454A  900214     MOV [W4+2], W4
00454C  780004     MOV W4, W0
00454E  024716     CALL LCD_WriteStringNullTerm
004550  000000     NOP
56:                                    break;
004552  370025     BRA 0x459E
57:                                 case COMMAND_WRITE_AT:
58:                                     //the first two bytes are the location of the write
59:                                     LCD_SetPosition(Message->Data[0],Message->Data[1]);
004554  90021E     MOV [W14+2], W4
004556  900214     MOV [W4+2], W4
004558  E80204     INC W4, W4
00455A  784294     MOV.B [W4], W5
00455C  90021E     MOV [W14+2], W4
00455E  900214     MOV [W4+2], W4
004560  784214     MOV.B [W4], W4
004562  784085     MOV.B W5, W1
004564  784004     MOV.B W4, W0
004566  0247C2     CALL LCD_SetPosition
004568  000000     NOP
60:                                     //add two because the first two bytes are the location
61:                                     //subtract two from the size because this size includes
62:                                     //the row/column information which we don't want to write
63:                                     LCD_WriteBuffer(Message->Data+2,Message->Size-2);
00456A  90021E     MOV [W14+2], W4
00456C  904214     MOV.B [W4+1], W4
00456E  E9C204     DEC2.B W4, W4
004570  90029E     MOV [W14+2], W5
004572  900295     MOV [W5+2], W5
004574  E88285     INC2 W5, W5
004576  784084     MOV.B W4, W1
004578  780005     MOV W5, W0
00457A  024734     CALL LCD_WriteBuffer
00457C  000000     NOP
64:                                                      
65:                                     //data[0] is line number, data[1] is where the text starts
66:                                    //LCD_write_line(Message->data+1,*Message->data);
67:                                    break;
00457E  37000F     BRA 0x459E
68:                                case COMMAND_SET_POS:
69:                                    LCD_SetPosition(Message->Data[0],Message->Data[1]);
004580  90021E     MOV [W14+2], W4
004582  900214     MOV [W4+2], W4
004584  E80204     INC W4, W4
004586  784294     MOV.B [W4], W5
004588  90021E     MOV [W14+2], W4
00458A  900214     MOV [W4+2], W4
00458C  784214     MOV.B [W4], W4
00458E  784085     MOV.B W5, W1
004590  784004     MOV.B W4, W0
004592  0247C2     CALL LCD_SetPosition
004594  000000     NOP
70:                                    break;
004596  370003     BRA 0x459E
71:                                default:
72:                                    Nop();
004598  000000     NOP
73:                                    break;                    
00459A  370001     BRA 0x459E
74:                            }
75:                            MessageDelete(Message);
00459E  90021E     MOV [W14+2], W4
0045A0  780004     MOV W4, W0
0045A2  024EEE     CALL MessageDelete
0045A4  000000     NOP
76:                        }
77:                        //free up the CPU
78:                        vTaskDelay(50);
0045BC  200320     MOV #0x32, W0
0045BE  021602     CALL vTaskDelay
0045C0  000000     NOP
79:                    }
0045C2  000000     NOP
80:                }
81:                
82:                
83:                
84:                /**
85:                 * Creates a message that can be filled with data to be sent to the LCD task
86:                 * @param command The type of message this will be
87:                 * @param data_size The size of the data block of the message
88:                 * @return The LCDMessag that can be sent to the LCD Task
89:                 */
90:                pMessage CreateGenericLCDMessage(char Command, char Size)
91:                {
0045C6  FA0004     LNK #0x4
0045C8  984720     MOV.B W0, [W14+2]
0045CA  984731     MOV.B W1, [W14+3]
92:                    pMessage Message = MessageCreate(Size);
0045CC  90403E     MOV.B [W14+3], W0
0045CE  024E6C     CALL MessageCreate
0045D0  000000     NOP
0045D2  780200     MOV W0, W4
0045D4  780F04     MOV W4, [W14]
93:                    Message->Command = Command;
0045D6  78021E     MOV [W14], W4
0045D8  9042AE     MOV.B [W14+2], W5
0045DA  784A05     MOV.B W5, [W4]
94:                    return Message;
0045DC  78021E     MOV [W14], W4
95:                }
0045DE  780004     MOV W4, W0
0045E0  FA8000     ULNK
0045E2  060000     RETURN
96:                
97:                /**
98:                 * Creates a Message loaded with the input Text. This message can then be
99:                 * sent to the LCD Task for displaying
100:                * @param Text
101:                * @param TextLength
102:                * @return 
103:                */
104:               pMessage CreateWriteAtLCDMessage(const char * Text, char TextLength, 
105:                       char Row, char Column)
106:               {
0045E4  FA0008     LNK #0x8
0045E6  980710     MOV W0, [W14+2]
0045E8  984741     MOV.B W1, [W14+4]
0045EA  984752     MOV.B W2, [W14+5]
0045EC  984763     MOV.B W3, [W14+6]
107:                   pMessage Message = 
0045F2  784084     MOV.B W4, W1
0045F4  B3C070     MOV.B #0x7, W0
0045F6  07FFE7     RCALL CreateGenericLCDMessage
0045F8  780200     MOV W0, W4
0045FA  780F04     MOV W4, [W14]
108:                           CreateGenericLCDMessage(COMMAND_WRITE_AT,TextLength+2);
0045EE  90424E     MOV.B [W14+4], W4
0045F0  E8C204     INC2.B W4, W4
109:                   memcpy((Message->Data)+2, Text, TextLength);
0045FC  90424E     MOV.B [W14+4], W4
0045FE  FB0284     SE W4, W5
004600  78021E     MOV [W14], W4
004602  900214     MOV [W4+2], W4
004604  E88204     INC2 W4, W4
004606  780105     MOV W5, W2
004608  90009E     MOV [W14+2], W1
00460A  780004     MOV W4, W0
00460C  02082C     CALL _memcpy
00460E  000000     NOP
110:                   Message->Data[0] = Row;
004610  78021E     MOV [W14], W4
004612  900214     MOV [W4+2], W4
004614  9042DE     MOV.B [W14+5], W5
004616  784A05     MOV.B W5, [W4]
111:                   Message->Data[1] = Column;
004618  78021E     MOV [W14], W4
00461A  900214     MOV [W4+2], W4
00461C  E80204     INC W4, W4
00461E  9042EE     MOV.B [W14+6], W5
004620  784A05     MOV.B W5, [W4]
112:                   return Message;
004622  78021E     MOV [W14], W4
113:               }
004624  780004     MOV W4, W0
004626  FA8000     ULNK
004628  060000     RETURN
114:               
115:               
116:               pMessage CreateWriteLineLCDMessage(const char * Text, char TextLength, 
117:                       char Row)
118:               {
00462A  FA0006     LNK #0x6
00462C  980710     MOV W0, [W14+2]
00462E  984741     MOV.B W1, [W14+4]
004630  984752     MOV.B W2, [W14+5]
119:                   pMessage Message = 
004632  B3C121     MOV.B #0x12, W1
004634  B3C070     MOV.B #0x7, W0
004636  07FFC7     RCALL CreateGenericLCDMessage
004638  780200     MOV W0, W4
00463A  780F04     MOV W4, [W14]
120:                           CreateGenericLCDMessage(COMMAND_WRITE_AT,18);
121:                   //fill the text buffer with spaces
122:                   memset(Message->Data,' ',18);    
00463C  78021E     MOV [W14], W4
00463E  900214     MOV [W4+2], W4
004640  200122     MOV #0x12, W2
004642  200201     MOV #0x20, W1
004644  780004     MOV W4, W0
004646  02083E     CALL _memset
004648  000000     NOP
123:                   //write the text into the buffer, unused elements will come out as space
124:                   memcpy((Message->Data)+2, Text, TextLength);
00464A  90424E     MOV.B [W14+4], W4
00464C  FB0284     SE W4, W5
00464E  78021E     MOV [W14], W4
004650  900214     MOV [W4+2], W4
004652  E88204     INC2 W4, W4
004654  780105     MOV W5, W2
004656  90009E     MOV [W14+2], W1
004658  780004     MOV W4, W0
00465A  02082C     CALL _memcpy
00465C  000000     NOP
125:                   Message->Data[0] = Row;
00465E  78021E     MOV [W14], W4
004660  900214     MOV [W4+2], W4
004662  9042DE     MOV.B [W14+5], W5
004664  784A05     MOV.B W5, [W4]
126:                   Message->Data[1] = 0;
004666  78021E     MOV [W14], W4
004668  900214     MOV [W4+2], W4
00466A  E80284     INC W4, W5
00466C  EB4200     CLR.B W4
00466E  784A84     MOV.B W4, [W5]
127:                   return Message;
004670  78021E     MOV [W14], W4
128:               }
004672  780004     MOV W4, W0
004674  FA8000     ULNK
004676  060000     RETURN
129:               
130:               /**
131:                * Creates a message that can be sent to the LCD Task that will clear the LCD
132:                * @return The correctly configured message to clear the LCD
133:                */
134:               pMessage CreateClearLCDMessage(void)
135:               {
004678  FA0002     LNK #0x2
136:                   pMessage Message = CreateGenericLCDMessage(COMMAND_CLEAR,0);
00467A  EB4080     CLR.B W1
00467C  B3C040     MOV.B #0x4, W0
00467E  07FFA3     RCALL CreateGenericLCDMessage
004680  780200     MOV W0, W4
004682  780F04     MOV W4, [W14]
137:                   return Message;
004684  78021E     MOV [W14], W4
138:               }
004686  780004     MOV W4, W0
004688  FA8000     ULNK
00468A  060000     RETURN
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/c/CC2500Task.c  ---
1:                 #include "CC2500Task.h"
2:                 
3:                 
4:                 
5:                 BaseType_t CreateCC2500Task(CC2500TaskData_t ** CC2500TaskData,
6:                         TaskHandle_t * TaskRef, QueueHandle_t LCDQueue, char * SPIConfigured)
7:                 {
003FC4  FA000A     LNK #0xA
003FC6  781F88     MOV W8, [W15++]
003FC8  980710     MOV W0, [W14+2]
003FCA  980721     MOV W1, [W14+4]
003FCC  980732     MOV W2, [W14+6]
003FCE  980743     MOV W3, [W14+8]
8:                     BaseType_t pass = pdFAIL;
003FD0  EB0200     CLR W4
003FD2  780F04     MOV W4, [W14]
9:                     (*CC2500TaskData) = pvPortMalloc(sizeof(CC2500TaskData_t));
003FD4  2000A0     MOV #0xA, W0
003FD6  024240     CALL pvPortMalloc
003FD8  000000     NOP
003FDA  780200     MOV W0, W4
003FDC  780284     MOV W4, W5
003FDE  90021E     MOV [W14+2], W4
003FE0  780A05     MOV W5, [W4]
10:                    (*CC2500TaskData)->LCDQueue = LCDQueue;
003FE2  90021E     MOV [W14+2], W4
003FE4  780214     MOV [W4], W4
003FE6  9002BE     MOV [W14+6], W5
003FE8  980225     MOV W5, [W4+4]
11:                    (*CC2500TaskData)->SPIConfigured = SPIConfigured;
003FEA  90021E     MOV [W14+2], W4
003FEC  780214     MOV [W4], W4
003FEE  9002CE     MOV [W14+8], W5
003FF0  980235     MOV W5, [W4+6]
12:                    (*CC2500TaskData)->RFQueue = xQueueCreate(20,sizeof(RFMessage_t));
003FF2  90021E     MOV [W14+2], W4
003FF4  780414     MOV [W4], W8
003FF6  EB4100     CLR.B W2
003FF8  200041     MOV #0x4, W1
003FFA  200140     MOV #0x14, W0
003FFC  0224A0     CALL xQueueGenericCreate
003FFE  000000     NOP
004000  780200     MOV W0, W4
004002  980414     MOV W4, [W8+2]
13:                    pass = xTaskCreate(CC2500Task,"CC2500",200,
004004  90021E     MOV [W14+2], W4
004006  780014     MOV [W4], W0
004008  EB0380     CLR W7
00400A  EB0300     CLR W6
00400C  9002AE     MOV [W14+4], W5
00400E  200014     MOV #0x1, W4
004010  780180     MOV W0, W3
004012  200C82     MOV #0xC8, W2
004014  293941     MOV #0x9394, W1
004016  2402A0     MOV #0x402A, W0
004018  021422     CALL xTaskGenericCreate
00401A  000000     NOP
00401C  780200     MOV W0, W4
00401E  780F04     MOV W4, [W14]
14:                            (*CC2500TaskData),CC2500_TASK_PRIORITY,TaskRef);
15:                    
16:                    return pass;
004020  78021E     MOV [W14], W4
17:                }
004022  780004     MOV W4, W0
004024  78044F     MOV [--W15], W8
004026  FA8000     ULNK
004028  060000     RETURN
18:                
19:                
20:                void CC2500Task(void * parameters)
21:                {
00402A  FA000A     LNK #0xA
00402C  980740     MOV W0, [W14+8]
22:                    CC2500TaskData_t * Data = (CC2500TaskData_t*) parameters;
00402E  90024E     MOV [W14+8], W4
004030  780F04     MOV W4, [W14]
23:                    
24:                    
25:                    
26:                    pMessage Message;
27:                    __eds__ char temp;
28:                    
29:                    //allocate string space for writing LCD messages
30:                    char * string = pvPortMalloc(sizeof(char)*20);
004032  200140     MOV #0x14, W0
004034  024240     CALL pvPortMalloc
004036  000000     NOP
004038  780200     MOV W0, W4
00403A  980714     MOV W4, [W14+2]
31:                    
32:                    //configure the Chip Select line to be an output
33:                    CC2500_CS_TRIS
00403C  A9EE11     BCLR 0xE11, #7
34:                    
35:                    Data->State = CC2500_IDLE;
00403E  78021E     MOV [W14], W4
004040  EB0280     CLR W5
004042  980245     MOV W5, [W4+8]
36:                    
37:                    //wait for the Temperature task to configure the SPI module
38:                    while(0 == *Data->SPIConfigured)
004044  370003     BRA 0x404C
00404C  78021E     MOV [W14], W4
00404E  900234     MOV [W4+6], W4
004050  784214     MOV.B [W4], W4
004052  524FE0     SUB.B W4, #0x0, [W15]
004054  32FFF8     BRA Z, 0x4046
39:                        vTaskDelay(500);
004046  201F40     MOV #0x1F4, W0
004048  021602     CALL vTaskDelay
00404A  000000     NOP
40:                    
41:                    //open a session to the CC2500 module and configure it for use
42:                    Data->Session = CC2500_Init(ChipSelect,0xFA,0);
004056  EB4100     CLR.B W2
004058  B3CFA1     MOV.B #0xFA, W1
00405A  242260     MOV #0x4226, W0
00405C  022DC0     CALL CC2500_Init
00405E  000000     NOP
004060  780200     MOV W0, W4
004062  78029E     MOV [W14], W5
004064  780A84     MOV W4, [W5]
43:                    
44:                    Message = CreateClearLCDMessage();
004066  024678     CALL CreateClearLCDMessage
004068  000000     NOP
00406A  780200     MOV W0, W4
00406C  980724     MOV W4, [W14+4]
45:                    MessageSend(Data->LCDQueue,&Message,CC2500_Q_TIMEOUT);
00406E  78021E     MOV [W14], W4
004070  900224     MOV [W4+4], W4
004072  4702E4     ADD W14, #0x4, W5
004074  213882     MOV #0x1388, W2
004076  780085     MOV W5, W1
004078  780004     MOV W4, W0
00407A  024EB6     CALL MessageSend
00407C  000000     NOP
46:                    
47:                    CC2500_WriteStrobe(Data->Session,CC2500_SRX);
00407E  78021E     MOV [W14], W4
004080  780214     MOV [W4], W4
004082  B3C341     MOV.B #0x34, W1
004084  780004     MOV W4, W0
004086  022F02     CALL CC2500_WriteStrobe
004088  000000     NOP
48:                    
49:                    while(1)
50:                    {
51:                        CC2500_ReadStatusRegister(Data->Session,&temp,0);
00408A  78021E     MOV [W14], W4
00408C  780314     MOV [W4], W6
00408E  470266     ADD W14, #0x6, W4
004090  DE22CF     LSR W4, #15, W5
004092  780204     MOV W4, W4
004094  A1F004     BCLR W4, #15
004096  EB0080     CLR W1
004098  BE0104     MOV.D W4, W2
00409A  780006     MOV W6, W0
00409C  022FAE     CALL CC2500_ReadStatusRegister
00409E  000000     NOP
52:                        switch(temp)
0040A0  DE72CF     LSR W14, #15, W5
0040A2  78020E     MOV W14, W4
0040A4  A1F004     BCLR W4, #15
0040A6  800196     MOV DSRPAG, W6
0040A8  D00204     SL W4, W4
0040AA  B000C4     ADD #0xC, W4
0040AC  A82042     BSET SR, #1
0040AE  4A82E0     ADDC W5, #0x0, W5
0040B0  AE2042     BTSS SR, #1
0040B2  A80042     BSET SR, #0
0040B4  D38204     RRC W4, W4
0040B6  780385     MOV W5, W7
0040B8  880197     MOV W7, DSRPAG
0040BA  000000     NOP
0040BC  780204     MOV W4, W4
0040BE  784214     MOV.B [W4], W4
0040C0  880196     MOV W6, DSRPAG
0040C2  000000     NOP
0040C4  FB0204     SE W4, W4
0040C6  520FEF     SUB W4, #0xF, [W15]
0040C8  320003     BRA Z, 0x40D0
0040CA  520FFF     SUB W4, #0x1F, [W15]
0040CC  32004A     BRA Z, 0x4162
0040CE  370059     BRA 0x4182
53:                        {
54:                                case 0x0F:
55:                
56:                                    Message = CreateWriteLineLCDMessage(string,
0040DA  EB4100     CLR.B W2
0040DC  B3C0C1     MOV.B #0xC, W1
0040DE  90001E     MOV [W14+2], W0
0040E0  02462A     CALL CreateWriteLineLCDMessage
0040E2  000000     NOP
0040E4  780200     MOV W0, W4
0040E6  980724     MOV W4, [W14+4]
57:                                            sprintf(string,"In IDLE Mode"),0);
0040D0  2000D2     MOV #0xD, W2
0040D2  2939B1     MOV #0x939B, W1
0040D4  90001E     MOV [W14+2], W0
0040D6  02082C     CALL _memcpy
0040D8  000000     NOP
58:                                    MessageSend(Data->LCDQueue,&Message,CC2500_Q_TIMEOUT);
0040E8  78021E     MOV [W14], W4
0040EA  900224     MOV [W4+4], W4
0040EC  4702E4     ADD W14, #0x4, W5
0040EE  213882     MOV #0x1388, W2
0040F0  780085     MOV W5, W1
0040F2  780004     MOV W4, W0
0040F4  024EB6     CALL MessageSend
0040F6  000000     NOP
59:                
60:                                    if(temp & 0x4){
0040F8  DE72CF     LSR W14, #15, W5
0040FA  78020E     MOV W14, W4
0040FC  A1F004     BCLR W4, #15
0040FE  800196     MOV DSRPAG, W6
004100  D00204     SL W4, W4
004102  B000C4     ADD #0xC, W4
004104  A82042     BSET SR, #1
004106  4A82E0     ADDC W5, #0x0, W5
004108  AE2042     BTSS SR, #1
00410A  A80042     BSET SR, #0
00410C  D38204     RRC W4, W4
00410E  780385     MOV W5, W7
004110  880197     MOV W7, DSRPAG
004112  000000     NOP
004114  780204     MOV W4, W4
004116  784214     MOV.B [W4], W4
004118  880196     MOV W6, DSRPAG
00411A  000000     NOP
00411C  FB0204     SE W4, W4
00411E  620264     AND W4, #0x4, W4
004120  520FE0     SUB W4, #0x0, [W15]
004122  32005B     BRA Z, 0x41DA
61:                                        readData(Data->Session);
004124  78021E     MOV [W14], W4
004126  780214     MOV [W4], W4
004128  780004     MOV W4, W0
00412A  07005C     RCALL readData
62:                                        __delay_ms(10);
00412C  227C00     MOV #0x27C0, W0
00412E  200091     MOV #0x9, W1
004130  024F5A     CALL ___delay32
004132  000000     NOP
63:                                        CC2500_WriteStrobe(Data->Session,CC2500_SFRX);
004134  78021E     MOV [W14], W4
004136  780214     MOV [W4], W4
004138  B3C3A1     MOV.B #0x3A, W1
00413A  780004     MOV W4, W0
00413C  022F02     CALL CC2500_WriteStrobe
00413E  000000     NOP
64:                                        __delay_ms(100);
004140  28D800     MOV #0x8D80, W0
004142  2005B1     MOV #0x5B, W1
004144  024F5A     CALL ___delay32
004146  000000     NOP
65:                                        CC2500_ReadRegister(Data->Session,CC2500_RXBYTES,&temp,0);
004148  78021E     MOV [W14], W4
00414A  780294     MOV [W4], W5
00414C  470266     ADD W14, #0x6, W4
00414E  DE23CF     LSR W4, #15, W7
004150  780304     MOV W4, W6
004152  A1F006     BCLR W6, #15
004154  EB0200     CLR W4
004156  BE0106     MOV.D W6, W2
004158  B3C3B1     MOV.B #0x3B, W1
00415A  780005     MOV W5, W0
00415C  022F46     CALL CC2500_ReadRegister
00415E  000000     NOP
66:                                    }
67:                                    break;
004160  37003D     BRA 0x41DC
0041DA  000000     NOP
68:                                case 0x1F:
69:                                    Message = CreateWriteLineLCDMessage("In RX Mode",10,0);
004162  EB4100     CLR.B W2
004164  B3C0A1     MOV.B #0xA, W1
004166  293A80     MOV #0x93A8, W0
004168  02462A     CALL CreateWriteLineLCDMessage
00416A  000000     NOP
00416C  780200     MOV W0, W4
00416E  980724     MOV W4, [W14+4]
70:                                    MessageSend(Data->LCDQueue,&Message,CC2500_Q_TIMEOUT);
004170  78021E     MOV [W14], W4
004172  900224     MOV [W4+4], W4
004174  4702E4     ADD W14, #0x4, W5
004176  213882     MOV #0x1388, W2
004178  780085     MOV W5, W1
00417A  780004     MOV W4, W0
00417C  024EB6     CALL MessageSend
00417E  000000     NOP
71:                                      break;
004180  37002D     BRA 0x41DC
72:                                default:
73:                                    
74:                                    Message = CreateWriteLineLCDMessage(string, 
0041B8  784204     MOV.B W4, W4
0041BA  EB4100     CLR.B W2
0041BC  784084     MOV.B W4, W1
0041BE  90001E     MOV [W14+2], W0
0041C0  02462A     CALL CreateWriteLineLCDMessage
0041C2  000000     NOP
0041C4  780200     MOV W0, W4
0041C6  980724     MOV W4, [W14+4]
75:                                            sprintf(string,"Unknown: 0x%x",temp),0);
004182  DE72CF     LSR W14, #15, W5
004184  78020E     MOV W14, W4
004186  A1F004     BCLR W4, #15
004188  800196     MOV DSRPAG, W6
00418A  D00204     SL W4, W4
00418C  B000C4     ADD #0xC, W4
00418E  A82042     BSET SR, #1
004190  4A82E0     ADDC W5, #0x0, W5
004192  AE2042     BTSS SR, #1
004194  A80042     BSET SR, #0
004196  D38204     RRC W4, W4
004198  780385     MOV W5, W7
00419A  880197     MOV W7, DSRPAG
00419C  000000     NOP
00419E  780204     MOV W4, W4
0041A0  784214     MOV.B [W4], W4
0041A2  880196     MOV W6, DSRPAG
0041A4  000000     NOP
0041A6  FB0204     SE W4, W4
0041A8  781F84     MOV W4, [W15++]
0041AA  293B34     MOV #0x93B3, W4
0041AC  781F84     MOV W4, [W15++]
0041AE  90001E     MOV [W14+2], W0
0041B0  020862     CALL __sprintf_cdnopsuxX
0041B2  000000     NOP
0041B4  5787E4     SUB W15, #0x4, W15
0041B6  780200     MOV W0, W4
76:                                    MessageSend(Data->LCDQueue,&Message,CC2500_Q_TIMEOUT);
0041C8  78021E     MOV [W14], W4
0041CA  900224     MOV [W4+4], W4
0041CC  4702E4     ADD W14, #0x4, W5
0041CE  213882     MOV #0x1388, W2
0041D0  780085     MOV W5, W1
0041D2  780004     MOV W4, W0
0041D4  024EB6     CALL MessageSend
0041D6  000000     NOP
0041D8  370001     BRA 0x41DC
77:                        }                   
78:                        vTaskDelay(500);
0041DC  201F40     MOV #0x1F4, W0
0041DE  021602     CALL vTaskDelay
0041E0  000000     NOP
79:                    }
0041E2  37FF53     BRA 0x408A
80:                        
81:                }
82:                
83:                int readData(CC2500_Session Session)
84:                {
0041E4  FA0006     LNK #0x6
0041E6  980720     MOV W0, [W14+4]
85:                     __eds__ char temp;
86:                    CC2500_ReadRegister(Session,CC2500_RXBYTES,&temp,0);
0041E8  E8820E     INC2 W14, W4
0041EA  DE23CF     LSR W4, #15, W7
0041EC  780304     MOV W4, W6
0041EE  A1F006     BCLR W6, #15
0041F0  EB0200     CLR W4
0041F2  BE0106     MOV.D W6, W2
0041F4  B3C3B1     MOV.B #0x3B, W1
0041F6  90002E     MOV [W14+4], W0
0041F8  022F46     CALL CC2500_ReadRegister
0041FA  000000     NOP
87:                    
88:                    char * data = pvPortMalloc(sizeof(char)*20);
0041FC  200140     MOV #0x14, W0
0041FE  024240     CALL pvPortMalloc
004200  000000     NOP
004202  780200     MOV W0, W4
004204  780F04     MOV W4, [W14]
89:                    unsigned char count;
90:                    CC2500_ReadPacket(Session,data,&count);
004206  78021E     MOV [W14], W4
004208  B92261     MUL.SU W4, #1, W4
00420A  470363     ADD W14, #0x3, W6
00420C  780086     MOV W6, W1
00420E  BE0104     MOV.D W4, W2
004210  90002E     MOV [W14+4], W0
004212  023040     CALL CC2500_ReadPacket
004214  000000     NOP
91:                
92:                    Nop();
004216  000000     NOP
93:                    vPortFree(data);
004218  78001E     MOV [W14], W0
00421A  024330     CALL vPortFree
00421C  000000     NOP
94:                    //0D BD
95:                    return 0;
00421E  EB0200     CLR W4
96:                }
004220  780004     MOV W4, W0
004222  FA8000     ULNK
004224  060000     RETURN
97:                
98:                
99:                //active low
100:               void ChipSelect(char state)
101:               {
004226  FA0002     LNK #0x2
004228  784F00     MOV.B W0, [W14]
102:                   CC2500_CS = state;    
00422A  78421E     MOV.B [W14], W4
00422C  624261     AND.B W4, #0x1, W4
00422E  FB8204     ZE W4, W4
004230  DD224F     SL W4, #15, W4
004232  8070A6     MOV LATB, W6
004234  27FFF5     MOV #0x7FFF, W5
004236  630285     AND W6, W5, W5
004238  720205     IOR W4, W5, W4
00423A  8870A4     MOV W4, LATB
103:               }
00423C  FA8000     ULNK
00423E  060000     RETURN
104:               
105:               
106:               
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/FreeRTOS/timers.c  
1:                 /*
2:                     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     ***************************************************************************
8:                      *                                                                       *
9:                      *    FreeRTOS provides completely free yet professionally developed,    *
10:                     *    robust, strictly quality controlled, supported, and cross          *
11:                     *    platform software that has become a de facto standard.             *
12:                     *                                                                       *
13:                     *    Help yourself get started quickly and support the FreeRTOS         *
14:                     *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                     *                                                                       *
17:                     *    Thank you!                                                         *
18:                     *                                                                       *
19:                    ***************************************************************************
20:                
21:                    This file is part of the FreeRTOS distribution.
22:                
23:                    FreeRTOS is free software; you can redistribute it and/or modify it under
24:                    the terms of the GNU General Public License (version 2) as published by the
25:                    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                
27:                    >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                    >>! a combined work that includes FreeRTOS without being obliged to provide
29:                    >>! the source code for proprietary components outside of the FreeRTOS
30:                    >>! kernel.
31:                
32:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                    link: http://www.freertos.org/a00114.html
36:                
37:                    1 tab == 4 spaces!
38:                
39:                    ***************************************************************************
40:                     *                                                                       *
41:                     *    Having a problem?  Start by reading the FAQ "My application does   *
42:                     *    not run, what could be wrong?"                                     *
43:                     *                                                                       *
44:                     *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                     *                                                                       *
46:                    ***************************************************************************
47:                
48:                    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                    license and Real Time Engineers Ltd. contact details.
50:                
51:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                
55:                    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                    licenses offer ticketed support, indemnification and middleware.
58:                
59:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                    engineered and independently SIL3 certified version for use in safety and
61:                    mission critical applications that require provable dependability.
62:                
63:                    1 tab == 4 spaces!
64:                */
65:                
66:                /* Standard includes. */
67:                #include <stdlib.h>
68:                
69:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
70:                all the API functions to use the MPU wrappers.  That should only be done when
71:                task.h is included from an application file. */
72:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
73:                
74:                #include "FreeRTOS.h"
75:                #include "task.h"
76:                #include "queue.h"
77:                #include "timers.h"
78:                
79:                #if ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 0 )
80:                	#error configUSE_TIMERS must be set to 1 to make the xTimerPendFunctionCall() function available.
81:                #endif
82:                
83:                /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
84:                MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
85:                header files above, but not in this file, in order to generate the correct
86:                privileged Vs unprivileged linkage and placement. */
87:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
88:                
89:                
90:                /* This entire source file will be skipped if the application is not configured
91:                to include software timer functionality.  This #if is closed at the very bottom
92:                of this file.  If you want to include software timer functionality then ensure
93:                configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
94:                #if ( configUSE_TIMERS == 1 )
95:                
96:                /* Misc definitions. */
97:                #define tmrNO_DELAY		( TickType_t ) 0U
98:                
99:                /* The definition of the timers themselves. */
100:               typedef struct tmrTimerControl
101:               {
102:               	const char				*pcTimerName;		/*<< Text name.  This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
103:               	ListItem_t				xTimerListItem;		/*<< Standard linked list item as used by all kernel features for event management. */
104:               	TickType_t				xTimerPeriodInTicks;/*<< How quickly and often the timer expires. */
105:               	UBaseType_t				uxAutoReload;		/*<< Set to pdTRUE if the timer should be automatically restarted once expired.  Set to pdFALSE if the timer is, in effect, a one-shot timer. */
106:               	void 					*pvTimerID;			/*<< An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */
107:               	TimerCallbackFunction_t	pxCallbackFunction;	/*<< The function that will be called when the timer expires. */
108:               	#if( configUSE_TRACE_FACILITY == 1 )
109:               		UBaseType_t			uxTimerNumber;		/*<< An ID assigned by trace tools such as FreeRTOS+Trace */
110:               	#endif
111:               } xTIMER;
112:               
113:               /* The old xTIMER name is maintained above then typedefed to the new Timer_t
114:               name below to enable the use of older kernel aware debuggers. */
115:               typedef xTIMER Timer_t;
116:               
117:               /* The definition of messages that can be sent and received on the timer queue.
118:               Two types of message can be queued - messages that manipulate a software timer,
119:               and messages that request the execution of a non-timer related callback.  The
120:               two message types are defined in two separate structures, xTimerParametersType
121:               and xCallbackParametersType respectively. */
122:               typedef struct tmrTimerParameters
123:               {
124:               	TickType_t			xMessageValue;		/*<< An optional value used by a subset of commands, for example, when changing the period of a timer. */
125:               	Timer_t *			pxTimer;			/*<< The timer to which the command will be applied. */
126:               } TimerParameter_t;
127:               
128:               
129:               typedef struct tmrCallbackParameters
130:               {
131:               	PendedFunction_t	pxCallbackFunction;	/* << The callback function to execute. */
132:               	void *pvParameter1;						/* << The value that will be used as the callback functions first parameter. */
133:               	uint32_t ulParameter2;					/* << The value that will be used as the callback functions second parameter. */
134:               } CallbackParameters_t;
135:               
136:               /* The structure that contains the two message types, along with an identifier
137:               that is used to determine which message type is valid. */
138:               typedef struct tmrTimerQueueMessage
139:               {
140:               	BaseType_t			xMessageID;			/*<< The command being sent to the timer service task. */
141:               	union
142:               	{
143:               		TimerParameter_t xTimerParameters;
144:               
145:               		/* Don't include xCallbackParameters if it is not going to be used as
146:               		it makes the structure (and therefore the timer queue) larger. */
147:               		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
148:               			CallbackParameters_t xCallbackParameters;
149:               		#endif /* INCLUDE_xTimerPendFunctionCall */
150:               	} u;
151:               } DaemonTaskMessage_t;
152:               
153:               /*lint -e956 A manual analysis and inspection has been used to determine which
154:               static variables must be declared volatile. */
155:               
156:               /* The list in which active timers are stored.  Timers are referenced in expire
157:               time order, with the nearest expiry time at the front of the list.  Only the
158:               timer service task is allowed to access these lists. */
159:               PRIVILEGED_DATA static List_t xActiveTimerList1;
160:               PRIVILEGED_DATA static List_t xActiveTimerList2;
161:               PRIVILEGED_DATA static List_t *pxCurrentTimerList;
162:               PRIVILEGED_DATA static List_t *pxOverflowTimerList;
163:               
164:               /* A queue that is used to send commands to the timer service task. */
165:               PRIVILEGED_DATA static QueueHandle_t xTimerQueue = NULL;
166:               
167:               #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
168:               
169:               	PRIVILEGED_DATA static TaskHandle_t xTimerTaskHandle = NULL;
170:               
171:               #endif
172:               
173:               /*lint +e956 */
174:               
175:               /*-----------------------------------------------------------*/
176:               
177:               /*
178:                * Initialise the infrastructure used by the timer service task if it has not
179:                * been initialised already.
180:                */
181:               static void prvCheckForValidListAndQueue( void ) PRIVILEGED_FUNCTION;
182:               
183:               /*
184:                * The timer service task (daemon).  Timer functionality is controlled by this
185:                * task.  Other tasks communicate with the timer service task using the
186:                * xTimerQueue queue.
187:                */
188:               static void prvTimerTask( void *pvParameters ) PRIVILEGED_FUNCTION;
189:               
190:               /*
191:                * Called by the timer service task to interpret and process a command it
192:                * received on the timer queue.
193:                */
194:               static void	prvProcessReceivedCommands( void ) PRIVILEGED_FUNCTION;
195:               
196:               /*
197:                * Insert the timer into either xActiveTimerList1, or xActiveTimerList2,
198:                * depending on if the expire time causes a timer counter overflow.
199:                */
200:               static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime ) PRIVILEGED_FUNCTION;
201:               
202:               /*
203:                * An active timer has reached its expire time.  Reload the timer if it is an
204:                * auto reload timer, then call its callback.
205:                */
206:               static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) PRIVILEGED_FUNCTION;
207:               
208:               /*
209:                * The tick count has overflowed.  Switch the timer lists after ensuring the
210:                * current timer list does not still reference some timers.
211:                */
212:               static void prvSwitchTimerLists( void ) PRIVILEGED_FUNCTION;
213:               
214:               /*
215:                * Obtain the current tick count, setting *pxTimerListsWereSwitched to pdTRUE
216:                * if a tick count overflow occurred since prvSampleTimeNow() was last called.
217:                */
218:               static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched ) PRIVILEGED_FUNCTION;
219:               
220:               /*
221:                * If the timer list contains any active timers then return the expire time of
222:                * the timer that will expire first and set *pxListWasEmpty to false.  If the
223:                * timer list does not contain any timers then return 0 and set *pxListWasEmpty
224:                * to pdTRUE.
225:                */
226:               static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) PRIVILEGED_FUNCTION;
227:               
228:               /*
229:                * If a timer has expired, process it.  Otherwise, block the timer service task
230:                * until either a timer does expire or a command is received.
231:                */
232:               static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;
233:               
234:               /*-----------------------------------------------------------*/
235:               
236:               BaseType_t xTimerCreateTimerTask( void )
237:               {
0031D2  FA0002     LNK #0x2
238:               BaseType_t xReturn = pdFAIL;
0031D4  EB0200     CLR W4
0031D6  780F04     MOV W4, [W14]
239:               
240:               	/* This function is called when the scheduler is started if
241:               	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
242:               	timer service task has been created/initialised.  If timers have already
243:               	been created then the initialisation will already have been performed. */
244:               	prvCheckForValidListAndQueue();
0031D8  0701F6     RCALL _prvCheckForValidListAndQueue
245:               
246:               	if( xTimerQueue != NULL )
0031DA  8301F4     MOV xTimerQueue, W4
0031DC  520FE0     SUB W4, #0x0, [W15]
0031DE  32000C     BRA Z, 0x31F8
247:               	{
248:               		#if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
249:               		{
250:               			/* Create the timer task, storing its handle in xTimerTaskHandle so
251:               			it can be returned by the xTimerGetTimerDaemonTaskHandle() function. */
252:               			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
253:               		}
254:               		#else
255:               		{
256:               			/* Create the timer task without storing its handle. */
257:               			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
0031E0  EB0380     CLR W7
0031E2  EB0300     CLR W6
0031E4  EB0280     CLR W5
0031E6  200044     MOV #0x4, W4
0031E8  EB0180     CLR W3
0031EA  200642     MOV #0x64, W2
0031EC  294081     MOV #0x9408, W1
0031EE  233240     MOV #0x3324, W0
0031F0  021422     CALL xTaskGenericCreate
0031F2  000000     NOP
0031F4  780200     MOV W0, W4
0031F6  780F04     MOV W4, [W14]
258:               		}
259:               		#endif
260:               	}
261:               	else
262:               	{
263:               		mtCOVERAGE_TEST_MARKER();
264:               	}
265:               
266:               	configASSERT( xReturn );
267:               	return xReturn;
0031F8  78021E     MOV [W14], W4
268:               }
0031FA  780004     MOV W4, W0
0031FC  FA8000     ULNK
0031FE  060000     RETURN
269:               /*-----------------------------------------------------------*/
270:               
271:               TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
272:               {
003200  FA000C     LNK #0xC
003202  980710     MOV W0, [W14+2]
003204  980721     MOV W1, [W14+4]
003206  980732     MOV W2, [W14+6]
003208  980743     MOV W3, [W14+8]
00320A  980754     MOV W4, [W14+10]
273:               Timer_t *pxNewTimer;
274:               
275:               	/* Allocate the timer structure. */
276:               	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
00320C  90022E     MOV [W14+4], W4
00320E  520FE0     SUB W4, #0x0, [W15]
003210  3A0003     BRA NZ, 0x3218
277:               	{
278:               		pxNewTimer = NULL;
003212  EB0200     CLR W4
003214  780F04     MOV W4, [W14]
003216  37001C     BRA 0x3250
279:               	}
280:               	else
281:               	{
282:               		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
003218  200160     MOV #0x16, W0
00321A  024240     CALL pvPortMalloc
00321C  000000     NOP
00321E  780200     MOV W0, W4
003220  780F04     MOV W4, [W14]
283:               		if( pxNewTimer != NULL )
003222  78021E     MOV [W14], W4
003224  520FE0     SUB W4, #0x0, [W15]
003226  320014     BRA Z, 0x3250
284:               		{
285:               			/* Ensure the infrastructure used by the timer service task has been
286:               			created/initialised. */
287:               			prvCheckForValidListAndQueue();
003228  0701CE     RCALL _prvCheckForValidListAndQueue
288:               
289:               			/* Initialise the timer structure members using the function parameters. */
290:               			pxNewTimer->pcTimerName = pcTimerName;
00322A  78021E     MOV [W14], W4
00322C  90029E     MOV [W14+2], W5
00322E  780A05     MOV W5, [W4]
291:               			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
003230  78021E     MOV [W14], W4
003232  9002AE     MOV [W14+4], W5
003234  980265     MOV W5, [W4+12]
292:               			pxNewTimer->uxAutoReload = uxAutoReload;
003236  78021E     MOV [W14], W4
003238  9002BE     MOV [W14+6], W5
00323A  980275     MOV W5, [W4+14]
293:               			pxNewTimer->pvTimerID = pvTimerID;
00323C  78021E     MOV [W14], W4
00323E  9002CE     MOV [W14+8], W5
003240  980A05     MOV W5, [W4+16]
294:               			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
003242  78021E     MOV [W14], W4
003244  9002DE     MOV [W14+10], W5
003246  980A15     MOV W5, [W4+18]
295:               			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
003248  E8821E     INC2 [W14], W4
00324A  780004     MOV W4, W0
00324C  024B60     CALL vListInitialiseItem
00324E  000000     NOP
296:               
297:               			traceTIMER_CREATE( pxNewTimer );
298:               		}
299:               		else
300:               		{
301:               			traceTIMER_CREATE_FAILED();
302:               		}
303:               	}
304:               
305:               	/* 0 is not a valid value for xTimerPeriodInTicks. */
306:               	configASSERT( ( xTimerPeriodInTicks > 0 ) );
307:               
308:               	return ( TimerHandle_t ) pxNewTimer;
003250  78021E     MOV [W14], W4
309:               }
003252  780004     MOV W4, W0
003254  FA8000     ULNK
003256  060000     RETURN
310:               /*-----------------------------------------------------------*/
311:               
312:               BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
313:               {
003258  FA0012     LNK #0x12
00325A  980740     MOV W0, [W14+8]
00325C  980751     MOV W1, [W14+10]
00325E  980762     MOV W2, [W14+12]
003260  980773     MOV W3, [W14+14]
003262  980F04     MOV W4, [W14+16]
314:               BaseType_t xReturn = pdFAIL;
003264  EB0200     CLR W4
003266  780F04     MOV W4, [W14]
315:               DaemonTaskMessage_t xMessage;
316:               
317:               	/* Send a message to the timer service task to perform a particular action
318:               	on a particular timer definition. */
319:               	if( xTimerQueue != NULL )
003268  8301F4     MOV xTimerQueue, W4
00326A  520FE0     SUB W4, #0x0, [W15]
00326C  32002E     BRA Z, 0x32CA
320:               	{
321:               		/* Send a command to the timer service task to start the xTimer timer. */
322:               		xMessage.xMessageID = xCommandID;
00326E  90025E     MOV [W14+10], W4
003270  980714     MOV W4, [W14+2]
323:               		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
003272  90026E     MOV [W14+12], W4
003274  980724     MOV W4, [W14+4]
324:               		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
003276  90024E     MOV [W14+8], W4
003278  980734     MOV W4, [W14+6]
325:               
326:               		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
00327A  90025E     MOV [W14+10], W4
00327C  520FE5     SUB W4, #0x5, [W15]
00327E  3C001B     BRA GT, 0x32B6
327:               		{
328:               			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
003280  022202     CALL xTaskGetSchedulerState
003282  000000     NOP
003284  780200     MOV W0, W4
003286  520FE2     SUB W4, #0x2, [W15]
003288  3A000B     BRA NZ, 0x32A0
329:               			{
330:               				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
00328A  8301F4     MOV xTimerQueue, W4
00328C  E8828E     INC2 W14, W5
00328E  EB0180     CLR W3
003290  90090E     MOV [W14+16], W2
003292  780085     MOV W5, W1
003294  780004     MOV W4, W0
003296  022584     CALL xQueueGenericSend
003298  000000     NOP
00329A  780200     MOV W0, W4
00329C  780F04     MOV W4, [W14]
00329E  370015     BRA 0x32CA
331:               			}
332:               			else
333:               			{
334:               				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
0032A0  8301F4     MOV xTimerQueue, W4
0032A2  E8828E     INC2 W14, W5
0032A4  EB0180     CLR W3
0032A6  EB0100     CLR W2
0032A8  780085     MOV W5, W1
0032AA  780004     MOV W4, W0
0032AC  022584     CALL xQueueGenericSend
0032AE  000000     NOP
0032B0  780200     MOV W0, W4
0032B2  780F04     MOV W4, [W14]
0032B4  37000A     BRA 0x32CA
335:               			}
336:               		}
337:               		else
338:               		{
339:               			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
0032B6  8301F4     MOV xTimerQueue, W4
0032B8  E8828E     INC2 W14, W5
0032BA  EB0180     CLR W3
0032BC  90017E     MOV [W14+14], W2
0032BE  780085     MOV W5, W1
0032C0  780004     MOV W4, W0
0032C2  022684     CALL xQueueGenericSendFromISR
0032C4  000000     NOP
0032C6  780200     MOV W0, W4
0032C8  780F04     MOV W4, [W14]
340:               		}
341:               
342:               		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
343:               	}
344:               	else
345:               	{
346:               		mtCOVERAGE_TEST_MARKER();
347:               	}
348:               
349:               	return xReturn;
0032CA  78021E     MOV [W14], W4
350:               }
0032CC  780004     MOV W4, W0
0032CE  FA8000     ULNK
0032D0  060000     RETURN
351:               /*-----------------------------------------------------------*/
352:               
353:               #if ( INCLUDE_xTimerGetTimerDaemonTaskHandle == 1 )
354:               
355:               	TaskHandle_t xTimerGetTimerDaemonTaskHandle( void )
356:               	{
357:               		/* If xTimerGetTimerDaemonTaskHandle() is called before the scheduler has been
358:               		started, then xTimerTaskHandle will be NULL. */
359:               		configASSERT( ( xTimerTaskHandle != NULL ) );
360:               		return xTimerTaskHandle;
361:               	}
362:               
363:               #endif
364:               /*-----------------------------------------------------------*/
365:               
366:               static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
367:               {
0032D2  FA0008     LNK #0x8
0032D4  980720     MOV W0, [W14+4]
0032D6  980731     MOV W1, [W14+6]
368:               BaseType_t xResult;
369:               Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
0032D8  8301D4     MOV pxCurrentTimerList, W4
0032DA  900234     MOV [W4+6], W4
0032DC  900234     MOV [W4+6], W4
0032DE  780F04     MOV W4, [W14]
370:               
371:               	/* Remove the timer from the list of active timers.  A check has already
372:               	been performed to ensure the list is not empty. */
373:               	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
0032E0  E8821E     INC2 [W14], W4
0032E2  780004     MOV W4, W0
0032E4  024C0E     CALL uxListRemove
0032E6  000000     NOP
374:               	traceTIMER_EXPIRED( pxTimer );
375:               
376:               	/* If the timer is an auto reload timer then calculate the next
377:               	expiry time and re-insert the timer in the list of active timers. */
378:               	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
0032E8  78021E     MOV [W14], W4
0032EA  900274     MOV [W4+14], W4
0032EC  520FE1     SUB W4, #0x1, [W15]
0032EE  3A0014     BRA NZ, 0x3318
379:               	{
380:               		/* The timer is inserted into a list using a time relative to anything
381:               		other than the current time.  It will therefore be inserted into the
382:               		correct list relative to the time this task thinks it is now. */
383:               		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
0032F0  78021E     MOV [W14], W4
0032F2  9002E4     MOV [W4+12], W5
0032F4  90022E     MOV [W14+4], W4
0032F6  428204     ADD W5, W4, W4
0032F8  9001AE     MOV [W14+4], W3
0032FA  90013E     MOV [W14+6], W2
0032FC  780084     MOV W4, W1
0032FE  78001E     MOV [W14], W0
003300  07007D     RCALL _prvInsertTimerInActiveList
003302  780200     MOV W0, W4
003304  520FE1     SUB W4, #0x1, [W15]
003306  3A0008     BRA NZ, 0x3318
384:               		{
385:               			/* The timer expired before it was added to the active timer
386:               			list.  Reload it now.  */
387:               			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
003308  EB0200     CLR W4
00330A  EB0180     CLR W3
00330C  90012E     MOV [W14+4], W2
00330E  EB0080     CLR W1
003310  78001E     MOV [W14], W0
003312  07FFA2     RCALL xTimerGenericCommand
003314  780200     MOV W0, W4
003316  980714     MOV W4, [W14+2]
388:               			configASSERT( xResult );
389:               			( void ) xResult;
390:               		}
391:               		else
392:               		{
393:               			mtCOVERAGE_TEST_MARKER();
394:               		}
395:               	}
396:               	else
397:               	{
398:               		mtCOVERAGE_TEST_MARKER();
399:               	}
400:               
401:               	/* Call the timer callback. */
402:               	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
003318  78021E     MOV [W14], W4
00331A  900A14     MOV [W4+18], W4
00331C  78001E     MOV [W14], W0
00331E  010004     CALL W4
403:               }
003320  FA8000     ULNK
003322  060000     RETURN
404:               /*-----------------------------------------------------------*/
405:               
406:               static void prvTimerTask( void *pvParameters )
407:               {
003324  FA0006     LNK #0x6
003326  980720     MOV W0, [W14+4]
408:               TickType_t xNextExpireTime;
409:               BaseType_t xListWasEmpty;
410:               
411:               	/* Just to avoid compiler warnings. */
412:               	( void ) pvParameters;
413:               
414:               	for( ;; )
415:               	{
416:               		/* Query the timers list to see if it contains any timers, and if so,
417:               		obtain the time at which the next timer will expire. */
418:               		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
003328  E8820E     INC2 W14, W4
00332A  780004     MOV W4, W0
00332C  070037     RCALL _prvGetNextExpireTime
00332E  780200     MOV W0, W4
003330  780F04     MOV W4, [W14]
419:               
420:               		/* If a timer has expired, process it.  Otherwise, block this task
421:               		until either a timer does expire, or a command is received. */
422:               		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
003332  90021E     MOV [W14+2], W4
003334  780084     MOV W4, W1
003336  78001E     MOV [W14], W0
003338  070002     RCALL _prvProcessTimerOrBlockTask
423:               
424:               		/* Empty the command queue. */
425:               		prvProcessReceivedCommands();
00333A  070099     RCALL _prvProcessReceivedCommands
426:               	}
00333C  37FFF5     BRA 0x3328
427:               }
428:               /*-----------------------------------------------------------*/
429:               
430:               static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
431:               {
00333E  FA0008     LNK #0x8
003340  980720     MOV W0, [W14+4]
003342  980731     MOV W1, [W14+6]
432:               TickType_t xTimeNow;
433:               BaseType_t xTimerListsWereSwitched;
434:               
435:               	vTaskSuspendAll();
003344  021928     CALL vTaskSuspendAll
003346  000000     NOP
436:               	{
437:               		/* Obtain the time now to make an assessment as to whether the timer
438:               		has expired or not.  If obtaining the time causes the lists to switch
439:               		then don't process this timer as any timers that remained in the list
440:               		when the lists were switched will have been processed within the
441:               		prvSampleTimeNow() function. */
442:               		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
003348  E8820E     INC2 W14, W4
00334A  780004     MOV W4, W0
00334C  07003F     RCALL _prvSampleTimeNow
00334E  780200     MOV W0, W4
003350  780F04     MOV W4, [W14]
443:               		if( xTimerListsWereSwitched == pdFALSE )
003352  90021E     MOV [W14+2], W4
003354  520FE0     SUB W4, #0x0, [W15]
003356  3A001C     BRA NZ, 0x3390
444:               		{
445:               			/* The tick count has not overflowed, has the timer expired? */
446:               			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
003358  90023E     MOV [W14+6], W4
00335A  520FE0     SUB W4, #0x0, [W15]
00335C  3A0009     BRA NZ, 0x3370
00335E  90022E     MOV [W14+4], W4
003360  520F9E     SUB W4, [W14], [W15]
003362  3E0006     BRA GTU, 0x3370
447:               			{
448:               				( void ) xTaskResumeAll();
003364  021934     CALL xTaskResumeAll
003366  000000     NOP
449:               				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
003368  78009E     MOV [W14], W1
00336A  90002E     MOV [W14+4], W0
00336C  07FFB2     RCALL _prvProcessExpiredTimer
00336E  370014     BRA 0x3398
450:               			}
451:               			else
452:               			{
453:               				/* The tick count has not overflowed, and the next expire
454:               				time has not been reached yet.  This task should therefore
455:               				block to wait for the next expire time or a command to be
456:               				received - whichever comes first.  The following line cannot
457:               				be reached unless xNextExpireTime > xTimeNow, except in the
458:               				case when the current timer list is empty. */
459:               				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
003370  90022E     MOV [W14+4], W4
003372  52029E     SUB W4, [W14], W5
003374  8301F4     MOV xTimerQueue, W4
003376  780085     MOV W5, W1
003378  780004     MOV W4, W0
00337A  022BD0     CALL vQueueWaitForMessageRestricted
00337C  000000     NOP
460:               
461:               				if( xTaskResumeAll() == pdFALSE )
00337E  021934     CALL xTaskResumeAll
003380  000000     NOP
003382  780200     MOV W0, W4
003384  520FE0     SUB W4, #0x0, [W15]
003386  3A0007     BRA NZ, 0x3396
462:               				{
463:               					/* Yield to wait for either a command to arrive, or the block time
464:               					to expire.  If a command arrived between the critical section being
465:               					exited and this yield then the yield will not cause the task
466:               					to block. */
467:               					portYIELD_WITHIN_API();
003388  024F06     CALL _vPortYield
00338A  000000     NOP
00338C  000000     NOP
00338E  370004     BRA 0x3398
003396  000000     NOP
468:               				}
469:               				else
470:               				{
471:               					mtCOVERAGE_TEST_MARKER();
472:               				}
473:               			}
474:               		}
475:               		else
476:               		{
477:               			( void ) xTaskResumeAll();
003390  021934     CALL xTaskResumeAll
003392  000000     NOP
003394  370001     BRA 0x3398
478:               		}
479:               	}
480:               }
003398  FA8000     ULNK
00339A  060000     RETURN
481:               /*-----------------------------------------------------------*/
482:               
483:               static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
484:               {
00339C  FA0004     LNK #0x4
00339E  980710     MOV W0, [W14+2]
485:               TickType_t xNextExpireTime;
486:               
487:               	/* Timers are listed in expiry time order, with the head of the list
488:               	referencing the task that will expire first.  Obtain the time at which
489:               	the timer with the nearest expiry time will expire.  If there are no
490:               	active timers then just set the next expire time to 0.  That will cause
491:               	this task to unblock when the tick count overflows, at which point the
492:               	timer lists will be switched and the next expiry time can be
493:               	re-assessed.  */
494:               	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
0033A0  8301D4     MOV pxCurrentTimerList, W4
0033A2  780214     MOV [W4], W4
0033A4  A7F004     BTSC W4, #15
0033A6  EA0204     NEG W4, W4
0033A8  E90204     DEC W4, W4
0033AA  DE224F     LSR W4, #15, W4
0033AC  90029E     MOV [W14+2], W5
0033AE  780A84     MOV W4, [W5]
495:               	if( *pxListWasEmpty == pdFALSE )
0033B0  90021E     MOV [W14+2], W4
0033B2  780214     MOV [W4], W4
0033B4  520FE0     SUB W4, #0x0, [W15]
0033B6  3A0004     BRA NZ, 0x33C0
496:               	{
497:               		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
0033B8  8301D4     MOV pxCurrentTimerList, W4
0033BA  900234     MOV [W4+6], W4
0033BC  780F14     MOV [W4], [W14]
0033BE  370002     BRA 0x33C4
498:               	}
499:               	else
500:               	{
501:               		/* Ensure the task unblocks when the tick count rolls over. */
502:               		xNextExpireTime = ( TickType_t ) 0U;
0033C0  EB0200     CLR W4
0033C2  780F04     MOV W4, [W14]
503:               	}
504:               
505:               	return xNextExpireTime;
0033C4  78021E     MOV [W14], W4
506:               }
0033C6  780004     MOV W4, W0
0033C8  FA8000     ULNK
0033CA  060000     RETURN
507:               /*-----------------------------------------------------------*/
508:               
509:               static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
510:               {
0033CC  FA0004     LNK #0x4
0033CE  980710     MOV W0, [W14+2]
511:               TickType_t xTimeNow;
512:               PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */
513:               
514:               	xTimeNow = xTaskGetTickCount();
0033D0  0219E4     CALL xTaskGetTickCount
0033D2  000000     NOP
0033D4  780200     MOV W0, W4
0033D6  780F04     MOV W4, [W14]
515:               
516:               	if( xTimeNow < xLastTime )
0033D8  830204     MOV xLastTime, W4
0033DA  78029E     MOV [W14], W5
0033DC  528F84     SUB W5, W4, [W15]
0033DE  310005     BRA C, 0x33EA
517:               	{
518:               		prvSwitchTimerLists();
0033E0  0700B3     RCALL _prvSwitchTimerLists
519:               		*pxTimerListsWereSwitched = pdTRUE;
0033E2  90021E     MOV [W14+2], W4
0033E4  200015     MOV #0x1, W5
0033E6  780A05     MOV W5, [W4]
0033E8  370003     BRA 0x33F0
520:               	}
521:               	else
522:               	{
523:               		*pxTimerListsWereSwitched = pdFALSE;
0033EA  90021E     MOV [W14+2], W4
0033EC  EB0280     CLR W5
0033EE  780A05     MOV W5, [W4]
524:               	}
525:               
526:               	xLastTime = xTimeNow;
0033F0  78021E     MOV [W14], W4
0033F2  8B0204     MOV W4, xLastTime
527:               
528:               	return xTimeNow;
0033F4  78021E     MOV [W14], W4
529:               }
0033F6  780004     MOV W4, W0
0033F8  FA8000     ULNK
0033FA  060000     RETURN
530:               /*-----------------------------------------------------------*/
531:               
532:               static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
533:               {
0033FC  FA000A     LNK #0xA
0033FE  980710     MOV W0, [W14+2]
003400  980721     MOV W1, [W14+4]
003402  980732     MOV W2, [W14+6]
003404  980743     MOV W3, [W14+8]
534:               BaseType_t xProcessTimerNow = pdFALSE;
003406  EB0200     CLR W4
003408  780F04     MOV W4, [W14]
535:               
536:               	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
00340A  90021E     MOV [W14+2], W4
00340C  9002AE     MOV [W14+4], W5
00340E  980215     MOV W5, [W4+2]
537:               	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
003410  90021E     MOV [W14+2], W4
003412  90029E     MOV [W14+2], W5
003414  980245     MOV W5, [W4+8]
538:               
539:               	if( xNextExpiryTime <= xTimeNow )
003416  9002AE     MOV [W14+4], W5
003418  90023E     MOV [W14+6], W4
00341A  528F84     SUB W5, W4, [W15]
00341C  3E0012     BRA GTU, 0x3442
540:               	{
541:               		/* Has the expiry time elapsed between the command to start/reset a
542:               		timer was issued, and the time the command was processed? */
543:               		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
00341E  9002BE     MOV [W14+6], W5
003420  90024E     MOV [W14+8], W4
003422  528284     SUB W5, W4, W5
003424  90021E     MOV [W14+2], W4
003426  900264     MOV [W4+12], W4
003428  528F84     SUB W5, W4, [W15]
00342A  390003     BRA NC, 0x3432
544:               		{
545:               			/* The time between a command being issued and the command being
546:               			processed actually exceeds the timers period.  */
547:               			xProcessTimerNow = pdTRUE;
00342C  200014     MOV #0x1, W4
00342E  780F04     MOV W4, [W14]
003430  37001A     BRA 0x3466
548:               		}
549:               		else
550:               		{
551:               			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
003432  90021E     MOV [W14+2], W4
003434  E88284     INC2 W4, W5
003436  8301E4     MOV pxOverflowTimerList, W4
003438  780085     MOV W5, W1
00343A  780004     MOV W4, W0
00343C  024BAA     CALL vListInsert
00343E  000000     NOP
003440  370012     BRA 0x3466
552:               		}
553:               	}
554:               	else
555:               	{
556:               		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
003442  9002BE     MOV [W14+6], W5
003444  90024E     MOV [W14+8], W4
003446  528F84     SUB W5, W4, [W15]
003448  310007     BRA C, 0x3458
00344A  9002AE     MOV [W14+4], W5
00344C  90024E     MOV [W14+8], W4
00344E  528F84     SUB W5, W4, [W15]
003450  390003     BRA NC, 0x3458
557:               		{
558:               			/* If, since the command was issued, the tick count has overflowed
559:               			but the expiry time has not, then the timer must have already passed
560:               			its expiry time and should be processed immediately. */
561:               			xProcessTimerNow = pdTRUE;
003452  200014     MOV #0x1, W4
003454  780F04     MOV W4, [W14]
003456  370007     BRA 0x3466
562:               		}
563:               		else
564:               		{
565:               			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
003458  90021E     MOV [W14+2], W4
00345A  E88284     INC2 W4, W5
00345C  8301D4     MOV pxCurrentTimerList, W4
00345E  780085     MOV W5, W1
003460  780004     MOV W4, W0
003462  024BAA     CALL vListInsert
003464  000000     NOP
566:               		}
567:               	}
568:               
569:               	return xProcessTimerNow;
003466  78021E     MOV [W14], W4
570:               }
003468  780004     MOV W4, W0
00346A  FA8000     ULNK
00346C  060000     RETURN
571:               /*-----------------------------------------------------------*/
572:               
573:               static void	prvProcessReceivedCommands( void )
574:               {
00346E  FA000E     LNK #0xE
575:               DaemonTaskMessage_t xMessage;
576:               Timer_t *pxTimer;
577:               BaseType_t xTimerListsWereSwitched, xResult;
578:               TickType_t xTimeNow;
579:               
580:               	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
003470  37005E     BRA 0x352E
00352E  8301F4     MOV xTimerQueue, W4
003530  4702E6     ADD W14, #0x6, W5
003532  EB0180     CLR W3
003534  EB0100     CLR W2
003536  780085     MOV W5, W1
003538  780004     MOV W4, W0
00353A  0226FA     CALL xQueueGenericReceive
00353C  000000     NOP
00353E  780200     MOV W0, W4
003540  520FE0     SUB W4, #0x0, [W15]
003542  3AFF97     BRA NZ, 0x3472
581:               	{
582:               		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
583:               		{
584:               			/* Negative commands are pended function calls rather than timer
585:               			commands. */
586:               			if( xMessage.xMessageID < 0 )
587:               			{
588:               				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
589:               
590:               				/* The timer uses the xCallbackParameters member to request a
591:               				callback be executed.  Check the callback is not NULL. */
592:               				configASSERT( pxCallback );
593:               
594:               				/* Call the function. */
595:               				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
596:               			}
597:               			else
598:               			{
599:               				mtCOVERAGE_TEST_MARKER();
600:               			}
601:               		}
602:               		#endif /* INCLUDE_xTimerPendFunctionCall */
603:               
604:               		/* Commands that are positive are timer commands rather than pended
605:               		function calls. */
606:               		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
003472  90023E     MOV [W14+6], W4
003474  520FE0     SUB W4, #0x0, [W15]
003476  35005B     BRA LT, 0x352E
607:               		{
608:               			/* The messages uses the xTimerParameters member to work on a
609:               			software timer. */
610:               			pxTimer = xMessage.u.xTimerParameters.pxTimer;
003478  90025E     MOV [W14+10], W4
00347A  780F04     MOV W4, [W14]
611:               
612:               			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
00347C  78021E     MOV [W14], W4
00347E  900254     MOV [W4+10], W4
003480  520FE0     SUB W4, #0x0, [W15]
003482  320004     BRA Z, 0x348C
613:               			{
614:               				/* The timer is in a list, remove it. */
615:               				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
003484  E8821E     INC2 [W14], W4
003486  780004     MOV W4, W0
003488  024C0E     CALL uxListRemove
00348A  000000     NOP
616:               			}
617:               			else
618:               			{
619:               				mtCOVERAGE_TEST_MARKER();
620:               			}
621:               
622:               			traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.u.xTimerParameters.xMessageValue );
623:               
624:               			/* In this case the xTimerListsWereSwitched parameter is not used, but
625:               			it must be present in the function call.  prvSampleTimeNow() must be
626:               			called after the message is received from xTimerQueue so there is no
627:               			possibility of a higher priority task adding a message to the message
628:               			queue with a time that is ahead of the timer daemon task (because it
629:               			pre-empted the timer daemon task after the xTimeNow value was set). */
630:               			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
00348C  47026C     ADD W14, #0xC, W4
00348E  780004     MOV W4, W0
003490  07FF9D     RCALL _prvSampleTimeNow
003492  780200     MOV W0, W4
003494  980714     MOV W4, [W14+2]
631:               
632:               			switch( xMessage.xMessageID )
003496  90023E     MOV [W14+6], W4
003498  DEA2CF     ASR W4, #15, W5
00349A  200096     MOV #0x9, W6
00349C  200007     MOV #0x0, W7
00349E  520F86     SUB W4, W6, [W15]
0034A0  5A8F87     SUBB W5, W7, [W15]
0034A2  3E003E     BRA GTU, 0x3520
0034A4  010604     BRA W4
0034A6  370009     BRA 0x34BA
0034A8  370008     BRA 0x34BA
0034AA  370007     BRA 0x34BA
0034AC  37003B     BRA 0x3524
0034AE  370027     BRA 0x34FE
0034B0  370033     BRA 0x3518
0034B2  370003     BRA 0x34BA
0034B4  370002     BRA 0x34BA
0034B6  370036     BRA 0x3524
0034B8  370022     BRA 0x34FE
633:               			{
634:               				case tmrCOMMAND_START :
635:               			    case tmrCOMMAND_START_FROM_ISR :
636:               			    case tmrCOMMAND_RESET :
637:               			    case tmrCOMMAND_RESET_FROM_ISR :
638:               				case tmrCOMMAND_START_DONT_TRACE :
639:               					/* Start or restart a timer. */
640:               					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
0034BA  9002CE     MOV [W14+8], W5
0034BC  90034E     MOV [W14+8], W6
0034BE  78021E     MOV [W14], W4
0034C0  900264     MOV [W4+12], W4
0034C2  430204     ADD W6, W4, W4
0034C4  780185     MOV W5, W3
0034C6  90011E     MOV [W14+2], W2
0034C8  780084     MOV W4, W1
0034CA  78001E     MOV [W14], W0
0034CC  07FF97     RCALL _prvInsertTimerInActiveList
0034CE  780200     MOV W0, W4
0034D0  520FE1     SUB W4, #0x1, [W15]
0034D2  3A002A     BRA NZ, 0x3528
641:               					{
642:               						/* The timer expired before it was added to the active
643:               						timer list.  Process it now. */
644:               						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
0034D4  78021E     MOV [W14], W4
0034D6  900A14     MOV [W4+18], W4
0034D8  78001E     MOV [W14], W0
0034DA  010004     CALL W4
645:               						traceTIMER_EXPIRED( pxTimer );
646:               
647:               						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
0034DC  78021E     MOV [W14], W4
0034DE  900274     MOV [W4+14], W4
0034E0  520FE1     SUB W4, #0x1, [W15]
0034E2  3A0024     BRA NZ, 0x352C
648:               						{
649:               							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
0034E4  9002CE     MOV [W14+8], W5
0034E6  78021E     MOV [W14], W4
0034E8  900264     MOV [W4+12], W4
0034EA  428284     ADD W5, W4, W5
0034EC  EB0200     CLR W4
0034EE  EB0180     CLR W3
0034F0  780105     MOV W5, W2
0034F2  EB0080     CLR W1
0034F4  78001E     MOV [W14], W0
0034F6  07FEB0     RCALL xTimerGenericCommand
0034F8  780200     MOV W0, W4
0034FA  980724     MOV W4, [W14+4]
650:               							configASSERT( xResult );
651:               							( void ) xResult;
652:               						}
653:               						else
654:               						{
655:               							mtCOVERAGE_TEST_MARKER();
656:               						}
657:               					}
658:               					else
659:               					{
660:               						mtCOVERAGE_TEST_MARKER();
661:               					}
662:               					break;
0034FC  370018     BRA 0x352E
003528  000000     NOP
00352A  370001     BRA 0x352E
00352C  000000     NOP
663:               
664:               				case tmrCOMMAND_STOP :
665:               				case tmrCOMMAND_STOP_FROM_ISR :
666:               					/* The timer has already been removed from the active list.
667:               					There is nothing to do here. */
668:               					break;
003524  000000     NOP
003526  370003     BRA 0x352E
669:               
670:               				case tmrCOMMAND_CHANGE_PERIOD :
671:               				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
672:               					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
0034FE  9002CE     MOV [W14+8], W5
003500  78021E     MOV [W14], W4
003502  980265     MOV W5, [W4+12]
673:               					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
674:               
675:               					/* The new period does not really have a reference, and can be
676:               					longer or shorter than the old one.  The command time is
677:               					therefore set to the current time, and as the period cannot be
678:               					zero the next expiry time can only be in the future, meaning
679:               					(unlike for the xTimerStart() case above) there is no fail case
680:               					that needs to be handled here. */
681:               					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
003504  78021E     MOV [W14], W4
003506  9002E4     MOV [W4+12], W5
003508  90021E     MOV [W14+2], W4
00350A  428204     ADD W5, W4, W4
00350C  90019E     MOV [W14+2], W3
00350E  90011E     MOV [W14+2], W2
003510  780084     MOV W4, W1
003512  78001E     MOV [W14], W0
003514  07FF73     RCALL _prvInsertTimerInActiveList
682:               					break;
003516  37000B     BRA 0x352E
683:               
684:               				case tmrCOMMAND_DELETE :
685:               					/* The timer has already been removed from the active list,
686:               					just free up the memory. */
687:               					vPortFree( pxTimer );
003518  78001E     MOV [W14], W0
00351A  024330     CALL vPortFree
00351C  000000     NOP
688:               					break;
00351E  370007     BRA 0x352E
689:               
690:               				default	:
691:               					/* Don't expect to get here. */
692:               					break;
003520  000000     NOP
003522  370005     BRA 0x352E
693:               			}
694:               		}
695:               	}
696:               }
003544  FA8000     ULNK
003546  060000     RETURN
697:               /*-----------------------------------------------------------*/
698:               
699:               static void prvSwitchTimerLists( void )
700:               {
003548  FA000A     LNK #0xA
701:               TickType_t xNextExpireTime, xReloadTime;
702:               List_t *pxTemp;
703:               Timer_t *pxTimer;
704:               BaseType_t xResult;
705:               
706:               	/* The tick count has overflowed.  The timer lists must be switched.
707:               	If there are any timers still referenced from the current timer list
708:               	then they must have expired and should be processed before the lists
709:               	are switched. */
710:               	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
00354A  370031     BRA 0x35AE
0035AE  8301D4     MOV pxCurrentTimerList, W4
0035B0  780214     MOV [W4], W4
0035B2  520FE0     SUB W4, #0x0, [W15]
0035B4  3AFFCB     BRA NZ, 0x354C
711:               	{
712:               		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
00354C  8301D4     MOV pxCurrentTimerList, W4
00354E  900234     MOV [W4+6], W4
003550  780F14     MOV [W4], [W14]
713:               
714:               		/* Remove the timer from the list. */
715:               		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
003552  8301D4     MOV pxCurrentTimerList, W4
003554  900234     MOV [W4+6], W4
003556  900234     MOV [W4+6], W4
003558  980714     MOV W4, [W14+2]
716:               		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
00355A  90021E     MOV [W14+2], W4
00355C  E88204     INC2 W4, W4
00355E  780004     MOV W4, W0
003560  024C0E     CALL uxListRemove
003562  000000     NOP
717:               		traceTIMER_EXPIRED( pxTimer );
718:               
719:               		/* Execute its callback, then send a command to restart the timer if
720:               		it is an auto-reload timer.  It cannot be restarted here as the lists
721:               		have not yet been switched. */
722:               		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
003564  90021E     MOV [W14+2], W4
003566  900A14     MOV [W4+18], W4
003568  90001E     MOV [W14+2], W0
00356A  010004     CALL W4
723:               
724:               		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
00356C  90021E     MOV [W14+2], W4
00356E  900274     MOV [W4+14], W4
003570  520FE1     SUB W4, #0x1, [W15]
003572  3A001D     BRA NZ, 0x35AE
725:               		{
726:               			/* Calculate the reload value, and if the reload value results in
727:               			the timer going into the same timer list then it has already expired
728:               			and the timer should be re-inserted into the current list so it is
729:               			processed again within this loop.  Otherwise a command should be sent
730:               			to restart the timer to ensure it is only inserted into a list after
731:               			the lists have been swapped. */
732:               			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
003574  90021E     MOV [W14+2], W4
003576  900264     MOV [W4+12], W4
003578  42021E     ADD W4, [W14], W4
00357A  980724     MOV W4, [W14+4]
733:               			if( xReloadTime > xNextExpireTime )
00357C  90022E     MOV [W14+4], W4
00357E  520F9E     SUB W4, [W14], [W15]
003580  36000E     BRA LEU, 0x359E
734:               			{
735:               				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
003582  90021E     MOV [W14+2], W4
003584  9002AE     MOV [W14+4], W5
003586  980215     MOV W5, [W4+2]
736:               				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
003588  90021E     MOV [W14+2], W4
00358A  90029E     MOV [W14+2], W5
00358C  980245     MOV W5, [W4+8]
737:               				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
00358E  90021E     MOV [W14+2], W4
003590  E88284     INC2 W4, W5
003592  8301D4     MOV pxCurrentTimerList, W4
003594  780085     MOV W5, W1
003596  780004     MOV W4, W0
003598  024BAA     CALL vListInsert
00359A  000000     NOP
00359C  370008     BRA 0x35AE
738:               			}
739:               			else
740:               			{
741:               				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
00359E  EB0200     CLR W4
0035A0  EB0180     CLR W3
0035A2  78011E     MOV [W14], W2
0035A4  EB0080     CLR W1
0035A6  90001E     MOV [W14+2], W0
0035A8  07FE57     RCALL xTimerGenericCommand
0035AA  780200     MOV W0, W4
0035AC  980734     MOV W4, [W14+6]
742:               				configASSERT( xResult );
743:               				( void ) xResult;
744:               			}
745:               		}
746:               		else
747:               		{
748:               			mtCOVERAGE_TEST_MARKER();
749:               		}
750:               	}
751:               
752:               	pxTemp = pxCurrentTimerList;
0035B6  8301D4     MOV pxCurrentTimerList, W4
0035B8  980744     MOV W4, [W14+8]
753:               	pxCurrentTimerList = pxOverflowTimerList;
0035BA  8301E4     MOV pxOverflowTimerList, W4
0035BC  8B01D4     MOV W4, pxCurrentTimerList
754:               	pxOverflowTimerList = pxTemp;
0035BE  9002CE     MOV [W14+8], W5
0035C0  8B01E5     MOV W5, pxOverflowTimerList
755:               }
0035C2  FA8000     ULNK
0035C4  060000     RETURN
756:               /*-----------------------------------------------------------*/
757:               
758:               static void prvCheckForValidListAndQueue( void )
759:               {
0035C6  FA0000     LNK #0x0
760:               	/* Check that the list from which active timers are referenced, and the
761:               	queue used to communicate with the timer service, have been
762:               	initialised. */
763:               	taskENTER_CRITICAL();
0035C8  02497A     CALL vPortEnterCritical
0035CA  000000     NOP
764:               	{
765:               		if( xTimerQueue == NULL )
0035CC  8301F4     MOV xTimerQueue, W4
0035CE  520FE0     SUB W4, #0x0, [W15]
0035D0  3A0011     BRA NZ, 0x35F4
766:               		{
767:               			vListInitialise( &xActiveTimerList1 );
0035D2  260260     MOV #0x6026, W0
0035D4  024B2E     CALL vListInitialise
0035D6  000000     NOP
768:               			vListInitialise( &xActiveTimerList2 );
0035D8  260300     MOV #0x6030, W0
0035DA  024B2E     CALL vListInitialise
0035DC  000000     NOP
769:               			pxCurrentTimerList = &xActiveTimerList1;
0035DE  260264     MOV #0x6026, W4
0035E0  8B01D4     MOV W4, pxCurrentTimerList
770:               			pxOverflowTimerList = &xActiveTimerList2;
0035E2  260304     MOV #0x6030, W4
0035E4  8B01E4     MOV W4, pxOverflowTimerList
771:               			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
0035E6  EB4100     CLR.B W2
0035E8  200061     MOV #0x6, W1
0035EA  200050     MOV #0x5, W0
0035EC  0224A0     CALL xQueueGenericCreate
0035EE  000000     NOP
0035F0  780200     MOV W0, W4
0035F2  8B01F4     MOV W4, xTimerQueue
772:               			configASSERT( xTimerQueue );
773:               
774:               			#if ( configQUEUE_REGISTRY_SIZE > 0 )
775:               			{
776:               				if( xTimerQueue != NULL )
777:               				{
778:               					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
779:               				}
780:               				else
781:               				{
782:               					mtCOVERAGE_TEST_MARKER();
783:               				}
784:               			}
785:               			#endif /* configQUEUE_REGISTRY_SIZE */
786:               		}
787:               		else
788:               		{
789:               			mtCOVERAGE_TEST_MARKER();
790:               		}
791:               	}
792:               	taskEXIT_CRITICAL();
0035F4  02498E     CALL vPortExitCritical
0035F6  000000     NOP
793:               }
0035F8  FA8000     ULNK
0035FA  060000     RETURN
794:               /*-----------------------------------------------------------*/
795:               
796:               BaseType_t xTimerIsTimerActive( TimerHandle_t xTimer )
797:               {
0035FC  FA0006     LNK #0x6
0035FE  980720     MOV W0, [W14+4]
798:               BaseType_t xTimerIsInActiveList;
799:               Timer_t *pxTimer = ( Timer_t * ) xTimer;
003600  90022E     MOV [W14+4], W4
003602  780F04     MOV W4, [W14]
800:               
801:               	/* Is the timer in the list of active timers? */
802:               	taskENTER_CRITICAL();
003604  02497A     CALL vPortEnterCritical
003606  000000     NOP
803:               	{
804:               		/* Checking to see if it is in the NULL list in effect checks to see if
805:               		it is referenced from either the current or the overflow timer lists in
806:               		one go, but the logic has to be reversed, hence the '!'. */
807:               		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
003608  78021E     MOV [W14], W4
00360A  900254     MOV [W4+10], W4
00360C  A7F004     BTSC W4, #15
00360E  EA0204     NEG W4, W4
003610  EA0204     NEG W4, W4
003612  DE224F     LSR W4, #15, W4
003614  980714     MOV W4, [W14+2]
808:               	}
809:               	taskEXIT_CRITICAL();
003616  02498E     CALL vPortExitCritical
003618  000000     NOP
810:               
811:               	return xTimerIsInActiveList;
00361A  90021E     MOV [W14+2], W4
812:               } /*lint !e818 Can't be pointer to const due to the typedef. */
00361C  780004     MOV W4, W0
00361E  FA8000     ULNK
003620  060000     RETURN
813:               /*-----------------------------------------------------------*/
814:               
815:               void *pvTimerGetTimerID( const TimerHandle_t xTimer )
816:               {
003622  FA0004     LNK #0x4
003624  980710     MOV W0, [W14+2]
817:               Timer_t * const pxTimer = ( Timer_t * ) xTimer;
003626  90021E     MOV [W14+2], W4
003628  780F04     MOV W4, [W14]
818:               
819:               	return pxTimer->pvTimerID;
00362A  78021E     MOV [W14], W4
00362C  900A04     MOV [W4+16], W4
820:               }
00362E  780004     MOV W4, W0
003630  FA8000     ULNK
003632  060000     RETURN
821:               /*-----------------------------------------------------------*/
822:               
823:               #if( INCLUDE_xTimerPendFunctionCall == 1 )
824:               
825:               	BaseType_t xTimerPendFunctionCallFromISR( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken )
826:               	{
827:               	DaemonTaskMessage_t xMessage;
828:               	BaseType_t xReturn;
829:               
830:               		/* Complete the message with the function parameters and post it to the
831:               		daemon task. */
832:               		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR;
833:               		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
834:               		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
835:               		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
836:               
837:               		xReturn = xQueueSendFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
838:               		
839:               		tracePEND_FUNC_CALL_FROM_ISR( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
840:               
841:               		return xReturn;
842:               	}
843:               
844:               #endif /* INCLUDE_xTimerPendFunctionCall */
845:               /*-----------------------------------------------------------*/
846:               
847:               #if( INCLUDE_xTimerPendFunctionCall == 1 )
848:               
849:               	BaseType_t xTimerPendFunctionCall( PendedFunction_t xFunctionToPend, void *pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait )
850:               	{
851:               	DaemonTaskMessage_t xMessage;
852:               	BaseType_t xReturn;
853:               
854:               		/* Complete the message with the function parameters and post it to the
855:               		daemon task. */
856:               		xMessage.xMessageID = tmrCOMMAND_EXECUTE_CALLBACK;
857:               		xMessage.u.xCallbackParameters.pxCallbackFunction = xFunctionToPend;
858:               		xMessage.u.xCallbackParameters.pvParameter1 = pvParameter1;
859:               		xMessage.u.xCallbackParameters.ulParameter2 = ulParameter2;
860:               
861:               		xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
862:               
863:               		tracePEND_FUNC_CALL( xFunctionToPend, pvParameter1, ulParameter2, xReturn );
864:               		
865:               		return xReturn;
866:               	}
867:               
868:               #endif /* INCLUDE_xTimerPendFunctionCall */
869:               /*-----------------------------------------------------------*/
870:               
871:               /* This entire source file will be skipped if the application is not configured
872:               to include software timer functionality.  If you want to include software timer
873:               functionality then ensure configUSE_TIMERS is set to 1 in FreeRTOSConfig.h. */
874:               #endif /* configUSE_TIMERS == 1 */
875:               
876:               
877:               
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/FreeRTOS/tasks.c  -
1:                 /*
2:                     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     ***************************************************************************
8:                      *                                                                       *
9:                      *    FreeRTOS provides completely free yet professionally developed,    *
10:                     *    robust, strictly quality controlled, supported, and cross          *
11:                     *    platform software that has become a de facto standard.             *
12:                     *                                                                       *
13:                     *    Help yourself get started quickly and support the FreeRTOS         *
14:                     *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                     *                                                                       *
17:                     *    Thank you!                                                         *
18:                     *                                                                       *
19:                    ***************************************************************************
20:                
21:                    This file is part of the FreeRTOS distribution.
22:                
23:                    FreeRTOS is free software; you can redistribute it and/or modify it under
24:                    the terms of the GNU General Public License (version 2) as published by the
25:                    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                
27:                    >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                    >>! a combined work that includes FreeRTOS without being obliged to provide
29:                    >>! the source code for proprietary components outside of the FreeRTOS
30:                    >>! kernel.
31:                
32:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                    link: http://www.freertos.org/a00114.html
36:                
37:                    1 tab == 4 spaces!
38:                
39:                    ***************************************************************************
40:                     *                                                                       *
41:                     *    Having a problem?  Start by reading the FAQ "My application does   *
42:                     *    not run, what could be wrong?"                                     *
43:                     *                                                                       *
44:                     *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                     *                                                                       *
46:                    ***************************************************************************
47:                
48:                    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                    license and Real Time Engineers Ltd. contact details.
50:                
51:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                
55:                    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                    licenses offer ticketed support, indemnification and middleware.
58:                
59:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                    engineered and independently SIL3 certified version for use in safety and
61:                    mission critical applications that require provable dependability.
62:                
63:                    1 tab == 4 spaces!
64:                */
65:                
66:                /* Standard includes. */
67:                #include <stdlib.h>
68:                #include <string.h>
69:                
70:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
71:                all the API functions to use the MPU wrappers.  That should only be done when
72:                task.h is included from an application file. */
73:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
74:                
75:                /* FreeRTOS includes. */
76:                #include "FreeRTOS.h"
77:                #include "task.h"
78:                #include "timers.h"
79:                #include "StackMacros.h"
80:                
81:                /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
82:                MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
83:                header files above, but not in this file, in order to generate the correct
84:                privileged Vs unprivileged linkage and placement. */
85:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
86:                
87:                #if ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 )
88:                	/* At the bottom of this file are two optional functions that can be used
89:                	to generate human readable text from the raw data generated by the
90:                	uxTaskGetSystemState() function.  Note the formatting functions are provided
91:                	for convenience only, and are NOT considered part of the kernel. */
92:                	#include <stdio.h>
93:                #endif /* configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) */
94:                
95:                /* Sanity check the configuration. */
96:                #if configUSE_TICKLESS_IDLE != 0
97:                	#if INCLUDE_vTaskSuspend != 1
98:                		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
99:                	#endif /* INCLUDE_vTaskSuspend */
100:               #endif /* configUSE_TICKLESS_IDLE */
101:               
102:               /*
103:                * Defines the size, in words, of the stack allocated to the idle task.
104:                */
105:               #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
106:               
107:               #if( configUSE_PREEMPTION == 0 )
108:               	/* If the cooperative scheduler is being used then a yield should not be
109:               	performed just because a higher priority task has been woken. */
110:               	#define taskYIELD_IF_USING_PREEMPTION()
111:               #else
112:               	#define taskYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
113:               #endif
114:               
115:               /*
116:                * Task control block.  A task control block (TCB) is allocated for each task,
117:                * and stores task state information, including a pointer to the task's context
118:                * (the task's run time environment, including register values)
119:                */
120:               typedef struct tskTaskControlBlock
121:               {
122:               	volatile StackType_t	*pxTopOfStack;	/*< Points to the location of the last item placed on the tasks stack.  THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */
123:               
124:               	#if ( portUSING_MPU_WRAPPERS == 1 )
125:               		xMPU_SETTINGS	xMPUSettings;		/*< The MPU settings are defined as part of the port layer.  THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */
126:               	#endif
127:               
128:               	ListItem_t			xGenericListItem;	/*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */
129:               	ListItem_t			xEventListItem;		/*< Used to reference a task from an event list. */
130:               	UBaseType_t			uxPriority;			/*< The priority of the task.  0 is the lowest priority. */
131:               	StackType_t			*pxStack;			/*< Points to the start of the stack. */
132:               	char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when created.  Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
133:               
134:               	#if ( portSTACK_GROWTH > 0 )
135:               		StackType_t		*pxEndOfStack;		/*< Points to the end of the stack on architectures where the stack grows up from low memory. */
136:               	#endif
137:               
138:               	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
139:               		UBaseType_t 	uxCriticalNesting; 	/*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */
140:               	#endif
141:               
142:               	#if ( configUSE_TRACE_FACILITY == 1 )
143:               		UBaseType_t		uxTCBNumber;		/*< Stores a number that increments each time a TCB is created.  It allows debuggers to determine when a task has been deleted and then recreated. */
144:               		UBaseType_t  	uxTaskNumber;		/*< Stores a number specifically for use by third party trace code. */
145:               	#endif
146:               
147:               	#if ( configUSE_MUTEXES == 1 )
148:               		UBaseType_t 	uxBasePriority;		/*< The priority last assigned to the task - used by the priority inheritance mechanism. */
149:               	#endif
150:               
151:               	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
152:               		TaskHookFunction_t pxTaskTag;
153:               	#endif
154:               
155:               	#if ( configGENERATE_RUN_TIME_STATS == 1 )
156:               		uint32_t		ulRunTimeCounter;	/*< Stores the amount of time the task has spent in the Running state. */
157:               	#endif
158:               
159:               	#if ( configUSE_NEWLIB_REENTRANT == 1 )
160:               		/* Allocate a Newlib reent structure that is specific to this task.
161:               		Note Newlib support has been included by popular demand, but is not
162:               		used by the FreeRTOS maintainers themselves.  FreeRTOS is not
163:               		responsible for resulting newlib operation.  User must be familiar with
164:               		newlib and must provide system-wide implementations of the necessary
165:               		stubs. Be warned that (at the time of writing) the current newlib design
166:               		implements a system-wide malloc() that must be provided with locks. */
167:               		struct 	_reent xNewLib_reent;
168:               	#endif
169:               
170:               } tskTCB;
171:               
172:               /* The old tskTCB name is maintained above then typedefed to the new TCB_t name
173:               below to enable the use of older kernel aware debuggers. */
174:               typedef tskTCB TCB_t;
175:               
176:               /*
177:                * Some kernel aware debuggers require the data the debugger needs access to to
178:                * be global, rather than file scope.
179:                */
180:               #ifdef portREMOVE_STATIC_QUALIFIER
181:               	#define static
182:               #endif
183:               
184:               /*lint -e956 A manual analysis and inspection has been used to determine which
185:               static variables must be declared volatile. */
186:               
187:               PRIVILEGED_DATA TCB_t * volatile pxCurrentTCB = NULL;
188:               
189:               /* Lists for ready and blocked tasks. --------------------*/
190:               PRIVILEGED_DATA static List_t pxReadyTasksLists[ configMAX_PRIORITIES ];/*< Prioritised ready tasks. */
191:               PRIVILEGED_DATA static List_t xDelayedTaskList1;						/*< Delayed tasks. */
192:               PRIVILEGED_DATA static List_t xDelayedTaskList2;						/*< Delayed tasks (two lists are used - one for delays that have overflowed the current tick count. */
193:               PRIVILEGED_DATA static List_t * volatile pxDelayedTaskList;				/*< Points to the delayed task list currently being used. */
194:               PRIVILEGED_DATA static List_t * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task list currently being used to hold tasks that have overflowed the current tick count. */
195:               PRIVILEGED_DATA static List_t xPendingReadyList;						/*< Tasks that have been readied while the scheduler was suspended.  They will be moved to the ready list when the scheduler is resumed. */
196:               
197:               #if ( INCLUDE_vTaskDelete == 1 )
198:               
199:               	PRIVILEGED_DATA static List_t xTasksWaitingTermination;				/*< Tasks that have been deleted - but their memory not yet freed. */
200:               	PRIVILEGED_DATA static volatile UBaseType_t uxTasksDeleted = ( UBaseType_t ) 0U;
201:               
202:               #endif
203:               
204:               #if ( INCLUDE_vTaskSuspend == 1 )
205:               
206:               	PRIVILEGED_DATA static List_t xSuspendedTaskList;					/*< Tasks that are currently suspended. */
207:               
208:               #endif
209:               
210:               #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
211:               
212:               	PRIVILEGED_DATA static TaskHandle_t xIdleTaskHandle = NULL;			/*< Holds the handle of the idle task.  The idle task is created automatically when the scheduler is started. */
213:               
214:               #endif
215:               
216:               /* Other file private variables. --------------------------------*/
217:               PRIVILEGED_DATA static volatile UBaseType_t uxCurrentNumberOfTasks 	= ( UBaseType_t ) 0U;
218:               PRIVILEGED_DATA static volatile TickType_t xTickCount 				= ( TickType_t ) 0U;
219:               PRIVILEGED_DATA static volatile UBaseType_t uxTopReadyPriority 		= tskIDLE_PRIORITY;
220:               PRIVILEGED_DATA static volatile BaseType_t xSchedulerRunning 		= pdFALSE;
221:               PRIVILEGED_DATA static volatile UBaseType_t uxPendedTicks 			= ( UBaseType_t ) 0U;
222:               PRIVILEGED_DATA static volatile BaseType_t xYieldPending 			= pdFALSE;
223:               PRIVILEGED_DATA static volatile BaseType_t xNumOfOverflows 			= ( BaseType_t ) 0;
224:               PRIVILEGED_DATA static UBaseType_t uxTaskNumber 					= ( UBaseType_t ) 0U;
225:               PRIVILEGED_DATA static volatile TickType_t xNextTaskUnblockTime		= portMAX_DELAY;
226:               
227:               /* Context switches are held pending while the scheduler is suspended.  Also,
228:               interrupts must not manipulate the xStateListItem of a TCB, or any of the
229:               lists the xStateListItem can be referenced from, if the scheduler is suspended.
230:               If an interrupt needs to unblock a task while the scheduler is suspended then it
231:               moves the task's event list item into the xPendingReadyList, ready for the
232:               kernel to move the task from the pending ready list into the real ready list
233:               when the scheduler is unsuspended.  The pending ready list itself can only be
234:               accessed from a critical section. */
235:               PRIVILEGED_DATA static volatile UBaseType_t uxSchedulerSuspended	= ( UBaseType_t ) pdFALSE;
236:               
237:               #if ( configGENERATE_RUN_TIME_STATS == 1 )
238:               
239:               	PRIVILEGED_DATA static uint32_t ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/counter the last time a task was switched in. */
240:               	PRIVILEGED_DATA static uint32_t ulTotalRunTime = 0UL;		/*< Holds the total amount of execution time as defined by the run time counter clock. */
241:               
242:               #endif
243:               
244:               /*lint +e956 */
245:               
246:               /* Debugging and trace facilities private variables and macros. ------------*/
247:               
248:               /*
249:                * The value used to fill the stack of a task when the task is created.  This
250:                * is used purely for checking the high water mark for tasks.
251:                */
252:               #define tskSTACK_FILL_BYTE	( 0xa5U )
253:               
254:               /*
255:                * Macros used by vListTask to indicate which state a task is in.
256:                */
257:               #define tskBLOCKED_CHAR		( 'B' )
258:               #define tskREADY_CHAR		( 'R' )
259:               #define tskDELETED_CHAR		( 'D' )
260:               #define tskSUSPENDED_CHAR	( 'S' )
261:               
262:               /*-----------------------------------------------------------*/
263:               
264:               #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION == 0 )
265:               
266:               	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 0 then task selection is
267:               	performed in a generic way that is not optimised to any particular
268:               	microcontroller architecture. */
269:               
270:               	/* uxTopReadyPriority holds the priority of the highest priority ready
271:               	state task. */
272:               	#define taskRECORD_READY_PRIORITY( uxPriority )														\
273:               	{																									\
274:               		if( ( uxPriority ) > uxTopReadyPriority )														\
275:               		{																								\
276:               			uxTopReadyPriority = ( uxPriority );														\
277:               		}																								\
278:               	} /* taskRECORD_READY_PRIORITY */
279:               
280:               	/*-----------------------------------------------------------*/
281:               
282:               	#define taskSELECT_HIGHEST_PRIORITY_TASK()															\
283:               	{																									\
284:               		/* Find the highest priority queue that contains ready tasks. */								\
285:               		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )						\
286:               		{																								\
287:               			configASSERT( uxTopReadyPriority );															\
288:               			--uxTopReadyPriority;																		\
289:               		}																								\
290:               																										\
291:               		/* listGET_OWNER_OF_NEXT_ENTRY indexes through the list, so the tasks of						\
292:               		the	same priority get an equal share of the processor time. */									\
293:               		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );		\
294:               	} /* taskSELECT_HIGHEST_PRIORITY_TASK */
295:               
296:               	/*-----------------------------------------------------------*/
297:               
298:               	/* Define away taskRESET_READY_PRIORITY() and portRESET_READY_PRIORITY() as
299:               	they are only required when a port optimised method of task selection is
300:               	being used. */
301:               	#define taskRESET_READY_PRIORITY( uxPriority )
302:               	#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority )
303:               
304:               #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
305:               
306:               	/* If configUSE_PORT_OPTIMISED_TASK_SELECTION is 1 then task selection is
307:               	performed in a way that is tailored to the particular microcontroller
308:               	architecture being used. */
309:               
310:               	/* A port optimised version is provided.  Call the port defined macros. */
311:               	#define taskRECORD_READY_PRIORITY( uxPriority )	portRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority )
312:               
313:               	/*-----------------------------------------------------------*/
314:               
315:               	#define taskSELECT_HIGHEST_PRIORITY_TASK()														\
316:               	{																								\
317:               	UBaseType_t uxTopPriority;																		\
318:               																									\
319:               		/* Find the highest priority queue that contains ready tasks. */							\
320:               		portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );								\
321:               		configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );		\
322:               		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );		\
323:               	} /* taskSELECT_HIGHEST_PRIORITY_TASK() */
324:               
325:               	/*-----------------------------------------------------------*/
326:               
327:               	/* A port optimised version is provided, call it only if the TCB being reset
328:               	is being referenced from a ready list.  If it is referenced from a delayed
329:               	or suspended list then it won't be in a ready list. */
330:               	#define taskRESET_READY_PRIORITY( uxPriority )													\
331:               	{																								\
332:               		if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) == 0 )				\
333:               		{																							\
334:               			portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );						\
335:               		}																							\
336:               	}
337:               
338:               #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */
339:               
340:               /*-----------------------------------------------------------*/
341:               
342:               /* pxDelayedTaskList and pxOverflowDelayedTaskList are switched when the tick
343:               count overflows. */
344:               #define taskSWITCH_DELAYED_LISTS()																	\
345:               {																									\
346:               	List_t *pxTemp;																					\
347:               																									\
348:               	/* The delayed tasks list should be empty when the lists are switched. */						\
349:               	configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );										\
350:               																									\
351:               	pxTemp = pxDelayedTaskList;																		\
352:               	pxDelayedTaskList = pxOverflowDelayedTaskList;													\
353:               	pxOverflowDelayedTaskList = pxTemp;																\
354:               	xNumOfOverflows++;																				\
355:               	prvResetNextTaskUnblockTime();																	\
356:               }
357:               
358:               /*-----------------------------------------------------------*/
359:               
360:               /*
361:                * Place the task represented by pxTCB into the appropriate ready list for
362:                * the task.  It is inserted at the end of the list.
363:                */
364:               #define prvAddTaskToReadyList( pxTCB )																\
365:               	traceMOVED_TASK_TO_READY_STATE( pxTCB )															\
366:               	taskRECORD_READY_PRIORITY( ( pxTCB )->uxPriority );												\
367:               	vListInsertEnd( &( pxReadyTasksLists[ ( pxTCB )->uxPriority ] ), &( ( pxTCB )->xGenericListItem ) )
368:               /*-----------------------------------------------------------*/
369:               
370:               /*
371:                * Several functions take an TaskHandle_t parameter that can optionally be NULL,
372:                * where NULL is used to indicate that the handle of the currently executing
373:                * task should be used in place of the parameter.  This macro simply checks to
374:                * see if the parameter is NULL and returns a pointer to the appropriate TCB.
375:                */
376:               #define prvGetTCBFromHandle( pxHandle ) ( ( ( pxHandle ) == NULL ) ? ( TCB_t * ) pxCurrentTCB : ( TCB_t * ) ( pxHandle ) )
377:               
378:               /* The item value of the event list item is normally used to hold the priority
379:               of the task to which it belongs (coded to allow it to be held in reverse
380:               priority order).  However, it is occasionally borrowed for other purposes.  It
381:               is important its value is not updated due to a task priority change while it is
382:               being used for another purpose.  The following bit definition is used to inform
383:               the scheduler that the value should not be changed - in which case it is the
384:               responsibility of whichever module is using the value to ensure it gets set back
385:               to its original value when it is released. */
386:               #if configUSE_16_BIT_TICKS == 1
387:               	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x8000U
388:               #else
389:               	#define taskEVENT_LIST_ITEM_VALUE_IN_USE	0x80000000UL
390:               #endif
391:               
392:               /* Callback function prototypes. --------------------------*/
393:               #if configCHECK_FOR_STACK_OVERFLOW > 0
394:               	extern void vApplicationStackOverflowHook( TaskHandle_t xTask, char *pcTaskName );
395:               #endif
396:               
397:               #if configUSE_TICK_HOOK > 0
398:               	extern void vApplicationTickHook( void );
399:               #endif
400:               
401:               /* File private functions. --------------------------------*/
402:               
403:               /*
404:                * Utility to ready a TCB for a given task.  Mainly just copies the parameters
405:                * into the TCB structure.
406:                */
407:               static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
408:               
409:               /**
410:                * Utility task that simply returns pdTRUE if the task referenced by xTask is
411:                * currently in the Suspended state, or pdFALSE if the task referenced by xTask
412:                * is in any other state.
413:                */
414:               static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
415:               
416:               /*
417:                * Utility to ready all the lists used by the scheduler.  This is called
418:                * automatically upon the creation of the first task.
419:                */
420:               static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
421:               
422:               /*
423:                * The idle task, which as all tasks is implemented as a never ending loop.
424:                * The idle task is automatically created and added to the ready lists upon
425:                * creation of the first user task.
426:                *
427:                * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
428:                * language extensions.  The equivalent prototype for this function is:
429:                *
430:                * void prvIdleTask( void *pvParameters );
431:                *
432:                */
433:               static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
434:               
435:               /*
436:                * Utility to free all memory allocated by the scheduler to hold a TCB,
437:                * including the stack pointed to by the TCB.
438:                *
439:                * This does not free memory allocated by the task itself (i.e. memory
440:                * allocated by calls to pvPortMalloc from within the tasks application code).
441:                */
442:               #if ( INCLUDE_vTaskDelete == 1 )
443:               
444:               	static void prvDeleteTCB( TCB_t *pxTCB ) PRIVILEGED_FUNCTION;
445:               
446:               #endif
447:               
448:               /*
449:                * Used only by the idle task.  This checks to see if anything has been placed
450:                * in the list of tasks waiting to be deleted.  If so the task is cleaned up
451:                * and its TCB deleted.
452:                */
453:               static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
454:               
455:               /*
456:                * The currently executing task is entering the Blocked state.  Add the task to
457:                * either the current or the overflow delayed task list.
458:                */
459:               static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake ) PRIVILEGED_FUNCTION;
460:               
461:               /*
462:                * Allocates memory from the heap for a TCB and associated stack.  Checks the
463:                * allocation was successful.
464:                */
465:               static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer ) PRIVILEGED_FUNCTION;
466:               
467:               /*
468:                * Fills an TaskStatus_t structure with information on each task that is
469:                * referenced from the pxList list (which may be a ready list, a delayed list,
470:                * a suspended list, etc.).
471:                *
472:                * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
473:                * NORMAL APPLICATION CODE.
474:                */
475:               #if ( configUSE_TRACE_FACILITY == 1 )
476:               
477:               	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState ) PRIVILEGED_FUNCTION;
478:               
479:               #endif
480:               
481:               /*
482:                * When a task is created, the stack of the task is filled with a known value.
483:                * This function determines the 'high water mark' of the task stack by
484:                * determining how much of the stack remains at the original preset value.
485:                */
486:               #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
487:               
488:               	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte ) PRIVILEGED_FUNCTION;
489:               
490:               #endif
491:               
492:               /*
493:                * Return the amount of time, in ticks, that will pass before the kernel will
494:                * next move a task from the Blocked state to the Running state.
495:                *
496:                * This conditional compilation should use inequality to 0, not equality to 1.
497:                * This is to ensure portSUPPRESS_TICKS_AND_SLEEP() can be called when user
498:                * defined low power mode implementations require configUSE_TICKLESS_IDLE to be
499:                * set to a value other than 1.
500:                */
501:               #if ( configUSE_TICKLESS_IDLE != 0 )
502:               
503:               	static TickType_t prvGetExpectedIdleTime( void ) PRIVILEGED_FUNCTION;
504:               
505:               #endif
506:               
507:               /*
508:                * Set xNextTaskUnblockTime to the time at which the next Blocked state task
509:                * will exit the Blocked state.
510:                */
511:               static void prvResetNextTaskUnblockTime( void );
512:               
513:               /*-----------------------------------------------------------*/
514:               
515:               BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
516:               {
001422  FA0016     LNK #0x16
001424  980730     MOV W0, [W14+6]
001426  980741     MOV W1, [W14+8]
001428  980752     MOV W2, [W14+10]
00142A  980763     MOV W3, [W14+12]
00142C  980774     MOV W4, [W14+14]
00142E  980F05     MOV W5, [W14+16]
001430  980F16     MOV W6, [W14+18]
001432  980F27     MOV W7, [W14+20]
517:               BaseType_t xReturn;
518:               TCB_t * pxNewTCB;
519:               
520:               	configASSERT( pxTaskCode );
521:               	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
522:               
523:               	/* Allocate the memory required by the TCB and stack for the new task,
524:               	checking that the allocation was successful. */
525:               	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
001434  90089E     MOV [W14+18], W1
001436  90005E     MOV [W14+10], W0
001438  0705DC     RCALL prvAllocateTCBAndStack
00143A  780200     MOV W0, W4
00143C  980714     MOV W4, [W14+2]
526:               
527:               	if( pxNewTCB != NULL )
00143E  90021E     MOV [W14+2], W4
001440  520FE0     SUB W4, #0x0, [W15]
001442  320057     BRA Z, 0x14F2
528:               	{
529:               		StackType_t *pxTopOfStack;
530:               
531:               		#if( portUSING_MPU_WRAPPERS == 1 )
532:               			/* Should the task be created in privileged mode? */
533:               			BaseType_t xRunPrivileged;
534:               			if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
535:               			{
536:               				xRunPrivileged = pdTRUE;
537:               			}
538:               			else
539:               			{
540:               				xRunPrivileged = pdFALSE;
541:               			}
542:               			uxPriority &= ~portPRIVILEGE_BIT;
543:               		#endif /* portUSING_MPU_WRAPPERS == 1 */
544:               
545:               		/* Calculate the top of stack address.  This depends on whether the
546:               		stack grows from high memory to low (as per the 80x86) or vice versa.
547:               		portSTACK_GROWTH is used to make the result positive or negative as
548:               		required by the port. */
549:               		#if( portSTACK_GROWTH < 0 )
550:               		{
551:               			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
552:               			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
553:               
554:               			/* Check the alignment of the calculated top of stack is correct. */
555:               			configASSERT( ( ( ( uint32_t ) pxTopOfStack & ( uint32_t ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
556:               		}
557:               		#else /* portSTACK_GROWTH */
558:               		{
559:               			pxTopOfStack = pxNewTCB->pxStack;
001444  90021E     MOV [W14+2], W4
001446  900AC4     MOV [W4+24], W5
001448  980725     MOV W5, [W14+4]
560:               
561:               			/* Check the alignment of the stack buffer is correct. */
562:               			configASSERT( ( ( ( uint32_t ) pxNewTCB->pxStack & ( uint32_t ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
563:               
564:               			/* If we want to use stack checking on architectures that use
565:               			a positive stack growth direction then we also need to store the
566:               			other extreme of the stack space. */
567:               			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
00144A  90021E     MOV [W14+2], W4
00144C  900AC4     MOV [W4+24], W5
00144E  90025E     MOV [W14+10], W4
001450  E90204     DEC W4, W4
001452  420204     ADD W4, W4, W4
001454  428284     ADD W5, W4, W5
001456  90021E     MOV [W14+2], W4
001458  981215     MOV W5, [W4+34]
568:               		}
569:               		#endif /* portSTACK_GROWTH */
570:               
571:               		/* Setup the newly allocated TCB with the initial state of the task. */
572:               		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
00145A  90025E     MOV [W14+10], W4
00145C  9009AE     MOV [W14+20], W3
00145E  90017E     MOV [W14+14], W2
001460  9000CE     MOV [W14+8], W1
001462  90001E     MOV [W14+2], W0
001464  07051B     RCALL prvInitialiseTCBVariables
573:               
574:               		/* Initialize the TCB stack to look as if the task was already running,
575:               		but had been interrupted by the scheduler.  The return address is set
576:               		to the start of the task function. Once the stack has been initialised
577:               		the	top of stack variable is updated. */
578:               		#if( portUSING_MPU_WRAPPERS == 1 )
579:               		{
580:               			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
581:               		}
582:               		#else /* portUSING_MPU_WRAPPERS */
583:               		{
584:               			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
001466  90016E     MOV [W14+12], W2
001468  9000BE     MOV [W14+6], W1
00146A  90002E     MOV [W14+4], W0
00146C  024878     CALL pxPortInitialiseStack
00146E  000000     NOP
001470  780200     MOV W0, W4
001472  780284     MOV W4, W5
001474  90021E     MOV [W14+2], W4
001476  780A05     MOV W5, [W4]
585:               		}
586:               		#endif /* portUSING_MPU_WRAPPERS */
587:               
588:               		if( ( void * ) pxCreatedTask != NULL )
001478  900A0E     MOV [W14+16], W4
00147A  520FE0     SUB W4, #0x0, [W15]
00147C  320003     BRA Z, 0x1484
589:               		{
590:               			/* Pass the TCB out - in an anonymous way.  The calling function/
591:               			task can use this as a handle to delete the task later if
592:               			required.*/
593:               			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
00147E  900A0E     MOV [W14+16], W4
001480  90029E     MOV [W14+2], W5
001482  780A05     MOV W5, [W4]
594:               		}
595:               		else
596:               		{
597:               			mtCOVERAGE_TEST_MARKER();
598:               		}
599:               
600:               		/* Ensure interrupts don't access the task lists while they are being
601:               		updated. */
602:               		taskENTER_CRITICAL();
001484  02497A     CALL vPortEnterCritical
001486  000000     NOP
603:               		{
604:               			uxCurrentNumberOfTasks++;
001488  82FD74     MOV uxCurrentNumberOfTasks, W4
00148A  E80204     INC W4, W4
00148C  8AFD74     MOV W4, uxCurrentNumberOfTasks
605:               			if( pxCurrentTCB == NULL )
00148E  82FA14     MOV pxCurrentTCB, W4
001490  520FE0     SUB W4, #0x0, [W15]
001492  3A0007     BRA NZ, 0x14A2
606:               			{
607:               				/* There are no other tasks, or all the other tasks are in
608:               				the suspended state - make this the current task. */
609:               				pxCurrentTCB =  pxNewTCB;
001494  90021E     MOV [W14+2], W4
001496  8AFA14     MOV W4, pxCurrentTCB
610:               
611:               				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
001498  82FD74     MOV uxCurrentNumberOfTasks, W4
00149A  520FE1     SUB W4, #0x1, [W15]
00149C  3A000C     BRA NZ, 0x14B6
612:               				{
613:               					/* This is the first task to be created so do the preliminary
614:               					initialisation required.  We will not recover if this call
615:               					fails, but we will report the failure. */
616:               					prvInitialiseTaskLists();
00149E  07053D     RCALL prvInitialiseTaskLists
0014A0  37000A     BRA 0x14B6
617:               				}
618:               				else
619:               				{
620:               					mtCOVERAGE_TEST_MARKER();
621:               				}
622:               			}
623:               			else
624:               			{
625:               				/* If the scheduler is not already running, make this task the
626:               				current task if it is the highest priority task to be created
627:               				so far. */
628:               				if( xSchedulerRunning == pdFALSE )
0014A2  82FDA4     MOV xSchedulerRunning, W4
0014A4  520FE0     SUB W4, #0x0, [W15]
0014A6  3A0007     BRA NZ, 0x14B6
629:               				{
630:               					if( pxCurrentTCB->uxPriority <= uxPriority )
0014A8  82FA14     MOV pxCurrentTCB, W4
0014AA  900AB4     MOV [W4+22], W5
0014AC  90027E     MOV [W14+14], W4
0014AE  528F84     SUB W5, W4, [W15]
0014B0  3E0002     BRA GTU, 0x14B6
631:               					{
632:               						pxCurrentTCB = pxNewTCB;
0014B2  90029E     MOV [W14+2], W5
0014B4  8AFA15     MOV W5, pxCurrentTCB
633:               					}
634:               					else
635:               					{
636:               						mtCOVERAGE_TEST_MARKER();
637:               					}
638:               				}
639:               				else
640:               				{
641:               					mtCOVERAGE_TEST_MARKER();
642:               				}
643:               			}
644:               
645:               			uxTaskNumber++;
0014B6  82FDE4     MOV uxTaskNumber, W4
0014B8  E80204     INC W4, W4
0014BA  8AFDE4     MOV W4, uxTaskNumber
646:               
647:               			#if ( configUSE_TRACE_FACILITY == 1 )
648:               			{
649:               				/* Add a counter into the TCB for tracing only. */
650:               				pxNewTCB->uxTCBNumber = uxTaskNumber;
0014BC  82FDE5     MOV uxTaskNumber, W5
0014BE  90021E     MOV [W14+2], W4
0014C0  981225     MOV W5, [W4+36]
651:               			}
652:               			#endif /* configUSE_TRACE_FACILITY */
653:               			traceTASK_CREATE( pxNewTCB );
654:               
655:               			prvAddTaskToReadyList( pxNewTCB );
0014C2  90021E     MOV [W14+2], W4
0014C4  900AB4     MOV [W4+22], W5
0014C6  82FD94     MOV uxTopReadyPriority, W4
0014C8  528F84     SUB W5, W4, [W15]
0014CA  360003     BRA LEU, 0x14D2
0014CC  90021E     MOV [W14+2], W4
0014CE  900A34     MOV [W4+22], W4
0014D0  8AFD94     MOV W4, uxTopReadyPriority
0014D2  90021E     MOV [W14+2], W4
0014D4  E88284     INC2 W4, W5
0014D6  90021E     MOV [W14+2], W4
0014D8  900A34     MOV [W4+22], W4
0014DA  B923EA     MUL.SU W4, #10, W6
0014DC  25F444     MOV #0x5F44, W4
0014DE  430204     ADD W6, W4, W4
0014E0  780085     MOV W5, W1
0014E2  780004     MOV W4, W0
0014E4  024B6E     CALL vListInsertEnd
0014E6  000000     NOP
656:               
657:               			xReturn = pdPASS;
0014E8  200014     MOV #0x1, W4
0014EA  780F04     MOV W4, [W14]
658:               			portSETUP_TCB( pxNewTCB );
659:               		}
660:               		taskEXIT_CRITICAL();
0014EC  02498E     CALL vPortExitCritical
0014EE  000000     NOP
0014F0  370002     BRA 0x14F6
661:               	}
662:               	else
663:               	{
664:               		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
0014F2  EB8200     SETM W4
0014F4  780F04     MOV W4, [W14]
665:               		traceTASK_CREATE_FAILED();
666:               	}
667:               
668:               	if( xReturn == pdPASS )
0014F6  78021E     MOV [W14], W4
0014F8  520FE1     SUB W4, #0x1, [W15]
0014FA  3A000B     BRA NZ, 0x1512
669:               	{
670:               		if( xSchedulerRunning != pdFALSE )
0014FC  82FDA4     MOV xSchedulerRunning, W4
0014FE  520FE0     SUB W4, #0x0, [W15]
001500  320008     BRA Z, 0x1512
671:               		{
672:               			/* If the created task is of a higher priority than the current task
673:               			then it should run now. */
674:               			if( pxCurrentTCB->uxPriority < uxPriority )
001502  82FA14     MOV pxCurrentTCB, W4
001504  900AB4     MOV [W4+22], W5
001506  90027E     MOV [W14+14], W4
001508  528F84     SUB W5, W4, [W15]
00150A  310003     BRA C, 0x1512
675:               			{
676:               				taskYIELD_IF_USING_PREEMPTION();
00150C  024F06     CALL _vPortYield
00150E  000000     NOP
001510  000000     NOP
677:               			}
678:               			else
679:               			{
680:               				mtCOVERAGE_TEST_MARKER();
681:               			}
682:               		}
683:               		else
684:               		{
685:               			mtCOVERAGE_TEST_MARKER();
686:               		}
687:               	}
688:               
689:               	return xReturn;
001512  78021E     MOV [W14], W4
690:               }
001514  780004     MOV W4, W0
001516  FA8000     ULNK
001518  060000     RETURN
691:               /*-----------------------------------------------------------*/
692:               
693:               #if ( INCLUDE_vTaskDelete == 1 )
694:               
695:               	void vTaskDelete( TaskHandle_t xTaskToDelete )
696:               	{
00151A  FA0004     LNK #0x4
00151C  980710     MOV W0, [W14+2]
697:               	TCB_t *pxTCB;
698:               
699:               		taskENTER_CRITICAL();
00151E  02497A     CALL vPortEnterCritical
001520  000000     NOP
700:               		{
701:               			/* If null is passed in here then it is the calling task that is
702:               			being deleted. */
703:               			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
001522  90021E     MOV [W14+2], W4
001524  520FE0     SUB W4, #0x0, [W15]
001526  3A0002     BRA NZ, 0x152C
001528  82FA14     MOV pxCurrentTCB, W4
00152A  370001     BRA 0x152E
00152C  90021E     MOV [W14+2], W4
00152E  780F04     MOV W4, [W14]
704:               
705:               			/* Remove task from the ready list and place in the	termination list.
706:               			This will stop the task from be scheduled.  The idle task will check
707:               			the termination list and free up any memory allocated by the
708:               			scheduler for the TCB and stack. */
709:               			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
001530  E8821E     INC2 [W14], W4
001532  780004     MOV W4, W0
001534  024C0E     CALL uxListRemove
001536  000000     NOP
710:               			{
711:               				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
712:               			}
713:               			else
714:               			{
715:               				mtCOVERAGE_TEST_MARKER();
716:               			}
717:               
718:               			/* Is the task waiting on an event also? */
719:               			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
001538  78021E     MOV [W14], W4
00153A  900A24     MOV [W4+20], W4
00153C  520FE0     SUB W4, #0x0, [W15]
00153E  320005     BRA Z, 0x154A
720:               			{
721:               				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
001540  78029E     MOV [W14], W5
001542  42826C     ADD W5, #0xC, W4
001544  780004     MOV W4, W0
001546  024C0E     CALL uxListRemove
001548  000000     NOP
722:               			}
723:               			else
724:               			{
725:               				mtCOVERAGE_TEST_MARKER();
726:               			}
727:               
728:               			vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
00154A  E8821E     INC2 [W14], W4
00154C  780084     MOV W4, W1
00154E  25F980     MOV #0x5F98, W0
001550  024B6E     CALL vListInsertEnd
001552  000000     NOP
729:               
730:               			/* Increment the ucTasksDeleted variable so the idle task knows
731:               			there is a task that has been deleted and that it should therefore
732:               			check the xTasksWaitingTermination list. */
733:               			++uxTasksDeleted;
001554  82FD14     MOV uxTasksDeleted, W4
001556  E80204     INC W4, W4
001558  8AFD14     MOV W4, uxTasksDeleted
734:               
735:               			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
736:               			can detect that the task lists need re-generating. */
737:               			uxTaskNumber++;
00155A  82FDE4     MOV uxTaskNumber, W4
00155C  E80204     INC W4, W4
00155E  8AFDE4     MOV W4, uxTaskNumber
738:               
739:               			traceTASK_DELETE( pxTCB );
740:               		}
741:               		taskEXIT_CRITICAL();
001560  02498E     CALL vPortExitCritical
001562  000000     NOP
742:               
743:               		/* Force a reschedule if it is the currently running task that has just
744:               		been deleted. */
745:               		if( xSchedulerRunning != pdFALSE )
001564  82FDA4     MOV xSchedulerRunning, W4
001566  520FE0     SUB W4, #0x0, [W15]
001568  320009     BRA Z, 0x157C
746:               		{
747:               			if( pxTCB == pxCurrentTCB )
00156A  82FA14     MOV pxCurrentTCB, W4
00156C  78029E     MOV [W14], W5
00156E  528F84     SUB W5, W4, [W15]
001570  3A0004     BRA NZ, 0x157A
748:               			{
749:               				configASSERT( uxSchedulerSuspended == 0 );
750:               
751:               				/* The pre-delete hook is primarily for the Windows simulator,
752:               				in which Windows specific clean up operations are performed,
753:               				after which it is not possible to yield away from this task -
754:               				hence xYieldPending is used to latch that a context switch is
755:               				required. */
756:               				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
757:               				portYIELD_WITHIN_API();
001572  024F06     CALL _vPortYield
001574  000000     NOP
001576  000000     NOP
001578  370001     BRA 0x157C
758:               			}
759:               			else
760:               			{
761:               				/* Reset the next expected unblock time in case it referred to
762:               				the task that has just been deleted. */
763:               				prvResetNextTaskUnblockTime();
00157A  07062B     RCALL prvResetNextTaskUnblockTime
764:               			}
765:               		}
766:               	}
00157C  FA8000     ULNK
00157E  060000     RETURN
767:               
768:               #endif /* INCLUDE_vTaskDelete */
769:               /*-----------------------------------------------------------*/
770:               
771:               #if ( INCLUDE_vTaskDelayUntil == 1 )
772:               
773:               	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
774:               	{
001580  FA000C     LNK #0xC
001582  980740     MOV W0, [W14+8]
001584  980751     MOV W1, [W14+10]
775:               	TickType_t xTimeToWake;
776:               	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
001586  EB0200     CLR W4
001588  780F04     MOV W4, [W14]
777:               
778:               		configASSERT( pxPreviousWakeTime );
779:               		configASSERT( ( xTimeIncrement > 0U ) );
780:               		configASSERT( uxSchedulerSuspended == 0 );
781:               
782:               		vTaskSuspendAll();
00158A  0701CE     RCALL vTaskSuspendAll
783:               		{
784:               			/* Minor optimisation.  The tick count cannot change in this
785:               			block. */
786:               			const TickType_t xConstTickCount = xTickCount;
00158C  82FD84     MOV xTickCount, W4
00158E  980714     MOV W4, [W14+2]
787:               
788:               			/* Generate the tick time at which the task wants to wake. */
789:               			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
001590  90024E     MOV [W14+8], W4
001592  780294     MOV [W4], W5
001594  90025E     MOV [W14+10], W4
001596  428204     ADD W5, W4, W4
001598  980724     MOV W4, [W14+4]
790:               
791:               			if( xConstTickCount < *pxPreviousWakeTime )
00159A  90024E     MOV [W14+8], W4
00159C  780294     MOV [W4], W5
00159E  90021E     MOV [W14+2], W4
0015A0  528F84     SUB W5, W4, [W15]
0015A2  36000C     BRA LEU, 0x15BC
792:               			{
793:               				/* The tick count has overflowed since this function was
794:               				lasted called.  In this case the only time we should ever
795:               				actually delay is if the wake time has also	overflowed,
796:               				and the wake time is greater than the tick time.  When this
797:               				is the case it is as if neither time had overflowed. */
798:               				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
0015A4  90024E     MOV [W14+8], W4
0015A6  780294     MOV [W4], W5
0015A8  90022E     MOV [W14+4], W4
0015AA  528F84     SUB W5, W4, [W15]
0015AC  360012     BRA LEU, 0x15D2
0015AE  9002AE     MOV [W14+4], W5
0015B0  90021E     MOV [W14+2], W4
0015B2  528F84     SUB W5, W4, [W15]
0015B4  36000E     BRA LEU, 0x15D2
799:               				{
800:               					xShouldDelay = pdTRUE;
0015B6  200014     MOV #0x1, W4
0015B8  780F04     MOV W4, [W14]
0015BA  37000B     BRA 0x15D2
801:               				}
802:               				else
803:               				{
804:               					mtCOVERAGE_TEST_MARKER();
805:               				}
806:               			}
807:               			else
808:               			{
809:               				/* The tick time has not overflowed.  In this case we will
810:               				delay if either the wake time has overflowed, and/or the
811:               				tick time is less than the wake time. */
812:               				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
0015BC  90024E     MOV [W14+8], W4
0015BE  780294     MOV [W4], W5
0015C0  90022E     MOV [W14+4], W4
0015C2  528F84     SUB W5, W4, [W15]
0015C4  3E0004     BRA GTU, 0x15CE
0015C6  9002AE     MOV [W14+4], W5
0015C8  90021E     MOV [W14+2], W4
0015CA  528F84     SUB W5, W4, [W15]
0015CC  360002     BRA LEU, 0x15D2
813:               				{
814:               					xShouldDelay = pdTRUE;
0015CE  200014     MOV #0x1, W4
0015D0  780F04     MOV W4, [W14]
815:               				}
816:               				else
817:               				{
818:               					mtCOVERAGE_TEST_MARKER();
819:               				}
820:               			}
821:               
822:               			/* Update the wake time ready for the next call. */
823:               			*pxPreviousWakeTime = xTimeToWake;
0015D2  90024E     MOV [W14+8], W4
0015D4  9002AE     MOV [W14+4], W5
0015D6  780A05     MOV W5, [W4]
824:               
825:               			if( xShouldDelay != pdFALSE )
0015D8  78021E     MOV [W14], W4
0015DA  520FE0     SUB W4, #0x0, [W15]
0015DC  320007     BRA Z, 0x15EC
826:               			{
827:               				traceTASK_DELAY_UNTIL();
828:               
829:               				/* Remove the task from the ready list before adding it to the
830:               				blocked list as the same list item is used for both lists. */
831:               				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0015DE  82FA14     MOV pxCurrentTCB, W4
0015E0  E88204     INC2 W4, W4
0015E2  780004     MOV W4, W0
0015E4  024C0E     CALL uxListRemove
0015E6  000000     NOP
832:               				{
833:               					/* The current task must be in a ready list, so there is
834:               					no need to check, and the port reset macro can be called
835:               					directly. */
836:               					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
837:               				}
838:               				else
839:               				{
840:               					mtCOVERAGE_TEST_MARKER();
841:               				}
842:               
843:               				prvAddCurrentTaskToDelayedList( xTimeToWake );
0015E8  90002E     MOV [W14+4], W0
0015EA  0704E3     RCALL prvAddCurrentTaskToDelayedList
844:               			}
845:               			else
846:               			{
847:               				mtCOVERAGE_TEST_MARKER();
848:               			}
849:               		}
850:               		xAlreadyYielded = xTaskResumeAll();
0015EC  0701A3     RCALL xTaskResumeAll
0015EE  780200     MOV W0, W4
0015F0  980734     MOV W4, [W14+6]
851:               
852:               		/* Force a reschedule if xTaskResumeAll has not already done so, we may
853:               		have put ourselves to sleep. */
854:               		if( xAlreadyYielded == pdFALSE )
0015F2  90023E     MOV [W14+6], W4
0015F4  520FE0     SUB W4, #0x0, [W15]
0015F6  3A0003     BRA NZ, 0x15FE
855:               		{
856:               			portYIELD_WITHIN_API();
0015F8  024F06     CALL _vPortYield
0015FA  000000     NOP
0015FC  000000     NOP
857:               		}
858:               		else
859:               		{
860:               			mtCOVERAGE_TEST_MARKER();
861:               		}
862:               	}
0015FE  FA8000     ULNK
001600  060000     RETURN
863:               
864:               #endif /* INCLUDE_vTaskDelayUntil */
865:               /*-----------------------------------------------------------*/
866:               
867:               #if ( INCLUDE_vTaskDelay == 1 )
868:               
869:               	void vTaskDelay( const TickType_t xTicksToDelay )
870:               	{
001602  FA0006     LNK #0x6
001604  980720     MOV W0, [W14+4]
871:               	TickType_t xTimeToWake;
872:               	BaseType_t xAlreadyYielded = pdFALSE;
001606  EB0200     CLR W4
001608  780F04     MOV W4, [W14]
873:               
874:               
875:               		/* A delay time of zero just forces a reschedule. */
876:               		if( xTicksToDelay > ( TickType_t ) 0U )
00160A  90022E     MOV [W14+4], W4
00160C  520FE0     SUB W4, #0x0, [W15]
00160E  32000F     BRA Z, 0x162E
877:               		{
878:               			configASSERT( uxSchedulerSuspended == 0 );
879:               			vTaskSuspendAll();
001610  07018B     RCALL vTaskSuspendAll
880:               			{
881:               				traceTASK_DELAY();
882:               
883:               				/* A task that is removed from the event list while the
884:               				scheduler is suspended will not get placed in the ready
885:               				list or removed from the blocked list until the scheduler
886:               				is resumed.
887:               
888:               				This task cannot be in an event list as it is the currently
889:               				executing task. */
890:               
891:               				/* Calculate the time to wake - this may overflow but this is
892:               				not a problem. */
893:               				xTimeToWake = xTickCount + xTicksToDelay;
001612  82FD85     MOV xTickCount, W5
001614  90022E     MOV [W14+4], W4
001616  428204     ADD W5, W4, W4
001618  980714     MOV W4, [W14+2]
894:               
895:               				/* We must remove ourselves from the ready list before adding
896:               				ourselves to the blocked list as the same list item is used for
897:               				both lists. */
898:               				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00161A  82FA14     MOV pxCurrentTCB, W4
00161C  E88204     INC2 W4, W4
00161E  780004     MOV W4, W0
001620  024C0E     CALL uxListRemove
001622  000000     NOP
899:               				{
900:               					/* The current task must be in a ready list, so there is
901:               					no need to check, and the port reset macro can be called
902:               					directly. */
903:               					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
904:               				}
905:               				else
906:               				{
907:               					mtCOVERAGE_TEST_MARKER();
908:               				}
909:               				prvAddCurrentTaskToDelayedList( xTimeToWake );
001624  90001E     MOV [W14+2], W0
001626  0704C5     RCALL prvAddCurrentTaskToDelayedList
910:               			}
911:               			xAlreadyYielded = xTaskResumeAll();
001628  070185     RCALL xTaskResumeAll
00162A  780200     MOV W0, W4
00162C  780F04     MOV W4, [W14]
912:               		}
913:               		else
914:               		{
915:               			mtCOVERAGE_TEST_MARKER();
916:               		}
917:               
918:               		/* Force a reschedule if xTaskResumeAll has not already done so, we may
919:               		have put ourselves to sleep. */
920:               		if( xAlreadyYielded == pdFALSE )
00162E  78021E     MOV [W14], W4
001630  520FE0     SUB W4, #0x0, [W15]
001632  3A0003     BRA NZ, 0x163A
921:               		{
922:               			portYIELD_WITHIN_API();
001634  024F06     CALL _vPortYield
001636  000000     NOP
001638  000000     NOP
923:               		}
924:               		else
925:               		{
926:               			mtCOVERAGE_TEST_MARKER();
927:               		}
928:               	}
00163A  FA8000     ULNK
00163C  060000     RETURN
929:               
930:               #endif /* INCLUDE_vTaskDelay */
931:               /*-----------------------------------------------------------*/
932:               
933:               #if ( INCLUDE_eTaskGetState == 1 )
934:               
935:               	eTaskState eTaskGetState( TaskHandle_t xTask )
936:               	{
937:               	eTaskState eReturn;
938:               	List_t *pxStateList;
939:               	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
940:               
941:               		configASSERT( pxTCB );
942:               
943:               		if( pxTCB == pxCurrentTCB )
944:               		{
945:               			/* The task calling this function is querying its own state. */
946:               			eReturn = eRunning;
947:               		}
948:               		else
949:               		{
950:               			taskENTER_CRITICAL();
951:               			{
952:               				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xGenericListItem ) );
953:               			}
954:               			taskEXIT_CRITICAL();
955:               
956:               			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
957:               			{
958:               				/* The task being queried is referenced from one of the Blocked
959:               				lists. */
960:               				eReturn = eBlocked;
961:               			}
962:               
963:               			#if ( INCLUDE_vTaskSuspend == 1 )
964:               				else if( pxStateList == &xSuspendedTaskList )
965:               				{
966:               					/* The task being queried is referenced from the suspended
967:               					list.  Is it genuinely suspended or is it block
968:               					indefinitely? */
969:               					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
970:               					{
971:               						eReturn = eSuspended;
972:               					}
973:               					else
974:               					{
975:               						eReturn = eBlocked;
976:               					}
977:               				}
978:               			#endif
979:               
980:               			#if ( INCLUDE_vTaskDelete == 1 )
981:               				else if( pxStateList == &xTasksWaitingTermination )
982:               				{
983:               					/* The task being queried is referenced from the deleted
984:               					tasks list. */
985:               					eReturn = eDeleted;
986:               				}
987:               			#endif
988:               
989:               			else
990:               			{
991:               				/* If the task is not in any other state, it must be in the
992:               				Ready (including pending ready) state. */
993:               				eReturn = eReady;
994:               			}
995:               		}
996:               
997:               		return eReturn;
998:               	}
999:               
1000:              #endif /* INCLUDE_eTaskGetState */
1001:              /*-----------------------------------------------------------*/
1002:              
1003:              #if ( INCLUDE_uxTaskPriorityGet == 1 )
1004:              
1005:              	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
1006:              	{
00163E  FA0006     LNK #0x6
001640  980720     MOV W0, [W14+4]
1007:              	TCB_t *pxTCB;
1008:              	UBaseType_t uxReturn;
1009:              
1010:              		taskENTER_CRITICAL();
001642  02497A     CALL vPortEnterCritical
001644  000000     NOP
1011:              		{
1012:              			/* If null is passed in here then we are changing the
1013:              			priority of the calling function. */
1014:              			pxTCB = prvGetTCBFromHandle( xTask );
001646  90022E     MOV [W14+4], W4
001648  520FE0     SUB W4, #0x0, [W15]
00164A  3A0002     BRA NZ, 0x1650
00164C  82FA14     MOV pxCurrentTCB, W4
00164E  370001     BRA 0x1652
001650  90022E     MOV [W14+4], W4
001652  780F04     MOV W4, [W14]
1015:              			uxReturn = pxTCB->uxPriority;
001654  78021E     MOV [W14], W4
001656  900AB4     MOV [W4+22], W5
001658  980715     MOV W5, [W14+2]
1016:              		}
1017:              		taskEXIT_CRITICAL();
00165A  02498E     CALL vPortExitCritical
00165C  000000     NOP
1018:              
1019:              		return uxReturn;
00165E  90021E     MOV [W14+2], W4
1020:              	}
001660  780004     MOV W4, W0
001662  FA8000     ULNK
001664  060000     RETURN
1021:              
1022:              #endif /* INCLUDE_uxTaskPriorityGet */
1023:              /*-----------------------------------------------------------*/
1024:              
1025:              #if ( INCLUDE_vTaskPrioritySet == 1 )
1026:              
1027:              	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
1028:              	{
001666  FA000C     LNK #0xC
001668  980740     MOV W0, [W14+8]
00166A  980751     MOV W1, [W14+10]
1029:              	TCB_t *pxTCB;
1030:              	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
1031:              	BaseType_t xYieldRequired = pdFALSE;
00166C  EB0200     CLR W4
00166E  780F04     MOV W4, [W14]
1032:              
1033:              		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
1034:              
1035:              		/* Ensure the new priority is valid. */
1036:              		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
001670  90025E     MOV [W14+10], W4
001672  520FE4     SUB W4, #0x4, [W15]
001674  360002     BRA LEU, 0x167A
1037:              		{
1038:              			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
001676  200044     MOV #0x4, W4
001678  980754     MOV W4, [W14+10]
1039:              		}
1040:              		else
1041:              		{
1042:              			mtCOVERAGE_TEST_MARKER();
1043:              		}
1044:              
1045:              		taskENTER_CRITICAL();
00167A  02497A     CALL vPortEnterCritical
00167C  000000     NOP
1046:              		{
1047:              			/* If null is passed in here then it is the priority of the calling
1048:              			task that is being changed. */
1049:              			pxTCB = prvGetTCBFromHandle( xTask );
00167E  90024E     MOV [W14+8], W4
001680  520FE0     SUB W4, #0x0, [W15]
001682  3A0002     BRA NZ, 0x1688
001684  82FA14     MOV pxCurrentTCB, W4
001686  370001     BRA 0x168A
001688  90024E     MOV [W14+8], W4
00168A  980714     MOV W4, [W14+2]
1050:              
1051:              			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
1052:              
1053:              			#if ( configUSE_MUTEXES == 1 )
1054:              			{
1055:              				uxCurrentBasePriority = pxTCB->uxBasePriority;
00168C  90021E     MOV [W14+2], W4
00168E  9012C4     MOV [W4+40], W5
001690  980725     MOV W5, [W14+4]
1056:              			}
1057:              			#else
1058:              			{
1059:              				uxCurrentBasePriority = pxTCB->uxPriority;
1060:              			}
1061:              			#endif
1062:              
1063:              			if( uxCurrentBasePriority != uxNewPriority )
001692  9002AE     MOV [W14+4], W5
001694  90025E     MOV [W14+10], W4
001696  528F84     SUB W5, W4, [W15]
001698  320053     BRA Z, 0x1740
1064:              			{
1065:              				/* The priority change may have readied a task of higher
1066:              				priority than the calling task. */
1067:              				if( uxNewPriority > uxCurrentBasePriority )
00169A  9002DE     MOV [W14+10], W5
00169C  90022E     MOV [W14+4], W4
00169E  528F84     SUB W5, W4, [W15]
0016A0  36000C     BRA LEU, 0x16BA
1068:              				{
1069:              					if( pxTCB != pxCurrentTCB )
0016A2  82FA14     MOV pxCurrentTCB, W4
0016A4  90029E     MOV [W14+2], W5
0016A6  528F84     SUB W5, W4, [W15]
0016A8  32000E     BRA Z, 0x16C6
1070:              					{
1071:              						/* The priority of a task other than the currently
1072:              						running task is being raised.  Is the priority being
1073:              						raised above that of the running task? */
1074:              						if( uxNewPriority >= pxCurrentTCB->uxPriority )
0016AA  82FA14     MOV pxCurrentTCB, W4
0016AC  900AB4     MOV [W4+22], W5
0016AE  90025E     MOV [W14+10], W4
0016B0  528F84     SUB W5, W4, [W15]
0016B2  3E0009     BRA GTU, 0x16C6
1075:              						{
1076:              							xYieldRequired = pdTRUE;
0016B4  200014     MOV #0x1, W4
0016B6  780F04     MOV W4, [W14]
0016B8  370006     BRA 0x16C6
1077:              						}
1078:              						else
1079:              						{
1080:              							mtCOVERAGE_TEST_MARKER();
1081:              						}
1082:              					}
1083:              					else
1084:              					{
1085:              						/* The priority of the running task is being raised,
1086:              						but the running task must already be the highest
1087:              						priority task able to run so no yield is required. */
1088:              					}
1089:              				}
1090:              				else if( pxTCB == pxCurrentTCB )
0016BA  82FA14     MOV pxCurrentTCB, W4
0016BC  90029E     MOV [W14+2], W5
0016BE  528F84     SUB W5, W4, [W15]
0016C0  3A0002     BRA NZ, 0x16C6
1091:              				{
1092:              					/* Setting the priority of the running task down means
1093:              					there may now be another task of higher priority that
1094:              					is ready to execute. */
1095:              					xYieldRequired = pdTRUE;
0016C2  200014     MOV #0x1, W4
0016C4  780F04     MOV W4, [W14]
1096:              				}
1097:              				else
1098:              				{
1099:              					/* Setting the priority of any other task down does not
1100:              					require a yield as the running task must be above the
1101:              					new priority of the task being modified. */
1102:              				}
1103:              
1104:              				/* Remember the ready list the task might be referenced from
1105:              				before its uxPriority member is changed so the
1106:              				taskRESET_READY_PRIORITY() macro can function correctly. */
1107:              				uxPriorityUsedOnEntry = pxTCB->uxPriority;
0016C6  90021E     MOV [W14+2], W4
0016C8  900AB4     MOV [W4+22], W5
0016CA  980735     MOV W5, [W14+6]
1108:              
1109:              				#if ( configUSE_MUTEXES == 1 )
1110:              				{
1111:              					/* Only change the priority being used if the task is not
1112:              					currently using an inherited priority. */
1113:              					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
0016CC  90021E     MOV [W14+2], W4
0016CE  9012C4     MOV [W4+40], W5
0016D0  90021E     MOV [W14+2], W4
0016D2  900A34     MOV [W4+22], W4
0016D4  528F84     SUB W5, W4, [W15]
0016D6  3A0003     BRA NZ, 0x16DE
1114:              					{
1115:              						pxTCB->uxPriority = uxNewPriority;
0016D8  90021E     MOV [W14+2], W4
0016DA  9002DE     MOV [W14+10], W5
0016DC  980A35     MOV W5, [W4+22]
1116:              					}
1117:              					else
1118:              					{
1119:              						mtCOVERAGE_TEST_MARKER();
1120:              					}
1121:              
1122:              					/* The base priority gets set whatever. */
1123:              					pxTCB->uxBasePriority = uxNewPriority;
0016DE  90021E     MOV [W14+2], W4
0016E0  9002DE     MOV [W14+10], W5
0016E2  981245     MOV W5, [W4+40]
1124:              				}
1125:              				#else
1126:              				{
1127:              					pxTCB->uxPriority = uxNewPriority;
1128:              				}
1129:              				#endif
1130:              
1131:              				/* Only reset the event list item value if the value is not
1132:              				being used for anything else. */
1133:              				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
0016E4  90021E     MOV [W14+2], W4
0016E6  900264     MOV [W4+12], W4
0016E8  520FE0     SUB W4, #0x0, [W15]
0016EA  350004     BRA LT, 0x16F4
1134:              				{
1135:              					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0016EC  90025E     MOV [W14+10], W4
0016EE  1202E5     SUBR W4, #0x5, W5
0016F0  90021E     MOV [W14+2], W4
0016F2  980265     MOV W5, [W4+12]
1136:              				}
1137:              				else
1138:              				{
1139:              					mtCOVERAGE_TEST_MARKER();
1140:              				}
1141:              
1142:              				/* If the task is in the blocked or suspended list we need do
1143:              				nothing more than change it's priority variable. However, if
1144:              				the task is in a ready list it needs to be removed and placed
1145:              				in the list appropriate to its new priority. */
1146:              				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
0016F4  90021E     MOV [W14+2], W4
0016F6  9002D4     MOV [W4+10], W5
0016F8  90023E     MOV [W14+6], W4
0016FA  B923EA     MUL.SU W4, #10, W6
0016FC  25F444     MOV #0x5F44, W4
0016FE  430204     ADD W6, W4, W4
001700  528F84     SUB W5, W4, [W15]
001702  3A0018     BRA NZ, 0x1734
1147:              				{
1148:              					/* The task is currently in its ready list - remove before adding
1149:              					it to it's new ready list.  As we are in a critical section we
1150:              					can do this even if the scheduler is suspended. */
1151:              					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
001704  90021E     MOV [W14+2], W4
001706  E88204     INC2 W4, W4
001708  780004     MOV W4, W0
00170A  024C0E     CALL uxListRemove
00170C  000000     NOP
1152:              					{
1153:              						/* It is known that the task is in its ready list so
1154:              						there is no need to check again and the port level
1155:              						reset macro can be called directly. */
1156:              						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
1157:              					}
1158:              					else
1159:              					{
1160:              						mtCOVERAGE_TEST_MARKER();
1161:              					}
1162:              					prvAddTaskToReadyList( pxTCB );
00170E  90021E     MOV [W14+2], W4
001710  900AB4     MOV [W4+22], W5
001712  82FD94     MOV uxTopReadyPriority, W4
001714  528F84     SUB W5, W4, [W15]
001716  360003     BRA LEU, 0x171E
001718  90021E     MOV [W14+2], W4
00171A  900A34     MOV [W4+22], W4
00171C  8AFD94     MOV W4, uxTopReadyPriority
00171E  90021E     MOV [W14+2], W4
001720  E88284     INC2 W4, W5
001722  90021E     MOV [W14+2], W4
001724  900A34     MOV [W4+22], W4
001726  B923EA     MUL.SU W4, #10, W6
001728  25F444     MOV #0x5F44, W4
00172A  430204     ADD W6, W4, W4
00172C  780085     MOV W5, W1
00172E  780004     MOV W4, W0
001730  024B6E     CALL vListInsertEnd
001732  000000     NOP
1163:              				}
1164:              				else
1165:              				{
1166:              					mtCOVERAGE_TEST_MARKER();
1167:              				}
1168:              
1169:              				if( xYieldRequired == pdTRUE )
001734  78021E     MOV [W14], W4
001736  520FE1     SUB W4, #0x1, [W15]
001738  3A0003     BRA NZ, 0x1740
1170:              				{
1171:              					taskYIELD_IF_USING_PREEMPTION();
00173A  024F06     CALL _vPortYield
00173C  000000     NOP
00173E  000000     NOP
1172:              				}
1173:              				else
1174:              				{
1175:              					mtCOVERAGE_TEST_MARKER();
1176:              				}
1177:              
1178:              				/* Remove compiler warning about unused variables when the port
1179:              				optimised task selection is not being used. */
1180:              				( void ) uxPriorityUsedOnEntry;
1181:              			}
1182:              		}
1183:              		taskEXIT_CRITICAL();
001740  02498E     CALL vPortExitCritical
001742  000000     NOP
1184:              	}
001744  FA8000     ULNK
001746  060000     RETURN
1185:              
1186:              #endif /* INCLUDE_vTaskPrioritySet */
1187:              /*-----------------------------------------------------------*/
1188:              
1189:              #if ( INCLUDE_vTaskSuspend == 1 )
1190:              
1191:              	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
1192:              	{
001748  FA0004     LNK #0x4
00174A  980710     MOV W0, [W14+2]
1193:              	TCB_t *pxTCB;
1194:              
1195:              		taskENTER_CRITICAL();
00174C  02497A     CALL vPortEnterCritical
00174E  000000     NOP
1196:              		{
1197:              			/* If null is passed in here then it is the running task that is
1198:              			being suspended. */
1199:              			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
001750  90021E     MOV [W14+2], W4
001752  520FE0     SUB W4, #0x0, [W15]
001754  3A0002     BRA NZ, 0x175A
001756  82FA14     MOV pxCurrentTCB, W4
001758  370001     BRA 0x175C
00175A  90021E     MOV [W14+2], W4
00175C  780F04     MOV W4, [W14]
1200:              
1201:              			traceTASK_SUSPEND( pxTCB );
1202:              
1203:              			/* Remove task from the ready/delayed list and place in the
1204:              			suspended list. */
1205:              			if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
00175E  E8821E     INC2 [W14], W4
001760  780004     MOV W4, W0
001762  024C0E     CALL uxListRemove
001764  000000     NOP
1206:              			{
1207:              				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
1208:              			}
1209:              			else
1210:              			{
1211:              				mtCOVERAGE_TEST_MARKER();
1212:              			}
1213:              
1214:              			/* Is the task waiting on an event also? */
1215:              			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
001766  78021E     MOV [W14], W4
001768  900A24     MOV [W4+20], W4
00176A  520FE0     SUB W4, #0x0, [W15]
00176C  320005     BRA Z, 0x1778
1216:              			{
1217:              				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00176E  78029E     MOV [W14], W5
001770  42826C     ADD W5, #0xC, W4
001772  780004     MOV W4, W0
001774  024C0E     CALL uxListRemove
001776  000000     NOP
1218:              			}
1219:              			else
1220:              			{
1221:              				mtCOVERAGE_TEST_MARKER();
1222:              			}
1223:              
1224:              			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
001778  E8821E     INC2 [W14], W4
00177A  780084     MOV W4, W1
00177C  25FA40     MOV #0x5FA4, W0
00177E  024B6E     CALL vListInsertEnd
001780  000000     NOP
1225:              		}
1226:              		taskEXIT_CRITICAL();
001782  02498E     CALL vPortExitCritical
001784  000000     NOP
1227:              
1228:              		if( pxTCB == pxCurrentTCB )
001786  82FA14     MOV pxCurrentTCB, W4
001788  78029E     MOV [W14], W5
00178A  528F84     SUB W5, W4, [W15]
00178C  3A0010     BRA NZ, 0x17AE
1229:              		{
1230:              			if( xSchedulerRunning != pdFALSE )
00178E  82FDA4     MOV xSchedulerRunning, W4
001790  520FE0     SUB W4, #0x0, [W15]
001792  320004     BRA Z, 0x179C
1231:              			{
1232:              				/* The current task has just been suspended. */
1233:              				configASSERT( uxSchedulerSuspended == 0 );
1234:              				portYIELD_WITHIN_API();
001794  024F06     CALL _vPortYield
001796  000000     NOP
001798  000000     NOP
00179A  37000D     BRA 0x17B6
1235:              			}
1236:              			else
1237:              			{
1238:              				/* The scheduler is not running, but the task that was pointed
1239:              				to by pxCurrentTCB has just been suspended and pxCurrentTCB
1240:              				must be adjusted to point to a different task. */
1241:              				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
00179C  82FD25     MOV xSuspendedTaskList, W5
00179E  82FD74     MOV uxCurrentNumberOfTasks, W4
0017A0  528F84     SUB W5, W4, [W15]
0017A2  3A0003     BRA NZ, 0x17AA
1242:              				{
1243:              					/* No other tasks are ready, so set pxCurrentTCB back to
1244:              					NULL so when the next task is created pxCurrentTCB will
1245:              					be set to point to it no matter what its relative priority
1246:              					is. */
1247:              					pxCurrentTCB = NULL;
0017A4  EB0200     CLR W4
0017A6  8AFA14     MOV W4, pxCurrentTCB
0017A8  370006     BRA 0x17B6
1248:              				}
1249:              				else
1250:              				{
1251:              					vTaskSwitchContext();
0017AA  070206     RCALL vTaskSwitchContext
0017AC  370004     BRA 0x17B6
1252:              				}
1253:              			}
1254:              		}
1255:              		else
1256:              		{
1257:              			if( xSchedulerRunning != pdFALSE )
0017AE  82FDA4     MOV xSchedulerRunning, W4
0017B0  520FE0     SUB W4, #0x0, [W15]
0017B2  320001     BRA Z, 0x17B6
1258:              			{
1259:              				/* A task other than the currently running task was suspended,
1260:              				reset the next expected unblock time in case it referred to the
1261:              				task that is now in the Suspended state. */
1262:              				prvResetNextTaskUnblockTime();
0017B4  07050E     RCALL prvResetNextTaskUnblockTime
1263:              			}
1264:              			else
1265:              			{
1266:              				mtCOVERAGE_TEST_MARKER();
1267:              			}
1268:              		}
1269:              	}
0017B6  FA8000     ULNK
0017B8  060000     RETURN
1270:              
1271:              #endif /* INCLUDE_vTaskSuspend */
1272:              /*-----------------------------------------------------------*/
1273:              
1274:              #if ( INCLUDE_vTaskSuspend == 1 )
1275:              
1276:              	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
1277:              	{
0017BA  FA0006     LNK #0x6
0017BC  980720     MOV W0, [W14+4]
1278:              	BaseType_t xReturn = pdFALSE;
0017BE  EB0200     CLR W4
0017C0  780F04     MOV W4, [W14]
1279:              	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
0017C2  90022E     MOV [W14+4], W4
0017C4  980714     MOV W4, [W14+2]
1280:              
1281:              		/* Accesses xPendingReadyList so must be called from a critical
1282:              		section. */
1283:              
1284:              		/* It does not make sense to check if the calling task is suspended. */
1285:              		configASSERT( xTask );
1286:              
1287:              		/* Is the task being resumed actually in the suspended list? */
1288:              		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
0017C6  90021E     MOV [W14+2], W4
0017C8  9002D4     MOV [W4+10], W5
0017CA  25FA44     MOV #0x5FA4, W4
0017CC  528F84     SUB W5, W4, [W15]
0017CE  3A000B     BRA NZ, 0x17E6
1289:              		{
1290:              			/* Has the task already been resumed from within an ISR? */
1291:              			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
0017D0  90021E     MOV [W14+2], W4
0017D2  900AA4     MOV [W4+20], W5
0017D4  25F8E4     MOV #0x5F8E, W4
0017D6  528F84     SUB W5, W4, [W15]
0017D8  320006     BRA Z, 0x17E6
1292:              			{
1293:              				/* Is it in the suspended list because it is in the	Suspended
1294:              				state, or because is is blocked with no timeout? */
1295:              				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
0017DA  90021E     MOV [W14+2], W4
0017DC  900A24     MOV [W4+20], W4
0017DE  520FE0     SUB W4, #0x0, [W15]
0017E0  3A0002     BRA NZ, 0x17E6
1296:              				{
1297:              					xReturn = pdTRUE;
0017E2  200014     MOV #0x1, W4
0017E4  780F04     MOV W4, [W14]
1298:              				}
1299:              				else
1300:              				{
1301:              					mtCOVERAGE_TEST_MARKER();
1302:              				}
1303:              			}
1304:              			else
1305:              			{
1306:              				mtCOVERAGE_TEST_MARKER();
1307:              			}
1308:              		}
1309:              		else
1310:              		{
1311:              			mtCOVERAGE_TEST_MARKER();
1312:              		}
1313:              
1314:              		return xReturn;
0017E6  78021E     MOV [W14], W4
1315:              	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
0017E8  780004     MOV W4, W0
0017EA  FA8000     ULNK
0017EC  060000     RETURN
1316:              
1317:              #endif /* INCLUDE_vTaskSuspend */
1318:              /*-----------------------------------------------------------*/
1319:              
1320:              #if ( INCLUDE_vTaskSuspend == 1 )
1321:              
1322:              	void vTaskResume( TaskHandle_t xTaskToResume )
1323:              	{
0017EE  FA0004     LNK #0x4
0017F0  980710     MOV W0, [W14+2]
1324:              	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
0017F2  90021E     MOV [W14+2], W4
0017F4  780F04     MOV W4, [W14]
1325:              
1326:              		/* It does not make sense to resume the calling task. */
1327:              		configASSERT( xTaskToResume );
1328:              
1329:              		/* The parameter cannot be NULL as it is impossible to resume the
1330:              		currently executing task. */
1331:              		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
0017F6  78021E     MOV [W14], W4
0017F8  520FE0     SUB W4, #0x0, [W15]
0017FA  32002C     BRA Z, 0x1854
0017FC  82FA14     MOV pxCurrentTCB, W4
0017FE  78029E     MOV [W14], W5
001800  528F84     SUB W5, W4, [W15]
001802  320028     BRA Z, 0x1854
1332:              		{
1333:              			taskENTER_CRITICAL();
001804  02497A     CALL vPortEnterCritical
001806  000000     NOP
1334:              			{
1335:              				if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
001808  78001E     MOV [W14], W0
00180A  07FFD7     RCALL prvTaskIsTaskSuspended
00180C  780200     MOV W0, W4
00180E  520FE1     SUB W4, #0x1, [W15]
001810  3A001F     BRA NZ, 0x1850
1336:              				{
1337:              					traceTASK_RESUME( pxTCB );
1338:              
1339:              					/* As we are in a critical section we can access the ready
1340:              					lists even if the scheduler is suspended. */
1341:              					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
001812  E8821E     INC2 [W14], W4
001814  780004     MOV W4, W0
001816  024C0E     CALL uxListRemove
001818  000000     NOP
1342:              					prvAddTaskToReadyList( pxTCB );
00181A  78021E     MOV [W14], W4
00181C  900AB4     MOV [W4+22], W5
00181E  82FD94     MOV uxTopReadyPriority, W4
001820  528F84     SUB W5, W4, [W15]
001822  360003     BRA LEU, 0x182A
001824  78021E     MOV [W14], W4
001826  900A34     MOV [W4+22], W4
001828  8AFD94     MOV W4, uxTopReadyPriority
00182A  E8829E     INC2 [W14], W5
00182C  78021E     MOV [W14], W4
00182E  900A34     MOV [W4+22], W4
001830  B923EA     MUL.SU W4, #10, W6
001832  25F444     MOV #0x5F44, W4
001834  430204     ADD W6, W4, W4
001836  780085     MOV W5, W1
001838  780004     MOV W4, W0
00183A  024B6E     CALL vListInsertEnd
00183C  000000     NOP
1343:              
1344:              					/* We may have just resumed a higher priority task. */
1345:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00183E  78021E     MOV [W14], W4
001840  900AB4     MOV [W4+22], W5
001842  82FA14     MOV pxCurrentTCB, W4
001844  900A34     MOV [W4+22], W4
001846  528F84     SUB W5, W4, [W15]
001848  390003     BRA NC, 0x1850
1346:              					{
1347:              						/* This yield may not cause the task just resumed to run,
1348:              						but will leave the lists in the correct state for the
1349:              						next yield. */
1350:              						taskYIELD_IF_USING_PREEMPTION();
00184A  024F06     CALL _vPortYield
00184C  000000     NOP
00184E  000000     NOP
1351:              					}
1352:              					else
1353:              					{
1354:              						mtCOVERAGE_TEST_MARKER();
1355:              					}
1356:              				}
1357:              				else
1358:              				{
1359:              					mtCOVERAGE_TEST_MARKER();
1360:              				}
1361:              			}
1362:              			taskEXIT_CRITICAL();
001850  02498E     CALL vPortExitCritical
001852  000000     NOP
1363:              		}
1364:              		else
1365:              		{
1366:              			mtCOVERAGE_TEST_MARKER();
1367:              		}
1368:              	}
001854  FA8000     ULNK
001856  060000     RETURN
1369:              
1370:              #endif /* INCLUDE_vTaskSuspend */
1371:              
1372:              /*-----------------------------------------------------------*/
1373:              
1374:              #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1375:              
1376:              	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
1377:              	{
001858  FA0008     LNK #0x8
00185A  980730     MOV W0, [W14+6]
1378:              	BaseType_t xYieldRequired = pdFALSE;
00185C  EB0200     CLR W4
00185E  780F04     MOV W4, [W14]
1379:              	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
001860  90023E     MOV [W14+6], W4
001862  980714     MOV W4, [W14+2]
1380:              	UBaseType_t uxSavedInterruptStatus;
1381:              
1382:              		configASSERT( xTaskToResume );
1383:              
1384:              		/* RTOS ports that support interrupt nesting have the concept of a
1385:              		maximum	system call (or maximum API call) interrupt priority.
1386:              		Interrupts that are	above the maximum system call priority are keep
1387:              		permanently enabled, even when the RTOS kernel is in a critical section,
1388:              		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
1389:              		is defined in FreeRTOSConfig.h then
1390:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1391:              		failure if a FreeRTOS API function is called from an interrupt that has
1392:              		been assigned a priority above the configured maximum system call
1393:              		priority.  Only FreeRTOS functions that end in FromISR can be called
1394:              		from interrupts	that have been assigned a priority at or (logically)
1395:              		below the maximum system call interrupt priority.  FreeRTOS maintains a
1396:              		separate interrupt safe API to ensure interrupt entry is as fast and as
1397:              		simple as possible.  More information (albeit Cortex-M specific) is
1398:              		provided on the following link:
1399:              		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1400:              		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1401:              
1402:              		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
001864  EB0200     CLR W4
001866  980724     MOV W4, [W14+4]
1403:              		{
1404:              			if( prvTaskIsTaskSuspended( pxTCB ) == pdTRUE )
001868  90001E     MOV [W14+2], W0
00186A  07FFA7     RCALL prvTaskIsTaskSuspended
00186C  780200     MOV W0, W4
00186E  520FE1     SUB W4, #0x1, [W15]
001870  3A002A     BRA NZ, 0x18C6
1405:              			{
1406:              				traceTASK_RESUME_FROM_ISR( pxTCB );
1407:              
1408:              				/* Check the ready lists can be accessed. */
1409:              				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001872  82FDF4     MOV uxSchedulerSuspended, W4
001874  520FE0     SUB W4, #0x0, [W15]
001876  3A0021     BRA NZ, 0x18BA
1410:              				{
1411:              					/* Ready lists can be accessed so move the task from the
1412:              					suspended list to the ready list directly. */
1413:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
001878  90021E     MOV [W14+2], W4
00187A  900AB4     MOV [W4+22], W5
00187C  82FA14     MOV pxCurrentTCB, W4
00187E  900A34     MOV [W4+22], W4
001880  528F84     SUB W5, W4, [W15]
001882  390002     BRA NC, 0x1888
1414:              					{
1415:              						xYieldRequired = pdTRUE;
001884  200014     MOV #0x1, W4
001886  780F04     MOV W4, [W14]
1416:              					}
1417:              					else
1418:              					{
1419:              						mtCOVERAGE_TEST_MARKER();
1420:              					}
1421:              
1422:              					( void ) uxListRemove(  &( pxTCB->xGenericListItem ) );
001888  90021E     MOV [W14+2], W4
00188A  E88204     INC2 W4, W4
00188C  780004     MOV W4, W0
00188E  024C0E     CALL uxListRemove
001890  000000     NOP
1423:              					prvAddTaskToReadyList( pxTCB );
001892  90021E     MOV [W14+2], W4
001894  900AB4     MOV [W4+22], W5
001896  82FD94     MOV uxTopReadyPriority, W4
001898  528F84     SUB W5, W4, [W15]
00189A  360003     BRA LEU, 0x18A2
00189C  90021E     MOV [W14+2], W4
00189E  900A34     MOV [W4+22], W4
0018A0  8AFD94     MOV W4, uxTopReadyPriority
0018A2  90021E     MOV [W14+2], W4
0018A4  E88284     INC2 W4, W5
0018A6  90021E     MOV [W14+2], W4
0018A8  900A34     MOV [W4+22], W4
0018AA  B923EA     MUL.SU W4, #10, W6
0018AC  25F444     MOV #0x5F44, W4
0018AE  430204     ADD W6, W4, W4
0018B0  780085     MOV W5, W1
0018B2  780004     MOV W4, W0
0018B4  024B6E     CALL vListInsertEnd
0018B6  000000     NOP
0018B8  370006     BRA 0x18C6
1424:              				}
1425:              				else
1426:              				{
1427:              					/* The delayed or ready lists cannot be accessed so the task
1428:              					is held in the pending ready list until the scheduler is
1429:              					unsuspended. */
1430:              					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0018BA  90021E     MOV [W14+2], W4
0018BC  42026C     ADD W4, #0xC, W4
0018BE  780084     MOV W4, W1
0018C0  25F8E0     MOV #0x5F8E, W0
0018C2  024B6E     CALL vListInsertEnd
0018C4  000000     NOP
1431:              				}
1432:              			}
1433:              			else
1434:              			{
1435:              				mtCOVERAGE_TEST_MARKER();
1436:              			}
1437:              		}
1438:              		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1439:              
1440:              		return xYieldRequired;
0018C6  78021E     MOV [W14], W4
1441:              	}
0018C8  780004     MOV W4, W0
0018CA  FA8000     ULNK
0018CC  060000     RETURN
1442:              
1443:              #endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
1444:              /*-----------------------------------------------------------*/
1445:              
1446:              void vTaskStartScheduler( void )
1447:              {
0018CE  FA0002     LNK #0x2
1448:              BaseType_t xReturn;
1449:              
1450:              	/* Add the idle task at the lowest priority. */
1451:              	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1452:              	{
1453:              		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
1454:              		be returned by the xTaskGetIdleTaskHandle() function. */
1455:              		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
1456:              	}
1457:              	#else
1458:              	{
1459:              		/* Create the idle task without storing its handle. */
1460:              		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
0018D0  EB0380     CLR W7
0018D2  EB0300     CLR W6
0018D4  EB0280     CLR W5
0018D6  EB0200     CLR W4
0018D8  EB0180     CLR W3
0018DA  200642     MOV #0x64, W2
0018DC  293E21     MOV #0x93E2, W1
0018DE  21E840     MOV #0x1E84, W0
0018E0  07FDA0     RCALL xTaskGenericCreate
0018E2  780200     MOV W0, W4
0018E4  780F04     MOV W4, [W14]
1461:              	}
1462:              	#endif /* INCLUDE_xTaskGetIdleTaskHandle */
1463:              
1464:              	#if ( configUSE_TIMERS == 1 )
1465:              	{
1466:              		if( xReturn == pdPASS )
0018E6  78021E     MOV [W14], W4
0018E8  520FE1     SUB W4, #0x1, [W15]
0018EA  3A0004     BRA NZ, 0x18F4
1467:              		{
1468:              			xReturn = xTimerCreateTimerTask();
0018EC  0231D2     CALL xTimerCreateTimerTask
0018EE  000000     NOP
0018F0  780200     MOV W0, W4
0018F2  780F04     MOV W4, [W14]
1469:              		}
1470:              		else
1471:              		{
1472:              			mtCOVERAGE_TEST_MARKER();
1473:              		}
1474:              	}
1475:              	#endif /* configUSE_TIMERS */
1476:              
1477:              	if( xReturn == pdPASS )
0018F4  78021E     MOV [W14], W4
0018F6  520FE1     SUB W4, #0x1, [W15]
0018F8  3A000A     BRA NZ, 0x190E
1478:              	{
1479:              		/* Interrupts are turned off here, to ensure a tick does not occur
1480:              		before or during the call to xPortStartScheduler().  The stacks of
1481:              		the created tasks contain a status word with interrupts switched on
1482:              		so interrupts will automatically get re-enabled when the first task
1483:              		starts to run. */
1484:              		portDISABLE_INTERRUPTS();
0018FA  800215     MOV SR, W5
0018FC  200204     MOV #0x20, W4
0018FE  720205     IOR W4, W5, W4
001900  880214     MOV W4, SR
1485:              
1486:              		#if ( configUSE_NEWLIB_REENTRANT == 1 )
1487:              		{
1488:              			/* Switch Newlib's _impure_ptr variable to point to the _reent
1489:              			structure specific to the task that will run first. */
1490:              			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
1491:              		}
1492:              		#endif /* configUSE_NEWLIB_REENTRANT */
1493:              
1494:              		xSchedulerRunning = pdTRUE;
001902  200014     MOV #0x1, W4
001904  8AFDA4     MOV W4, xSchedulerRunning
1495:              		xTickCount = ( TickType_t ) 0U;
001906  EB0200     CLR W4
001908  8AFD84     MOV W4, xTickCount
1496:              
1497:              		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1498:              		macro must be defined to configure the timer/counter used to generate
1499:              		the run time counter time base. */
1500:              		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1501:              
1502:              		/* Setting up the timer tick is hardware specific and thus in the
1503:              		portable interface. */
1504:              		if( xPortStartScheduler() != pdFALSE )
00190A  024914     CALL xPortStartScheduler
00190C  000000     NOP
1505:              		{
1506:              			/* Should not reach here as if the scheduler is running the
1507:              			function will not return. */
1508:              		}
1509:              		else
1510:              		{
1511:              			/* Should only reach here if a task calls xTaskEndScheduler(). */
1512:              		}
1513:              	}
1514:              	else
1515:              	{
1516:              		/* This line will only be reached if the kernel could not be started,
1517:              		because there was not enough FreeRTOS heap to create the idle task
1518:              		or the timer task. */
1519:              		configASSERT( xReturn );
1520:              	}
1521:              }
00190E  FA8000     ULNK
001910  060000     RETURN
1522:              /*-----------------------------------------------------------*/
1523:              
1524:              void vTaskEndScheduler( void )
1525:              {
001912  FA0000     LNK #0x0
1526:              	/* Stop the scheduler interrupts and call the portable scheduler end
1527:              	routine so the original ISRs can be restored if necessary.  The port
1528:              	layer must ensure interrupts enable	bit is left in the correct state. */
1529:              	portDISABLE_INTERRUPTS();
001914  800215     MOV SR, W5
001916  200204     MOV #0x20, W4
001918  720205     IOR W4, W5, W4
00191A  880214     MOV W4, SR
1530:              	xSchedulerRunning = pdFALSE;
00191C  EB0200     CLR W4
00191E  8AFDA4     MOV W4, xSchedulerRunning
1531:              	vPortEndScheduler();
001920  024948     CALL vPortEndScheduler
001922  000000     NOP
1532:              }
001924  FA8000     ULNK
001926  060000     RETURN
1533:              /*----------------------------------------------------------*/
1534:              
1535:              void vTaskSuspendAll( void )
1536:              {
001928  FA0000     LNK #0x0
1537:              	/* A critical section is not required as the variable is of type
1538:              	BaseType_t.  Please read Richard Barry's reply in the following link to a
1539:              	post in the FreeRTOS support forum before reporting this as a bug! -
1540:              	http://goo.gl/wu4acr */
1541:              	++uxSchedulerSuspended;
00192A  82FDF4     MOV uxSchedulerSuspended, W4
00192C  E80204     INC W4, W4
00192E  8AFDF4     MOV W4, uxSchedulerSuspended
1542:              }
001930  FA8000     ULNK
001932  060000     RETURN
1543:              /*----------------------------------------------------------*/
1544:              
1545:              #if ( configUSE_TICKLESS_IDLE != 0 )
1546:              
1547:              	static TickType_t prvGetExpectedIdleTime( void )
1548:              	{
1549:              	TickType_t xReturn;
1550:              
1551:              		if( pxCurrentTCB->uxPriority > tskIDLE_PRIORITY )
1552:              		{
1553:              			xReturn = 0;
1554:              		}
1555:              		else if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > 1 )
1556:              		{
1557:              			/* There are other idle priority tasks in the ready state.  If
1558:              			time slicing is used then the very next tick interrupt must be
1559:              			processed. */
1560:              			xReturn = 0;
1561:              		}
1562:              		else
1563:              		{
1564:              			xReturn = xNextTaskUnblockTime - xTickCount;
1565:              		}
1566:              
1567:              		return xReturn;
1568:              	}
1569:              
1570:              #endif /* configUSE_TICKLESS_IDLE */
1571:              /*----------------------------------------------------------*/
1572:              
1573:              BaseType_t xTaskResumeAll( void )
1574:              {
001934  FA0004     LNK #0x4
1575:              TCB_t *pxTCB;
1576:              BaseType_t xAlreadyYielded = pdFALSE;
001936  EB0200     CLR W4
001938  780F04     MOV W4, [W14]
1577:              
1578:              	/* If uxSchedulerSuspended is zero then this function does not match a
1579:              	previous call to vTaskSuspendAll(). */
1580:              	configASSERT( uxSchedulerSuspended );
1581:              
1582:              	/* It is possible that an ISR caused a task to be removed from an event
1583:              	list while the scheduler was suspended.  If this was the case then the
1584:              	removed task will have been added to the xPendingReadyList.  Once the
1585:              	scheduler has been resumed it is safe to move all the pending ready
1586:              	tasks from this list into their appropriate ready list. */
1587:              	taskENTER_CRITICAL();
00193A  02497A     CALL vPortEnterCritical
00193C  000000     NOP
1588:              	{
1589:              		--uxSchedulerSuspended;
00193E  82FDF4     MOV uxSchedulerSuspended, W4
001940  E90204     DEC W4, W4
001942  8AFDF4     MOV W4, uxSchedulerSuspended
1590:              
1591:              		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001944  82FDF4     MOV uxSchedulerSuspended, W4
001946  520FE0     SUB W4, #0x0, [W15]
001948  3A0047     BRA NZ, 0x19D8
1592:              		{
1593:              			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
00194A  82FD74     MOV uxCurrentNumberOfTasks, W4
00194C  520FE0     SUB W4, #0x0, [W15]
00194E  320044     BRA Z, 0x19D8
1594:              			{
1595:              				/* Move any readied tasks from the pending list into the
1596:              				appropriate ready list. */
1597:              				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
001950  370028     BRA 0x19A2
0019A2  82FC74     MOV xPendingReadyList, W4
0019A4  520FE0     SUB W4, #0x0, [W15]
0019A6  3AFFD5     BRA NZ, 0x1952
1598:              				{
1599:              					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
001952  82FCA4     MOV 0x5F94, W4
001954  900234     MOV [W4+6], W4
001956  980714     MOV W4, [W14+2]
1600:              					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
001958  90021E     MOV [W14+2], W4
00195A  42026C     ADD W4, #0xC, W4
00195C  780004     MOV W4, W0
00195E  024C0E     CALL uxListRemove
001960  000000     NOP
1601:              					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
001962  90021E     MOV [W14+2], W4
001964  E88204     INC2 W4, W4
001966  780004     MOV W4, W0
001968  024C0E     CALL uxListRemove
00196A  000000     NOP
1602:              					prvAddTaskToReadyList( pxTCB );
00196C  90021E     MOV [W14+2], W4
00196E  900AB4     MOV [W4+22], W5
001970  82FD94     MOV uxTopReadyPriority, W4
001972  528F84     SUB W5, W4, [W15]
001974  360003     BRA LEU, 0x197C
001976  90021E     MOV [W14+2], W4
001978  900A34     MOV [W4+22], W4
00197A  8AFD94     MOV W4, uxTopReadyPriority
00197C  90021E     MOV [W14+2], W4
00197E  E88284     INC2 W4, W5
001980  90021E     MOV [W14+2], W4
001982  900A34     MOV [W4+22], W4
001984  B923EA     MUL.SU W4, #10, W6
001986  25F444     MOV #0x5F44, W4
001988  430204     ADD W6, W4, W4
00198A  780085     MOV W5, W1
00198C  780004     MOV W4, W0
00198E  024B6E     CALL vListInsertEnd
001990  000000     NOP
1603:              
1604:              					/* If we have moved a task that has a priority higher than
1605:              					the current task then we should yield. */
1606:              					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
001992  90021E     MOV [W14+2], W4
001994  900AB4     MOV [W4+22], W5
001996  82FA14     MOV pxCurrentTCB, W4
001998  900A34     MOV [W4+22], W4
00199A  528F84     SUB W5, W4, [W15]
00199C  390002     BRA NC, 0x19A2
1607:              					{
1608:              						xYieldPending = pdTRUE;
00199E  200014     MOV #0x1, W4
0019A0  8AFDC4     MOV W4, xYieldPending
1609:              					}
1610:              					else
1611:              					{
1612:              						mtCOVERAGE_TEST_MARKER();
1613:              					}
1614:              				}
1615:              
1616:              				/* If any ticks occurred while the scheduler was suspended then
1617:              				they should be processed now.  This ensures the tick count does
1618:              				not	slip, and that any delayed tasks are resumed at the correct
1619:              				time. */
1620:              				if( uxPendedTicks > ( UBaseType_t ) 0U )
0019A8  82FDB4     MOV uxPendedTicks, W4
0019AA  520FE0     SUB W4, #0x0, [W15]
0019AC  32000D     BRA Z, 0x19C8
1621:              				{
1622:              					while( uxPendedTicks > ( UBaseType_t ) 0U )
0019AE  370009     BRA 0x19C2
0019C2  82FDB4     MOV uxPendedTicks, W4
0019C4  520FE0     SUB W4, #0x0, [W15]
0019C6  3AFFF4     BRA NZ, 0x19B0
1623:              					{
1624:              						if( xTaskIncrementTick() != pdFALSE )
0019B0  070097     RCALL xTaskIncrementTick
0019B2  780200     MOV W0, W4
0019B4  520FE0     SUB W4, #0x0, [W15]
0019B6  320002     BRA Z, 0x19BC
1625:              						{
1626:              							xYieldPending = pdTRUE;
0019B8  200014     MOV #0x1, W4
0019BA  8AFDC4     MOV W4, xYieldPending
1627:              						}
1628:              						else
1629:              						{
1630:              							mtCOVERAGE_TEST_MARKER();
1631:              						}
1632:              						--uxPendedTicks;
0019BC  82FDB4     MOV uxPendedTicks, W4
0019BE  E90204     DEC W4, W4
0019C0  8AFDB4     MOV W4, uxPendedTicks
1633:              					}
1634:              				}
1635:              				else
1636:              				{
1637:              					mtCOVERAGE_TEST_MARKER();
1638:              				}
1639:              
1640:              				if( xYieldPending == pdTRUE )
0019C8  82FDC4     MOV xYieldPending, W4
0019CA  520FE1     SUB W4, #0x1, [W15]
0019CC  3A0005     BRA NZ, 0x19D8
1641:              				{
1642:              					#if( configUSE_PREEMPTION != 0 )
1643:              					{
1644:              						xAlreadyYielded = pdTRUE;
0019CE  200014     MOV #0x1, W4
0019D0  780F04     MOV W4, [W14]
1645:              					}
1646:              					#endif
1647:              					taskYIELD_IF_USING_PREEMPTION();
0019D2  024F06     CALL _vPortYield
0019D4  000000     NOP
0019D6  000000     NOP
1648:              				}
1649:              				else
1650:              				{
1651:              					mtCOVERAGE_TEST_MARKER();
1652:              				}
1653:              			}
1654:              		}
1655:              		else
1656:              		{
1657:              			mtCOVERAGE_TEST_MARKER();
1658:              		}
1659:              	}
1660:              	taskEXIT_CRITICAL();
0019D8  02498E     CALL vPortExitCritical
0019DA  000000     NOP
1661:              
1662:              	return xAlreadyYielded;
0019DC  78021E     MOV [W14], W4
1663:              }
0019DE  780004     MOV W4, W0
0019E0  FA8000     ULNK
0019E2  060000     RETURN
1664:              /*-----------------------------------------------------------*/
1665:              
1666:              TickType_t xTaskGetTickCount( void )
1667:              {
0019E4  FA0002     LNK #0x2
1668:              TickType_t xTicks;
1669:              
1670:              	/* Critical section required if running on a 16 bit processor. */
1671:              	taskENTER_CRITICAL();
0019E6  02497A     CALL vPortEnterCritical
0019E8  000000     NOP
1672:              	{
1673:              		xTicks = xTickCount;
0019EA  82FD84     MOV xTickCount, W4
0019EC  780F04     MOV W4, [W14]
1674:              	}
1675:              	taskEXIT_CRITICAL();
0019EE  02498E     CALL vPortExitCritical
0019F0  000000     NOP
1676:              
1677:              	return xTicks;
0019F2  78021E     MOV [W14], W4
1678:              }
0019F4  780004     MOV W4, W0
0019F6  FA8000     ULNK
0019F8  060000     RETURN
1679:              /*-----------------------------------------------------------*/
1680:              
1681:              TickType_t xTaskGetTickCountFromISR( void )
1682:              {
0019FA  FA0004     LNK #0x4
1683:              TickType_t xReturn;
1684:              UBaseType_t uxSavedInterruptStatus;
1685:              
1686:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1687:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1688:              	above the maximum system call priority are kept permanently enabled, even
1689:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1690:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1691:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1692:              	failure if a FreeRTOS API function is called from an interrupt that has been
1693:              	assigned a priority above the configured maximum system call priority.
1694:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1695:              	that have been assigned a priority at or (logically) below the maximum
1696:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1697:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1698:              	More information (albeit Cortex-M specific) is provided on the following
1699:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1700:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1701:              
1702:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0019FC  EB0200     CLR W4
0019FE  780F04     MOV W4, [W14]
1703:              	{
1704:              		xReturn = xTickCount;
001A00  82FD84     MOV xTickCount, W4
001A02  980714     MOV W4, [W14+2]
1705:              	}
1706:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1707:              
1708:              	return xReturn;
001A04  90021E     MOV [W14+2], W4
1709:              }
001A06  780004     MOV W4, W0
001A08  FA8000     ULNK
001A0A  060000     RETURN
1710:              /*-----------------------------------------------------------*/
1711:              
1712:              UBaseType_t uxTaskGetNumberOfTasks( void )
1713:              {
001A0C  FA0000     LNK #0x0
1714:              	/* A critical section is not required because the variables are of type
1715:              	BaseType_t. */
1716:              	return uxCurrentNumberOfTasks;
001A0E  82FD74     MOV uxCurrentNumberOfTasks, W4
1717:              }
001A10  780004     MOV W4, W0
001A12  FA8000     ULNK
001A14  060000     RETURN
1718:              /*-----------------------------------------------------------*/
1719:              
1720:              #if ( INCLUDE_pcTaskGetTaskName == 1 )
1721:              
1722:              	char *pcTaskGetTaskName( TaskHandle_t xTaskToQuery )
1723:              	{
001A16  FA0004     LNK #0x4
001A18  980710     MOV W0, [W14+2]
1724:              	TCB_t *pxTCB;
1725:              
1726:              		/* If null is passed in here then the name of the calling task is being queried. */
1727:              		pxTCB = prvGetTCBFromHandle( xTaskToQuery );
001A1A  90021E     MOV [W14+2], W4
001A1C  520FE0     SUB W4, #0x0, [W15]
001A1E  3A0002     BRA NZ, 0x1A24
001A20  82FA14     MOV pxCurrentTCB, W4
001A22  370001     BRA 0x1A26
001A24  90021E     MOV [W14+2], W4
001A26  780F04     MOV W4, [W14]
1728:              		configASSERT( pxTCB );
1729:              		return &( pxTCB->pcTaskName[ 0 ] );
001A28  78029E     MOV [W14], W5
001A2A  42827A     ADD W5, #0x1A, W4
1730:              	}
001A2C  780004     MOV W4, W0
001A2E  FA8000     ULNK
001A30  060000     RETURN
1731:              
1732:              #endif /* INCLUDE_pcTaskGetTaskName */
1733:              /*-----------------------------------------------------------*/
1734:              
1735:              #if ( configUSE_TRACE_FACILITY == 1 )
1736:              
1737:              	UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime )
1738:              	{
001A32  FA000A     LNK #0xA
001A34  980720     MOV W0, [W14+4]
001A36  980731     MOV W1, [W14+6]
001A38  980742     MOV W2, [W14+8]
1739:              	UBaseType_t uxTask = 0, uxQueue = configMAX_PRIORITIES;
001A3A  EB0200     CLR W4
001A3C  780F04     MOV W4, [W14]
001A3E  200054     MOV #0x5, W4
001A40  980714     MOV W4, [W14+2]
1740:              
1741:              		vTaskSuspendAll();
001A42  07FF72     RCALL vTaskSuspendAll
1742:              		{
1743:              			/* Is there a space in the array for each task in the system? */
1744:              			if( uxArraySize >= uxCurrentNumberOfTasks )
001A44  82FD74     MOV uxCurrentNumberOfTasks, W4
001A46  9002BE     MOV [W14+6], W5
001A48  528F84     SUB W5, W4, [W15]
001A4A  390045     BRA NC, 0x1AD6
1745:              			{
1746:              				/* Fill in an TaskStatus_t structure with information on each
1747:              				task in the Ready state. */
1748:              				do
1749:              				{
1750:              					uxQueue--;
001A4C  90021E     MOV [W14+2], W4
001A4E  E90204     DEC W4, W4
001A50  980714     MOV W4, [W14+2]
1751:              					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &( pxReadyTasksLists[ uxQueue ] ), eReady );
001A52  90021E     MOV [W14+2], W4
001A54  B922EA     MUL.SU W4, #10, W4
001A56  780284     MOV W4, W5
001A58  25F444     MOV #0x5F44, W4
001A5A  428284     ADD W5, W4, W5
001A5C  78021E     MOV [W14], W4
001A5E  B922F2     MUL.SU W4, #18, W4
001A60  90032E     MOV [W14+4], W6
001A62  430204     ADD W6, W4, W4
001A64  200012     MOV #0x1, W2
001A66  780085     MOV W5, W1
001A68  780004     MOV W4, W0
001A6A  0702F3     RCALL prvListTaskWithinSingleList
001A6C  780200     MOV W0, W4
001A6E  420F1E     ADD W4, [W14], [W14]
1752:              
1753:              				} while( uxQueue > ( UBaseType_t ) tskIDLE_PRIORITY ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
001A70  90021E     MOV [W14+2], W4
001A72  520FE0     SUB W4, #0x0, [W15]
001A74  3AFFEB     BRA NZ, 0x1A4C
1754:              
1755:              				/* Fill in an TaskStatus_t structure with information on each
1756:              				task in the Blocked state. */
1757:              				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxDelayedTaskList, eBlocked );
001A76  82FC55     MOV pxDelayedTaskList, W5
001A78  78021E     MOV [W14], W4
001A7A  B922F2     MUL.SU W4, #18, W4
001A7C  90032E     MOV [W14+4], W6
001A7E  430204     ADD W6, W4, W4
001A80  200022     MOV #0x2, W2
001A82  780085     MOV W5, W1
001A84  780004     MOV W4, W0
001A86  0702E5     RCALL prvListTaskWithinSingleList
001A88  780200     MOV W0, W4
001A8A  420F1E     ADD W4, [W14], [W14]
1758:              				uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), ( List_t * ) pxOverflowDelayedTaskList, eBlocked );
001A8C  82FC65     MOV pxOverflowDelayedTaskList, W5
001A8E  78021E     MOV [W14], W4
001A90  B922F2     MUL.SU W4, #18, W4
001A92  90032E     MOV [W14+4], W6
001A94  430204     ADD W6, W4, W4
001A96  200022     MOV #0x2, W2
001A98  780085     MOV W5, W1
001A9A  780004     MOV W4, W0
001A9C  0702DA     RCALL prvListTaskWithinSingleList
001A9E  780200     MOV W0, W4
001AA0  420F1E     ADD W4, [W14], [W14]
1759:              
1760:              				#if( INCLUDE_vTaskDelete == 1 )
1761:              				{
1762:              					/* Fill in an TaskStatus_t structure with information on
1763:              					each task that has been deleted but not yet cleaned up. */
1764:              					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xTasksWaitingTermination, eDeleted );
001AA2  78021E     MOV [W14], W4
001AA4  B922F2     MUL.SU W4, #18, W4
001AA6  9002AE     MOV [W14+4], W5
001AA8  428204     ADD W5, W4, W4
001AAA  200042     MOV #0x4, W2
001AAC  25F981     MOV #0x5F98, W1
001AAE  780004     MOV W4, W0
001AB0  0702D0     RCALL prvListTaskWithinSingleList
001AB2  780200     MOV W0, W4
001AB4  420F1E     ADD W4, [W14], [W14]
1765:              				}
1766:              				#endif
1767:              
1768:              				#if ( INCLUDE_vTaskSuspend == 1 )
1769:              				{
1770:              					/* Fill in an TaskStatus_t structure with information on
1771:              					each task in the Suspended state. */
1772:              					uxTask += prvListTaskWithinSingleList( &( pxTaskStatusArray[ uxTask ] ), &xSuspendedTaskList, eSuspended );
001AB6  78021E     MOV [W14], W4
001AB8  B922F2     MUL.SU W4, #18, W4
001ABA  9002AE     MOV [W14+4], W5
001ABC  428204     ADD W5, W4, W4
001ABE  200032     MOV #0x3, W2
001AC0  25FA41     MOV #0x5FA4, W1
001AC2  780004     MOV W4, W0
001AC4  0702C6     RCALL prvListTaskWithinSingleList
001AC6  780200     MOV W0, W4
001AC8  420F1E     ADD W4, [W14], [W14]
1773:              				}
1774:              				#endif
1775:              
1776:              				#if ( configGENERATE_RUN_TIME_STATS == 1)
1777:              				{
1778:              					if( pulTotalRunTime != NULL )
1779:              					{
1780:              						#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
1781:              							portALT_GET_RUN_TIME_COUNTER_VALUE( ( *pulTotalRunTime ) );
1782:              						#else
1783:              							*pulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1784:              						#endif
1785:              					}
1786:              				}
1787:              				#else
1788:              				{
1789:              					if( pulTotalRunTime != NULL )
001ACA  90024E     MOV [W14+8], W4
001ACC  520FE0     SUB W4, #0x0, [W15]
001ACE  320003     BRA Z, 0x1AD6
1790:              					{
1791:              						*pulTotalRunTime = 0;
001AD0  90034E     MOV [W14+8], W6
001AD2  B82260     MUL.UU W4, #0, W4
001AD4  BE8B04     MOV.D W4, [W6]
1792:              					}
1793:              				}
1794:              				#endif
1795:              			}
1796:              			else
1797:              			{
1798:              				mtCOVERAGE_TEST_MARKER();
1799:              			}
1800:              		}
1801:              		( void ) xTaskResumeAll();
001AD6  07FF2E     RCALL xTaskResumeAll
1802:              
1803:              		return uxTask;
001AD8  78021E     MOV [W14], W4
1804:              	}
001ADA  780004     MOV W4, W0
001ADC  FA8000     ULNK
001ADE  060000     RETURN
1805:              
1806:              #endif /* configUSE_TRACE_FACILITY */
1807:              /*----------------------------------------------------------*/
1808:              
1809:              #if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
1810:              
1811:              	TaskHandle_t xTaskGetIdleTaskHandle( void )
1812:              	{
1813:              		/* If xTaskGetIdleTaskHandle() is called before the scheduler has been
1814:              		started, then xIdleTaskHandle will be NULL. */
1815:              		configASSERT( ( xIdleTaskHandle != NULL ) );
1816:              		return xIdleTaskHandle;
1817:              	}
1818:              
1819:              #endif /* INCLUDE_xTaskGetIdleTaskHandle */
1820:              /*----------------------------------------------------------*/
1821:              
1822:              /* This conditional compilation should use inequality to 0, not equality to 1.
1823:              This is to ensure vTaskStepTick() is available when user defined low power mode
1824:              implementations require configUSE_TICKLESS_IDLE to be set to a value other than
1825:              1. */
1826:              #if ( configUSE_TICKLESS_IDLE != 0 )
1827:              
1828:              	void vTaskStepTick( const TickType_t xTicksToJump )
1829:              	{
1830:              		/* Correct the tick count value after a period during which the tick
1831:              		was suppressed.  Note this does *not* call the tick hook function for
1832:              		each stepped tick. */
1833:              		configASSERT( ( xTickCount + xTicksToJump ) <= xNextTaskUnblockTime );
1834:              		xTickCount += xTicksToJump;
1835:              		traceINCREASE_TICK_COUNT( xTicksToJump );
1836:              	}
1837:              
1838:              #endif /* configUSE_TICKLESS_IDLE */
1839:              /*----------------------------------------------------------*/
1840:              
1841:              BaseType_t xTaskIncrementTick( void )
1842:              {
001AE0  FA000A     LNK #0xA
1843:              TCB_t * pxTCB;
1844:              TickType_t xItemValue;
1845:              BaseType_t xSwitchRequired = pdFALSE;
001AE2  EB0200     CLR W4
001AE4  780F04     MOV W4, [W14]
1846:              
1847:              	/* Called by the portable layer each time a tick interrupt occurs.
1848:              	Increments the tick then checks to see if the new tick value will cause any
1849:              	tasks to be unblocked. */
1850:              	traceTASK_INCREMENT_TICK( xTickCount );
1851:              	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001AE6  82FDF4     MOV uxSchedulerSuspended, W4
001AE8  520FE0     SUB W4, #0x0, [W15]
001AEA  3A0058     BRA NZ, 0x1B9C
1852:              	{
1853:              		/* Increment the RTOS tick, switching the delayed and overflowed
1854:              		delayed lists if it wraps to 0. */
1855:              		++xTickCount;
001AEC  82FD84     MOV xTickCount, W4
001AEE  E80204     INC W4, W4
001AF0  8AFD84     MOV W4, xTickCount
1856:              
1857:              		{
1858:              			/* Minor optimisation.  The tick count cannot change in this
1859:              			block. */
1860:              			const TickType_t xConstTickCount = xTickCount;
001AF2  82FD84     MOV xTickCount, W4
001AF4  980714     MOV W4, [W14+2]
1861:              
1862:              			if( xConstTickCount == ( TickType_t ) 0U )
001AF6  90021E     MOV [W14+2], W4
001AF8  520FE0     SUB W4, #0x0, [W15]
001AFA  3A000A     BRA NZ, 0x1B10
1863:              			{
1864:              				taskSWITCH_DELAYED_LISTS();
001AFC  82FC55     MOV pxDelayedTaskList, W5
001AFE  980725     MOV W5, [W14+4]
001B00  82FC64     MOV pxOverflowDelayedTaskList, W4
001B02  8AFC54     MOV W4, pxDelayedTaskList
001B04  90022E     MOV [W14+4], W4
001B06  8AFC64     MOV W4, pxOverflowDelayedTaskList
001B08  82FDD4     MOV xNumOfOverflows, W4
001B0A  E80204     INC W4, W4
001B0C  8AFDD4     MOV W4, xNumOfOverflows
001B0E  070361     RCALL prvResetNextTaskUnblockTime
1865:              			}
1866:              			else
1867:              			{
1868:              				mtCOVERAGE_TEST_MARKER();
1869:              			}
1870:              
1871:              			/* See if this tick has made a timeout expire.  Tasks are stored in
1872:              			the	queue in the order of their wake time - meaning once one task
1873:              			has been found whose block time has not expired there is no need to
1874:              			look any further	down the list. */
1875:              			if( xConstTickCount >= xNextTaskUnblockTime )
001B10  830304     MOV xNextTaskUnblockTime, W4
001B12  90029E     MOV [W14+2], W5
001B14  528F84     SUB W5, W4, [W15]
001B16  390046     BRA NC, 0x1BA4
001B18  370001     BRA 0x1B1C
1876:              			{
1877:              				for( ;; )
1878:              				{
1879:              					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
001B1C  82FC54     MOV pxDelayedTaskList, W4
001B1E  780214     MOV [W4], W4
001B20  520FE0     SUB W4, #0x0, [W15]
001B22  3A0003     BRA NZ, 0x1B2A
1880:              					{
1881:              						/* The delayed list is empty.  Set xNextTaskUnblockTime
1882:              						to the maximum possible value so it is extremely
1883:              						unlikely that the
1884:              						if( xTickCount >= xNextTaskUnblockTime ) test will pass
1885:              						next time through. */
1886:              						xNextTaskUnblockTime = portMAX_DELAY;
001B24  EB8200     SETM W4
001B26  8B0304     MOV W4, xNextTaskUnblockTime
1887:              						break;
001B28  37003E     BRA 0x1BA6
1888:              					}
1889:              					else
1890:              					{
1891:              						/* The delayed list is not empty, get the value of the
1892:              						item at the head of the delayed list.  This is the time
1893:              						at which the task at the head of the delayed list must
1894:              						be removed from the Blocked state. */
1895:              						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
001B2A  82FC54     MOV pxDelayedTaskList, W4
001B2C  900234     MOV [W4+6], W4
001B2E  900234     MOV [W4+6], W4
001B30  980734     MOV W4, [W14+6]
1896:              						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
001B32  90023E     MOV [W14+6], W4
001B34  900294     MOV [W4+2], W5
001B36  980745     MOV W5, [W14+8]
1897:              
1898:              						if( xConstTickCount < xItemValue )
001B38  90029E     MOV [W14+2], W5
001B3A  90024E     MOV [W14+8], W4
001B3C  528F84     SUB W5, W4, [W15]
001B3E  310004     BRA C, 0x1B48
1899:              						{
1900:              							/* It is not time to unblock this item yet, but the
1901:              							item value is the time at which the task at the head
1902:              							of the blocked list must be removed from the Blocked
1903:              							state -	so record the item value in
1904:              							xNextTaskUnblockTime. */
1905:              							xNextTaskUnblockTime = xItemValue;
001B40  90024E     MOV [W14+8], W4
001B42  8B0304     MOV W4, xNextTaskUnblockTime
1906:              							break;
001B44  000000     NOP
001B46  37002F     BRA 0x1BA6
1907:              						}
1908:              						else
1909:              						{
1910:              							mtCOVERAGE_TEST_MARKER();
1911:              						}
1912:              
1913:              						/* It is time to remove the item from the Blocked state. */
1914:              						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
001B48  90023E     MOV [W14+6], W4
001B4A  E88204     INC2 W4, W4
001B4C  780004     MOV W4, W0
001B4E  024C0E     CALL uxListRemove
001B50  000000     NOP
1915:              
1916:              						/* Is the task waiting on an event also?  If so remove
1917:              						it from the event list. */
1918:              						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
001B52  90023E     MOV [W14+6], W4
001B54  900A24     MOV [W4+20], W4
001B56  520FE0     SUB W4, #0x0, [W15]
001B58  320005     BRA Z, 0x1B64
1919:              						{
1920:              							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
001B5A  90023E     MOV [W14+6], W4
001B5C  42026C     ADD W4, #0xC, W4
001B5E  780004     MOV W4, W0
001B60  024C0E     CALL uxListRemove
001B62  000000     NOP
1921:              						}
1922:              						else
1923:              						{
1924:              							mtCOVERAGE_TEST_MARKER();
1925:              						}
1926:              
1927:              						/* Place the unblocked task into the appropriate ready
1928:              						list. */
1929:              						prvAddTaskToReadyList( pxTCB );
001B64  90023E     MOV [W14+6], W4
001B66  900AB4     MOV [W4+22], W5
001B68  82FD94     MOV uxTopReadyPriority, W4
001B6A  528F84     SUB W5, W4, [W15]
001B6C  360003     BRA LEU, 0x1B74
001B6E  90023E     MOV [W14+6], W4
001B70  900A34     MOV [W4+22], W4
001B72  8AFD94     MOV W4, uxTopReadyPriority
001B74  90023E     MOV [W14+6], W4
001B76  E88284     INC2 W4, W5
001B78  90023E     MOV [W14+6], W4
001B7A  900A34     MOV [W4+22], W4
001B7C  B923EA     MUL.SU W4, #10, W6
001B7E  25F444     MOV #0x5F44, W4
001B80  430204     ADD W6, W4, W4
001B82  780085     MOV W5, W1
001B84  780004     MOV W4, W0
001B86  024B6E     CALL vListInsertEnd
001B88  000000     NOP
1930:              
1931:              						/* A task being unblocked cannot cause an immediate
1932:              						context switch if preemption is turned off. */
1933:              						#if (  configUSE_PREEMPTION == 1 )
1934:              						{
1935:              							/* Preemption is on, but a context switch should
1936:              							only be performed if the unblocked task has a
1937:              							priority that is equal to or higher than the
1938:              							currently executing task. */
1939:              							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
001B8A  90023E     MOV [W14+6], W4
001B8C  900AB4     MOV [W4+22], W5
001B8E  82FA14     MOV pxCurrentTCB, W4
001B90  900A34     MOV [W4+22], W4
001B92  528F84     SUB W5, W4, [W15]
001B94  39FFC2     BRA NC, 0x1B1A
1940:              							{
1941:              								xSwitchRequired = pdTRUE;
001B96  200014     MOV #0x1, W4
001B98  780F04     MOV W4, [W14]
1942:              							}
1943:              							else
1944:              							{
1945:              								mtCOVERAGE_TEST_MARKER();
1946:              							}
1947:              						}
1948:              						#endif /* configUSE_PREEMPTION */
1949:              					}
1950:              				}
001B1A  000000     NOP
001B9A  37FFC0     BRA 0x1B1C
001BA4  000000     NOP
1951:              			}
1952:              		}
1953:              
1954:              		/* Tasks of equal priority to the currently running task will share
1955:              		processing time (time slice) if preemption is on, and the application
1956:              		writer has not explicitly turned time slicing off. */
1957:              		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
1958:              		{
1959:              			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
1960:              			{
1961:              				xSwitchRequired = pdTRUE;
1962:              			}
1963:              			else
1964:              			{
1965:              				mtCOVERAGE_TEST_MARKER();
1966:              			}
1967:              		}
1968:              		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
1969:              
1970:              		#if ( configUSE_TICK_HOOK == 1 )
1971:              		{
1972:              			/* Guard against the tick hook being called when the pended tick
1973:              			count is being unwound (when the scheduler is being unlocked). */
1974:              			if( uxPendedTicks == ( UBaseType_t ) 0U )
1975:              			{
1976:              				vApplicationTickHook();
1977:              			}
1978:              			else
1979:              			{
1980:              				mtCOVERAGE_TEST_MARKER();
1981:              			}
1982:              		}
1983:              		#endif /* configUSE_TICK_HOOK */
1984:              	}
1985:              	else
1986:              	{
1987:              		++uxPendedTicks;
001B9C  82FDB4     MOV uxPendedTicks, W4
001B9E  E80204     INC W4, W4
001BA0  8AFDB4     MOV W4, uxPendedTicks
001BA2  370001     BRA 0x1BA6
1988:              
1989:              		/* The tick hook gets called at regular intervals, even if the
1990:              		scheduler is locked. */
1991:              		#if ( configUSE_TICK_HOOK == 1 )
1992:              		{
1993:              			vApplicationTickHook();
1994:              		}
1995:              		#endif
1996:              	}
1997:              
1998:              	#if ( configUSE_PREEMPTION == 1 )
1999:              	{
2000:              		if( xYieldPending != pdFALSE )
001BA6  82FDC4     MOV xYieldPending, W4
001BA8  520FE0     SUB W4, #0x0, [W15]
001BAA  320002     BRA Z, 0x1BB0
2001:              		{
2002:              			xSwitchRequired = pdTRUE;
001BAC  200014     MOV #0x1, W4
001BAE  780F04     MOV W4, [W14]
2003:              		}
2004:              		else
2005:              		{
2006:              			mtCOVERAGE_TEST_MARKER();
2007:              		}
2008:              	}
2009:              	#endif /* configUSE_PREEMPTION */
2010:              
2011:              	return xSwitchRequired;
001BB0  78021E     MOV [W14], W4
2012:              }
001BB2  780004     MOV W4, W0
001BB4  FA8000     ULNK
001BB6  060000     RETURN
2013:              /*-----------------------------------------------------------*/
2014:              
2015:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2016:              
2017:              	void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction )
2018:              	{
2019:              	TCB_t *xTCB;
2020:              
2021:              		/* If xTask is NULL then it is the task hook of the calling task that is
2022:              		getting set. */
2023:              		if( xTask == NULL )
2024:              		{
2025:              			xTCB = ( TCB_t * ) pxCurrentTCB;
2026:              		}
2027:              		else
2028:              		{
2029:              			xTCB = ( TCB_t * ) xTask;
2030:              		}
2031:              
2032:              		/* Save the hook function in the TCB.  A critical section is required as
2033:              		the value can be accessed from an interrupt. */
2034:              		taskENTER_CRITICAL();
2035:              			xTCB->pxTaskTag = pxHookFunction;
2036:              		taskEXIT_CRITICAL();
2037:              	}
2038:              
2039:              #endif /* configUSE_APPLICATION_TASK_TAG */
2040:              /*-----------------------------------------------------------*/
2041:              
2042:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2043:              
2044:              	TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask )
2045:              	{
2046:              	TCB_t *xTCB;
2047:              	TaskHookFunction_t xReturn;
2048:              
2049:              		/* If xTask is NULL then we are setting our own task hook. */
2050:              		if( xTask == NULL )
2051:              		{
2052:              			xTCB = ( TCB_t * ) pxCurrentTCB;
2053:              		}
2054:              		else
2055:              		{
2056:              			xTCB = ( TCB_t * ) xTask;
2057:              		}
2058:              
2059:              		/* Save the hook function in the TCB.  A critical section is required as
2060:              		the value can be accessed from an interrupt. */
2061:              		taskENTER_CRITICAL();
2062:              		{
2063:              			xReturn = xTCB->pxTaskTag;
2064:              		}
2065:              		taskEXIT_CRITICAL();
2066:              
2067:              		return xReturn;
2068:              	}
2069:              
2070:              #endif /* configUSE_APPLICATION_TASK_TAG */
2071:              /*-----------------------------------------------------------*/
2072:              
2073:              #if ( configUSE_APPLICATION_TASK_TAG == 1 )
2074:              
2075:              	BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter )
2076:              	{
2077:              	TCB_t *xTCB;
2078:              	BaseType_t xReturn;
2079:              
2080:              		/* If xTask is NULL then we are calling our own task hook. */
2081:              		if( xTask == NULL )
2082:              		{
2083:              			xTCB = ( TCB_t * ) pxCurrentTCB;
2084:              		}
2085:              		else
2086:              		{
2087:              			xTCB = ( TCB_t * ) xTask;
2088:              		}
2089:              
2090:              		if( xTCB->pxTaskTag != NULL )
2091:              		{
2092:              			xReturn = xTCB->pxTaskTag( pvParameter );
2093:              		}
2094:              		else
2095:              		{
2096:              			xReturn = pdFAIL;
2097:              		}
2098:              
2099:              		return xReturn;
2100:              	}
2101:              
2102:              #endif /* configUSE_APPLICATION_TASK_TAG */
2103:              /*-----------------------------------------------------------*/
2104:              
2105:              void vTaskSwitchContext( void )
2106:              {
001BB8  FA0002     LNK #0x2
2107:              	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
001BBA  82FDF4     MOV uxSchedulerSuspended, W4
001BBC  520FE0     SUB W4, #0x0, [W15]
001BBE  320003     BRA Z, 0x1BC6
2108:              	{
2109:              		/* The scheduler is currently suspended - do not allow a context
2110:              		switch. */
2111:              		xYieldPending = pdTRUE;
001BC0  200014     MOV #0x1, W4
001BC2  8AFDC4     MOV W4, xYieldPending
001BC4  370027     BRA 0x1C14
2112:              	}
2113:              	else
2114:              	{
2115:              		xYieldPending = pdFALSE;
001BC6  EB0200     CLR W4
001BC8  8AFDC4     MOV W4, xYieldPending
2116:              		traceTASK_SWITCHED_OUT();
2117:              
2118:              		#if ( configGENERATE_RUN_TIME_STATS == 1 )
2119:              		{
2120:              				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
2121:              					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
2122:              				#else
2123:              					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
2124:              				#endif
2125:              
2126:              				/* Add the amount of time the task has been running to the
2127:              				accumulated	time so far.  The time the task started running was
2128:              				stored in ulTaskSwitchedInTime.  Note that there is no overflow
2129:              				protection here	so count values are only valid until the timer
2130:              				overflows.  The guard against negative values is to protect
2131:              				against suspect run time stat counter implementations - which
2132:              				are provided by the application, not the kernel. */
2133:              				if( ulTotalRunTime > ulTaskSwitchedInTime )
2134:              				{
2135:              					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
2136:              				}
2137:              				else
2138:              				{
2139:              					mtCOVERAGE_TEST_MARKER();
2140:              				}
2141:              				ulTaskSwitchedInTime = ulTotalRunTime;
2142:              		}
2143:              		#endif /* configGENERATE_RUN_TIME_STATS */
2144:              
2145:              		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
2146:              		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
2147:              
2148:              		taskSELECT_HIGHEST_PRIORITY_TASK();
001BCA  370003     BRA 0x1BD2
001BCC  82FD94     MOV uxTopReadyPriority, W4
001BCE  E90204     DEC W4, W4
001BD0  8AFD94     MOV W4, uxTopReadyPriority
001BD2  82FD94     MOV uxTopReadyPriority, W4
001BD4  B922EA     MUL.SU W4, #10, W4
001BD6  780284     MOV W4, W5
001BD8  25F444     MOV #0x5F44, W4
001BDA  428204     ADD W5, W4, W4
001BDC  780214     MOV [W4], W4
001BDE  520FE0     SUB W4, #0x0, [W15]
001BE0  32FFF5     BRA Z, 0x1BCC
001BE2  82FD94     MOV uxTopReadyPriority, W4
001BE4  B922EA     MUL.SU W4, #10, W4
001BE6  780284     MOV W4, W5
001BE8  25F444     MOV #0x5F44, W4
001BEA  428F04     ADD W5, W4, [W14]
001BEC  78021E     MOV [W14], W4
001BEE  900214     MOV [W4+2], W4
001BF0  900294     MOV [W4+2], W5
001BF2  78021E     MOV [W14], W4
001BF4  980215     MOV W5, [W4+2]
001BF6  78021E     MOV [W14], W4
001BF8  900294     MOV [W4+2], W5
001BFA  78031E     MOV [W14], W6
001BFC  430264     ADD W6, #0x4, W4
001BFE  528F84     SUB W5, W4, [W15]
001C00  3A0005     BRA NZ, 0x1C0C
001C02  78021E     MOV [W14], W4
001C04  900214     MOV [W4+2], W4
001C06  900294     MOV [W4+2], W5
001C08  78021E     MOV [W14], W4
001C0A  980215     MOV W5, [W4+2]
001C0C  78021E     MOV [W14], W4
001C0E  900214     MOV [W4+2], W4
001C10  900234     MOV [W4+6], W4
001C12  8AFA14     MOV W4, pxCurrentTCB
2149:              
2150:              		traceTASK_SWITCHED_IN();
2151:              
2152:              		#if ( configUSE_NEWLIB_REENTRANT == 1 )
2153:              		{
2154:              			/* Switch Newlib's _impure_ptr variable to point to the _reent
2155:              			structure specific to this task. */
2156:              			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
2157:              		}
2158:              		#endif /* configUSE_NEWLIB_REENTRANT */
2159:              	}
2160:              }
001C14  FA8000     ULNK
001C16  060000     RETURN
2161:              /*-----------------------------------------------------------*/
2162:              
2163:              void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
2164:              {
001C18  FA0006     LNK #0x6
001C1A  980710     MOV W0, [W14+2]
001C1C  980721     MOV W1, [W14+4]
2165:              TickType_t xTimeToWake;
2166:              
2167:              	configASSERT( pxEventList );
2168:              
2169:              	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
2170:              	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
2171:              
2172:              	/* Place the event list item of the TCB in the appropriate event list.
2173:              	This is placed in the list in priority order so the highest priority task
2174:              	is the first to be woken by the event.  The queue that contains the event
2175:              	list is locked, preventing simultaneous access from interrupts. */
2176:              	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
001C1E  82FA14     MOV pxCurrentTCB, W4
001C20  42026C     ADD W4, #0xC, W4
001C22  780084     MOV W4, W1
001C24  90001E     MOV [W14+2], W0
001C26  024BAA     CALL vListInsert
001C28  000000     NOP
2177:              
2178:              	/* The task must be removed from from the ready list before it is added to
2179:              	the blocked list as the same list item is used for both lists.  Exclusive
2180:              	access to the ready lists guaranteed because the scheduler is locked. */
2181:              	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
001C2A  82FA14     MOV pxCurrentTCB, W4
001C2C  E88204     INC2 W4, W4
001C2E  780004     MOV W4, W0
001C30  024C0E     CALL uxListRemove
001C32  000000     NOP
2182:              	{
2183:              		/* The current task must be in a ready list, so there is no need to
2184:              		check, and the port reset macro can be called directly. */
2185:              		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2186:              	}
2187:              	else
2188:              	{
2189:              		mtCOVERAGE_TEST_MARKER();
2190:              	}
2191:              
2192:              	#if ( INCLUDE_vTaskSuspend == 1 )
2193:              	{
2194:              		if( xTicksToWait == portMAX_DELAY )
001C34  90022E     MOV [W14+4], W4
001C36  420FE1     ADD W4, #0x1, [W15]
001C38  3A0007     BRA NZ, 0x1C48
2195:              		{
2196:              			/* Add the task to the suspended task list instead of a delayed task
2197:              			list to ensure the task is not woken by a timing event.  It will
2198:              			block indefinitely. */
2199:              			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
001C3A  82FA14     MOV pxCurrentTCB, W4
001C3C  E88204     INC2 W4, W4
001C3E  780084     MOV W4, W1
001C40  25FA40     MOV #0x5FA4, W0
001C42  024B6E     CALL vListInsertEnd
001C44  000000     NOP
001C46  370005     BRA 0x1C52
2200:              		}
2201:              		else
2202:              		{
2203:              			/* Calculate the time at which the task should be woken if the event
2204:              			does not occur.  This may overflow but this doesn't matter, the
2205:              			scheduler will handle it. */
2206:              			xTimeToWake = xTickCount + xTicksToWait;
001C48  82FD85     MOV xTickCount, W5
001C4A  90022E     MOV [W14+4], W4
001C4C  428F04     ADD W5, W4, [W14]
2207:              			prvAddCurrentTaskToDelayedList( xTimeToWake );
001C4E  78001E     MOV [W14], W0
001C50  0701B0     RCALL prvAddCurrentTaskToDelayedList
2208:              		}
2209:              	}
2210:              	#else /* INCLUDE_vTaskSuspend */
2211:              	{
2212:              			/* Calculate the time at which the task should be woken if the event does
2213:              			not occur.  This may overflow but this doesn't matter, the scheduler
2214:              			will handle it. */
2215:              			xTimeToWake = xTickCount + xTicksToWait;
2216:              			prvAddCurrentTaskToDelayedList( xTimeToWake );
2217:              	}
2218:              	#endif /* INCLUDE_vTaskSuspend */
2219:              }
001C52  FA8000     ULNK
001C54  060000     RETURN
2220:              /*-----------------------------------------------------------*/
2221:              
2222:              void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
2223:              {
001C56  FA0008     LNK #0x8
001C58  980710     MOV W0, [W14+2]
001C5A  980721     MOV W1, [W14+4]
001C5C  980732     MOV W2, [W14+6]
2224:              TickType_t xTimeToWake;
2225:              
2226:              	configASSERT( pxEventList );
2227:              
2228:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2229:              	the event groups implementation. */
2230:              	configASSERT( uxSchedulerSuspended != 0 );
2231:              
2232:              	/* Store the item value in the event list item.  It is safe to access the
2233:              	event list item here as interrupts won't access the event list item of a
2234:              	task that is not in the Blocked state. */
2235:              	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
001C5E  82FA14     MOV pxCurrentTCB, W4
001C60  90032E     MOV [W14+4], W6
001C62  280005     MOV #0x8000, W5
001C64  728286     IOR W5, W6, W5
001C66  980265     MOV W5, [W4+12]
2236:              
2237:              	/* Place the event list item of the TCB at the end of the appropriate event
2238:              	list.  It is safe to access the event list here because it is part of an
2239:              	event group implementation - and interrupts don't access event groups
2240:              	directly (instead they access them indirectly by pending function calls to
2241:              	the task level). */
2242:              	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
001C68  82FA14     MOV pxCurrentTCB, W4
001C6A  42026C     ADD W4, #0xC, W4
001C6C  780084     MOV W4, W1
001C6E  90001E     MOV [W14+2], W0
001C70  024B6E     CALL vListInsertEnd
001C72  000000     NOP
2243:              
2244:              	/* The task must be removed from the ready list before it is added to the
2245:              	blocked list.  Exclusive access can be assured to the ready list as the
2246:              	scheduler is locked. */
2247:              	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
001C74  82FA14     MOV pxCurrentTCB, W4
001C76  E88204     INC2 W4, W4
001C78  780004     MOV W4, W0
001C7A  024C0E     CALL uxListRemove
001C7C  000000     NOP
2248:              	{
2249:              		/* The current task must be in a ready list, so there is no need to
2250:              		check, and the port reset macro can be called directly. */
2251:              		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2252:              	}
2253:              	else
2254:              	{
2255:              		mtCOVERAGE_TEST_MARKER();
2256:              	}
2257:              
2258:              	#if ( INCLUDE_vTaskSuspend == 1 )
2259:              	{
2260:              		if( xTicksToWait == portMAX_DELAY )
001C7E  90023E     MOV [W14+6], W4
001C80  420FE1     ADD W4, #0x1, [W15]
001C82  3A0007     BRA NZ, 0x1C92
2261:              		{
2262:              			/* Add the task to the suspended task list instead of a delayed task
2263:              			list to ensure it is not woken by a timing event.  It will block
2264:              			indefinitely. */
2265:              			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
001C84  82FA14     MOV pxCurrentTCB, W4
001C86  E88204     INC2 W4, W4
001C88  780084     MOV W4, W1
001C8A  25FA40     MOV #0x5FA4, W0
001C8C  024B6E     CALL vListInsertEnd
001C8E  000000     NOP
001C90  370005     BRA 0x1C9C
2266:              		}
2267:              		else
2268:              		{
2269:              			/* Calculate the time at which the task should be woken if the event
2270:              			does not occur.  This may overflow but this doesn't matter, the
2271:              			kernel will manage it correctly. */
2272:              			xTimeToWake = xTickCount + xTicksToWait;
001C92  82FD85     MOV xTickCount, W5
001C94  90023E     MOV [W14+6], W4
001C96  428F04     ADD W5, W4, [W14]
2273:              			prvAddCurrentTaskToDelayedList( xTimeToWake );
001C98  78001E     MOV [W14], W0
001C9A  07018B     RCALL prvAddCurrentTaskToDelayedList
2274:              		}
2275:              	}
2276:              	#else /* INCLUDE_vTaskSuspend */
2277:              	{
2278:              			/* Calculate the time at which the task should be woken if the event does
2279:              			not occur.  This may overflow but this doesn't matter, the kernel
2280:              			will manage it correctly. */
2281:              			xTimeToWake = xTickCount + xTicksToWait;
2282:              			prvAddCurrentTaskToDelayedList( xTimeToWake );
2283:              	}
2284:              	#endif /* INCLUDE_vTaskSuspend */
2285:              }
001C9C  FA8000     ULNK
001C9E  060000     RETURN
2286:              /*-----------------------------------------------------------*/
2287:              
2288:              #if configUSE_TIMERS == 1
2289:              
2290:              	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
2291:              	{
001CA0  FA0006     LNK #0x6
001CA2  980710     MOV W0, [W14+2]
001CA4  980721     MOV W1, [W14+4]
2292:              	TickType_t xTimeToWake;
2293:              
2294:              		configASSERT( pxEventList );
2295:              
2296:              		/* This function should not be called by application code hence the
2297:              		'Restricted' in its name.  It is not part of the public API.  It is
2298:              		designed for use by kernel code, and has special calling requirements -
2299:              		it should be called from a critical section. */
2300:              
2301:              
2302:              		/* Place the event list item of the TCB in the appropriate event list.
2303:              		In this case it is assume that this is the only task that is going to
2304:              		be waiting on this event list, so the faster vListInsertEnd() function
2305:              		can be used in place of vListInsert. */
2306:              		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
001CA6  82FA14     MOV pxCurrentTCB, W4
001CA8  42026C     ADD W4, #0xC, W4
001CAA  780084     MOV W4, W1
001CAC  90001E     MOV [W14+2], W0
001CAE  024B6E     CALL vListInsertEnd
001CB0  000000     NOP
2307:              
2308:              		/* We must remove this task from the ready list before adding it to the
2309:              		blocked list as the same list item is used for both lists.  This
2310:              		function is called form a critical section. */
2311:              		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
001CB2  82FA14     MOV pxCurrentTCB, W4
001CB4  E88204     INC2 W4, W4
001CB6  780004     MOV W4, W0
001CB8  024C0E     CALL uxListRemove
001CBA  000000     NOP
2312:              		{
2313:              			/* The current task must be in a ready list, so there is no need to
2314:              			check, and the port reset macro can be called directly. */
2315:              			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
2316:              		}
2317:              		else
2318:              		{
2319:              			mtCOVERAGE_TEST_MARKER();
2320:              		}
2321:              
2322:              		/* Calculate the time at which the task should be woken if the event does
2323:              		not occur.  This may overflow but this doesn't matter. */
2324:              		xTimeToWake = xTickCount + xTicksToWait;
001CBC  82FD85     MOV xTickCount, W5
001CBE  90022E     MOV [W14+4], W4
001CC0  428F04     ADD W5, W4, [W14]
2325:              
2326:              		traceTASK_DELAY_UNTIL();
2327:              		prvAddCurrentTaskToDelayedList( xTimeToWake );
001CC2  78001E     MOV [W14], W0
001CC4  070176     RCALL prvAddCurrentTaskToDelayedList
2328:              	}
001CC6  FA8000     ULNK
001CC8  060000     RETURN
2329:              
2330:              #endif /* configUSE_TIMERS */
2331:              /*-----------------------------------------------------------*/
2332:              
2333:              BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
2334:              {
001CCA  FA0006     LNK #0x6
001CCC  980720     MOV W0, [W14+4]
2335:              TCB_t *pxUnblockedTCB;
2336:              BaseType_t xReturn;
2337:              
2338:              	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
2339:              	called from a critical section within an ISR. */
2340:              
2341:              	/* The event list is sorted in priority order, so the first in the list can
2342:              	be removed as it is known to be the highest priority.  Remove the TCB from
2343:              	the delayed list, and add it to the ready list.
2344:              
2345:              	If an event is for a queue that is locked then this function will never
2346:              	get called - the lock count on the queue will get modified instead.  This
2347:              	means exclusive access to the event list is guaranteed here.
2348:              
2349:              	This function assumes that a check has already been made to ensure that
2350:              	pxEventList is not empty. */
2351:              	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
001CCE  90022E     MOV [W14+4], W4
001CD0  900234     MOV [W4+6], W4
001CD2  900234     MOV [W4+6], W4
001CD4  980714     MOV W4, [W14+2]
2352:              	configASSERT( pxUnblockedTCB );
2353:              	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
001CD6  90021E     MOV [W14+2], W4
001CD8  42026C     ADD W4, #0xC, W4
001CDA  780004     MOV W4, W0
001CDC  024C0E     CALL uxListRemove
001CDE  000000     NOP
2354:              
2355:              	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
001CE0  82FDF4     MOV uxSchedulerSuspended, W4
001CE2  520FE0     SUB W4, #0x0, [W15]
001CE4  3A0019     BRA NZ, 0x1D18
2356:              	{
2357:              		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
001CE6  90021E     MOV [W14+2], W4
001CE8  E88204     INC2 W4, W4
001CEA  780004     MOV W4, W0
001CEC  024C0E     CALL uxListRemove
001CEE  000000     NOP
2358:              		prvAddTaskToReadyList( pxUnblockedTCB );
001CF0  90021E     MOV [W14+2], W4
001CF2  900AB4     MOV [W4+22], W5
001CF4  82FD94     MOV uxTopReadyPriority, W4
001CF6  528F84     SUB W5, W4, [W15]
001CF8  360003     BRA LEU, 0x1D00
001CFA  90021E     MOV [W14+2], W4
001CFC  900A34     MOV [W4+22], W4
001CFE  8AFD94     MOV W4, uxTopReadyPriority
001D00  90021E     MOV [W14+2], W4
001D02  E88284     INC2 W4, W5
001D04  90021E     MOV [W14+2], W4
001D06  900A34     MOV [W4+22], W4
001D08  B923EA     MUL.SU W4, #10, W6
001D0A  25F444     MOV #0x5F44, W4
001D0C  430204     ADD W6, W4, W4
001D0E  780085     MOV W5, W1
001D10  780004     MOV W4, W0
001D12  024B6E     CALL vListInsertEnd
001D14  000000     NOP
001D16  370006     BRA 0x1D24
2359:              	}
2360:              	else
2361:              	{
2362:              		/* The delayed and ready lists cannot be accessed, so hold this task
2363:              		pending until the scheduler is resumed. */
2364:              		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
001D18  90021E     MOV [W14+2], W4
001D1A  42026C     ADD W4, #0xC, W4
001D1C  780084     MOV W4, W1
001D1E  25F8E0     MOV #0x5F8E, W0
001D20  024B6E     CALL vListInsertEnd
001D22  000000     NOP
2365:              	}
2366:              
2367:              	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
001D24  90021E     MOV [W14+2], W4
001D26  900AB4     MOV [W4+22], W5
001D28  82FA14     MOV pxCurrentTCB, W4
001D2A  900A34     MOV [W4+22], W4
001D2C  528F84     SUB W5, W4, [W15]
001D2E  360005     BRA LEU, 0x1D3A
2368:              	{
2369:              		/* Return true if the task removed from the event list has a higher
2370:              		priority than the calling task.  This allows the calling task to know if
2371:              		it should force a context switch now. */
2372:              		xReturn = pdTRUE;
001D30  200014     MOV #0x1, W4
001D32  780F04     MOV W4, [W14]
2373:              
2374:              		/* Mark that a yield is pending in case the user is not using the
2375:              		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2376:              		xYieldPending = pdTRUE;
001D34  200014     MOV #0x1, W4
001D36  8AFDC4     MOV W4, xYieldPending
001D38  370002     BRA 0x1D3E
2377:              	}
2378:              	else
2379:              	{
2380:              		xReturn = pdFALSE;
001D3A  EB0200     CLR W4
001D3C  780F04     MOV W4, [W14]
2381:              	}
2382:              
2383:              	return xReturn;
001D3E  78021E     MOV [W14], W4
2384:              }
001D40  780004     MOV W4, W0
001D42  FA8000     ULNK
001D44  060000     RETURN
2385:              /*-----------------------------------------------------------*/
2386:              
2387:              BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
2388:              {
001D46  FA0008     LNK #0x8
001D48  980720     MOV W0, [W14+4]
001D4A  980731     MOV W1, [W14+6]
2389:              TCB_t *pxUnblockedTCB;
2390:              BaseType_t xReturn;
2391:              
2392:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
2393:              	the event flags implementation. */
2394:              	configASSERT( uxSchedulerSuspended != pdFALSE );
2395:              
2396:              	/* Store the new item value in the event list. */
2397:              	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
001D4C  9002BE     MOV [W14+6], W5
001D4E  280004     MOV #0x8000, W4
001D50  780304     MOV W4, W6
001D52  730305     IOR W6, W5, W6
001D54  780286     MOV W6, W5
001D56  90022E     MOV [W14+4], W4
001D58  780A05     MOV W5, [W4]
2398:              
2399:              	/* Remove the event list form the event flag.  Interrupts do not access
2400:              	event flags. */
2401:              	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
001D5A  90022E     MOV [W14+4], W4
001D5C  900234     MOV [W4+6], W4
001D5E  980714     MOV W4, [W14+2]
2402:              	configASSERT( pxUnblockedTCB );
2403:              	( void ) uxListRemove( pxEventListItem );
001D60  90002E     MOV [W14+4], W0
001D62  024C0E     CALL uxListRemove
001D64  000000     NOP
2404:              
2405:              	/* Remove the task from the delayed list and add it to the ready list.  The
2406:              	scheduler is suspended so interrupts will not be accessing the ready
2407:              	lists. */
2408:              	( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
001D66  90021E     MOV [W14+2], W4
001D68  E88204     INC2 W4, W4
001D6A  780004     MOV W4, W0
001D6C  024C0E     CALL uxListRemove
001D6E  000000     NOP
2409:              	prvAddTaskToReadyList( pxUnblockedTCB );
001D70  90021E     MOV [W14+2], W4
001D72  900AB4     MOV [W4+22], W5
001D74  82FD94     MOV uxTopReadyPriority, W4
001D76  528F84     SUB W5, W4, [W15]
001D78  360003     BRA LEU, 0x1D80
001D7A  90021E     MOV [W14+2], W4
001D7C  900A34     MOV [W4+22], W4
001D7E  8AFD94     MOV W4, uxTopReadyPriority
001D80  90021E     MOV [W14+2], W4
001D82  E88284     INC2 W4, W5
001D84  90021E     MOV [W14+2], W4
001D86  900A34     MOV [W4+22], W4
001D88  B923EA     MUL.SU W4, #10, W6
001D8A  25F444     MOV #0x5F44, W4
001D8C  430204     ADD W6, W4, W4
001D8E  780085     MOV W5, W1
001D90  780004     MOV W4, W0
001D92  024B6E     CALL vListInsertEnd
001D94  000000     NOP
2410:              
2411:              	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
001D96  90021E     MOV [W14+2], W4
001D98  900AB4     MOV [W4+22], W5
001D9A  82FA14     MOV pxCurrentTCB, W4
001D9C  900A34     MOV [W4+22], W4
001D9E  528F84     SUB W5, W4, [W15]
001DA0  360005     BRA LEU, 0x1DAC
2412:              	{
2413:              		/* Return true if the task removed from the event list has
2414:              		a higher priority than the calling task.  This allows
2415:              		the calling task to know if it should force a context
2416:              		switch now. */
2417:              		xReturn = pdTRUE;
001DA2  200014     MOV #0x1, W4
001DA4  780F04     MOV W4, [W14]
2418:              
2419:              		/* Mark that a yield is pending in case the user is not using the
2420:              		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
2421:              		xYieldPending = pdTRUE;
001DA6  200014     MOV #0x1, W4
001DA8  8AFDC4     MOV W4, xYieldPending
001DAA  370002     BRA 0x1DB0
2422:              	}
2423:              	else
2424:              	{
2425:              		xReturn = pdFALSE;
001DAC  EB0200     CLR W4
001DAE  780F04     MOV W4, [W14]
2426:              	}
2427:              
2428:              	return xReturn;
001DB0  78021E     MOV [W14], W4
2429:              }
001DB2  780004     MOV W4, W0
001DB4  FA8000     ULNK
001DB6  060000     RETURN
2430:              /*-----------------------------------------------------------*/
2431:              
2432:              void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
2433:              {
001DB8  FA0002     LNK #0x2
001DBA  780F00     MOV W0, [W14]
2434:              	configASSERT( pxTimeOut );
2435:              	pxTimeOut->xOverflowCount = xNumOfOverflows;
001DBC  82FDD5     MOV xNumOfOverflows, W5
001DBE  78021E     MOV [W14], W4
001DC0  780A05     MOV W5, [W4]
2436:              	pxTimeOut->xTimeOnEntering = xTickCount;
001DC2  82FD85     MOV xTickCount, W5
001DC4  78021E     MOV [W14], W4
001DC6  980215     MOV W5, [W4+2]
2437:              }
001DC8  FA8000     ULNK
001DCA  060000     RETURN
2438:              /*-----------------------------------------------------------*/
2439:              
2440:              BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
2441:              {
001DCC  FA0008     LNK #0x8
001DCE  980720     MOV W0, [W14+4]
001DD0  980731     MOV W1, [W14+6]
2442:              BaseType_t xReturn;
2443:              
2444:              	configASSERT( pxTimeOut );
2445:              	configASSERT( pxTicksToWait );
2446:              
2447:              	taskENTER_CRITICAL();
001DD2  02497A     CALL vPortEnterCritical
001DD4  000000     NOP
2448:              	{
2449:              		/* Minor optimisation.  The tick count cannot change in this block. */
2450:              		const TickType_t xConstTickCount = xTickCount;
001DD6  82FD84     MOV xTickCount, W4
001DD8  980714     MOV W4, [W14+2]
2451:              
2452:              		#if ( INCLUDE_vTaskSuspend == 1 )
2453:              			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
2454:              			the maximum block time then the task should block indefinitely, and
2455:              			therefore never time out. */
2456:              			if( *pxTicksToWait == portMAX_DELAY )
001DDA  90023E     MOV [W14+6], W4
001DDC  780214     MOV [W4], W4
001DDE  420FE1     ADD W4, #0x1, [W15]
001DE0  3A0003     BRA NZ, 0x1DE8
2457:              			{
2458:              				xReturn = pdFALSE;
001DE2  EB0200     CLR W4
001DE4  780F04     MOV W4, [W14]
001DE6  370025     BRA 0x1E32
2459:              			}
2460:              			else /* We are not blocking indefinitely, perform the checks below. */
2461:              		#endif
2462:              
2463:              		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
001DE8  90022E     MOV [W14+4], W4
001DEA  780294     MOV [W4], W5
001DEC  82FDD4     MOV xNumOfOverflows, W4
001DEE  528F84     SUB W5, W4, [W15]
001DF0  320008     BRA Z, 0x1E02
001DF2  90022E     MOV [W14+4], W4
001DF4  900294     MOV [W4+2], W5
001DF6  90021E     MOV [W14+2], W4
001DF8  528F84     SUB W5, W4, [W15]
001DFA  3E0003     BRA GTU, 0x1E02
2464:              		{
2465:              			/* The tick count is greater than the time at which vTaskSetTimeout()
2466:              			was called, but has also overflowed since vTaskSetTimeOut() was called.
2467:              			It must have wrapped all the way around and gone past us again. This
2468:              			passed since vTaskSetTimeout() was called. */
2469:              			xReturn = pdTRUE;
001DFC  200014     MOV #0x1, W4
001DFE  780F04     MOV W4, [W14]
001E00  370018     BRA 0x1E32
2470:              		}
2471:              		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
001E02  90022E     MOV [W14+4], W4
001E04  900214     MOV [W4+2], W4
001E06  90029E     MOV [W14+2], W5
001E08  528284     SUB W5, W4, W5
001E0A  90023E     MOV [W14+6], W4
001E0C  780214     MOV [W4], W4
001E0E  528F84     SUB W5, W4, [W15]
001E10  31000E     BRA C, 0x1E2E
2472:              		{
2473:              			/* Not a genuine timeout. Adjust parameters for time remaining. */
2474:              			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
001E12  90023E     MOV [W14+6], W4
001E14  780294     MOV [W4], W5
001E16  90022E     MOV [W14+4], W4
001E18  900314     MOV [W4+2], W6
001E1A  90021E     MOV [W14+2], W4
001E1C  530204     SUB W6, W4, W4
001E1E  428284     ADD W5, W4, W5
001E20  90023E     MOV [W14+6], W4
001E22  780A05     MOV W5, [W4]
2475:              			vTaskSetTimeOutState( pxTimeOut );
001E24  90002E     MOV [W14+4], W0
001E26  07FFC8     RCALL vTaskSetTimeOutState
2476:              			xReturn = pdFALSE;
001E28  EB0200     CLR W4
001E2A  780F04     MOV W4, [W14]
001E2C  370002     BRA 0x1E32
2477:              		}
2478:              		else
2479:              		{
2480:              			xReturn = pdTRUE;
001E2E  200014     MOV #0x1, W4
001E30  780F04     MOV W4, [W14]
2481:              		}
2482:              	}
2483:              	taskEXIT_CRITICAL();
001E32  02498E     CALL vPortExitCritical
001E34  000000     NOP
2484:              
2485:              	return xReturn;
001E36  78021E     MOV [W14], W4
2486:              }
001E38  780004     MOV W4, W0
001E3A  FA8000     ULNK
001E3C  060000     RETURN
2487:              /*-----------------------------------------------------------*/
2488:              
2489:              void vTaskMissedYield( void )
2490:              {
001E3E  FA0000     LNK #0x0
2491:              	xYieldPending = pdTRUE;
001E40  200014     MOV #0x1, W4
001E42  8AFDC4     MOV W4, xYieldPending
2492:              }
001E44  FA8000     ULNK
001E46  060000     RETURN
2493:              /*-----------------------------------------------------------*/
2494:              
2495:              #if ( configUSE_TRACE_FACILITY == 1 )
2496:              
2497:              	UBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask )
2498:              	{
001E48  FA0006     LNK #0x6
001E4A  980720     MOV W0, [W14+4]
2499:              	UBaseType_t uxReturn;
2500:              	TCB_t *pxTCB;
2501:              
2502:              		if( xTask != NULL )
001E4C  90022E     MOV [W14+4], W4
001E4E  520FE0     SUB W4, #0x0, [W15]
001E50  320006     BRA Z, 0x1E5E
2503:              		{
2504:              			pxTCB = ( TCB_t * ) xTask;
001E52  90022E     MOV [W14+4], W4
001E54  980714     MOV W4, [W14+2]
2505:              			uxReturn = pxTCB->uxTaskNumber;
001E56  90021E     MOV [W14+2], W4
001E58  9012B4     MOV [W4+38], W5
001E5A  780F05     MOV W5, [W14]
001E5C  370002     BRA 0x1E62
2506:              		}
2507:              		else
2508:              		{
2509:              			uxReturn = 0U;
001E5E  EB0200     CLR W4
001E60  780F04     MOV W4, [W14]
2510:              		}
2511:              
2512:              		return uxReturn;
001E62  78021E     MOV [W14], W4
2513:              	}
001E64  780004     MOV W4, W0
001E66  FA8000     ULNK
001E68  060000     RETURN
2514:              
2515:              #endif /* configUSE_TRACE_FACILITY */
2516:              /*-----------------------------------------------------------*/
2517:              
2518:              #if ( configUSE_TRACE_FACILITY == 1 )
2519:              
2520:              	void vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle )
2521:              	{
001E6A  FA0006     LNK #0x6
001E6C  980710     MOV W0, [W14+2]
001E6E  980721     MOV W1, [W14+4]
2522:              	TCB_t *pxTCB;
2523:              
2524:              		if( xTask != NULL )
001E70  90021E     MOV [W14+2], W4
001E72  520FE0     SUB W4, #0x0, [W15]
001E74  320005     BRA Z, 0x1E80
2525:              		{
2526:              			pxTCB = ( TCB_t * ) xTask;
001E76  90021E     MOV [W14+2], W4
001E78  780F04     MOV W4, [W14]
2527:              			pxTCB->uxTaskNumber = uxHandle;
001E7A  78021E     MOV [W14], W4
001E7C  9002AE     MOV [W14+4], W5
001E7E  981235     MOV W5, [W4+38]
2528:              		}
2529:              	}
001E80  FA8000     ULNK
001E82  060000     RETURN
2530:              
2531:              #endif /* configUSE_TRACE_FACILITY */
2532:              
2533:              /*
2534:               * -----------------------------------------------------------
2535:               * The Idle task.
2536:               * ----------------------------------------------------------
2537:               *
2538:               * The portTASK_FUNCTION() macro is used to allow port/compiler specific
2539:               * language extensions.  The equivalent prototype for this function is:
2540:               *
2541:               * void prvIdleTask( void *pvParameters );
2542:               *
2543:               */
2544:              static portTASK_FUNCTION( prvIdleTask, pvParameters )
2545:              {
001E84  FA0002     LNK #0x2
001E86  780F00     MOV W0, [W14]
001E88  370001     BRA 0x1E8C
2546:              	/* Stop warnings. */
2547:              	( void ) pvParameters;
2548:              
2549:              	for( ;; )
2550:              	{
2551:              		/* See if any tasks have been deleted. */
2552:              		prvCheckTasksWaitingTermination();
001E8C  07006B     RCALL prvCheckTasksWaitingTermination
2553:              
2554:              		#if ( configUSE_PREEMPTION == 0 )
2555:              		{
2556:              			/* If we are not using preemption we keep forcing a task switch to
2557:              			see if any other task has become available.  If we are using
2558:              			preemption we don't need to do this as any task becoming available
2559:              			will automatically get the processor anyway. */
2560:              			taskYIELD();
2561:              		}
2562:              		#endif /* configUSE_PREEMPTION */
2563:              
2564:              		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
2565:              		{
2566:              			/* When using preemption tasks of equal priority will be
2567:              			timesliced.  If a task that is sharing the idle priority is ready
2568:              			to run then the idle task should yield before the end of the
2569:              			timeslice.
2570:              
2571:              			A critical region is not required here as we are just reading from
2572:              			the list, and an occasional incorrect value will not matter.  If
2573:              			the ready list at the idle priority contains more than one task
2574:              			then a task other than the idle task is ready to execute. */
2575:              			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
001E8E  82FA24     MOV pxReadyTasksLists, W4
001E90  520FE1     SUB W4, #0x1, [W15]
001E92  36FFFB     BRA LEU, 0x1E8A
2576:              			{
2577:              				taskYIELD();
001E94  024F06     CALL _vPortYield
001E96  000000     NOP
001E98  000000     NOP
2578:              			}
2579:              			else
2580:              			{
2581:              				mtCOVERAGE_TEST_MARKER();
2582:              			}
2583:              		}
2584:              		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
2585:              
2586:              		#if ( configUSE_IDLE_HOOK == 1 )
2587:              		{
2588:              			extern void vApplicationIdleHook( void );
2589:              
2590:              			/* Call the user defined function from within the idle task.  This
2591:              			allows the application designer to add background functionality
2592:              			without the overhead of a separate task.
2593:              			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
2594:              			CALL A FUNCTION THAT MIGHT BLOCK. */
2595:              			vApplicationIdleHook();
2596:              		}
2597:              		#endif /* configUSE_IDLE_HOOK */
2598:              
2599:              		/* This conditional compilation should use inequality to 0, not equality
2600:              		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
2601:              		user defined low power mode	implementations require
2602:              		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
2603:              		#if ( configUSE_TICKLESS_IDLE != 0 )
2604:              		{
2605:              		TickType_t xExpectedIdleTime;
2606:              
2607:              			/* It is not desirable to suspend then resume the scheduler on
2608:              			each iteration of the idle task.  Therefore, a preliminary
2609:              			test of the expected idle time is performed without the
2610:              			scheduler suspended.  The result here is not necessarily
2611:              			valid. */
2612:              			xExpectedIdleTime = prvGetExpectedIdleTime();
2613:              
2614:              			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2615:              			{
2616:              				vTaskSuspendAll();
2617:              				{
2618:              					/* Now the scheduler is suspended, the expected idle
2619:              					time can be sampled again, and this time its value can
2620:              					be used. */
2621:              					configASSERT( xNextTaskUnblockTime >= xTickCount );
2622:              					xExpectedIdleTime = prvGetExpectedIdleTime();
2623:              
2624:              					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
2625:              					{
2626:              						traceLOW_POWER_IDLE_BEGIN();
2627:              						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
2628:              						traceLOW_POWER_IDLE_END();
2629:              					}
2630:              					else
2631:              					{
2632:              						mtCOVERAGE_TEST_MARKER();
2633:              					}
2634:              				}
2635:              				( void ) xTaskResumeAll();
2636:              			}
2637:              			else
2638:              			{
2639:              				mtCOVERAGE_TEST_MARKER();
2640:              			}
2641:              		}
2642:              		#endif /* configUSE_TICKLESS_IDLE */
2643:              	}
001E8A  000000     NOP
001E9A  37FFF8     BRA 0x1E8C
2644:              }
2645:              /*-----------------------------------------------------------*/
2646:              
2647:              #if configUSE_TICKLESS_IDLE != 0
2648:              
2649:              	eSleepModeStatus eTaskConfirmSleepModeStatus( void )
2650:              	{
2651:              	eSleepModeStatus eReturn = eStandardSleep;
2652:              
2653:              		if( listCURRENT_LIST_LENGTH( &xPendingReadyList ) != 0 )
2654:              		{
2655:              			/* A task was made ready while the scheduler was suspended. */
2656:              			eReturn = eAbortSleep;
2657:              		}
2658:              		else if( xYieldPending != pdFALSE )
2659:              		{
2660:              			/* A yield was pended while the scheduler was suspended. */
2661:              			eReturn = eAbortSleep;
2662:              		}
2663:              		else
2664:              		{
2665:              			#if configUSE_TIMERS == 0
2666:              			{
2667:              				/* The idle task exists in addition to the application tasks. */
2668:              				const UBaseType_t uxNonApplicationTasks = 1;
2669:              
2670:              				/* If timers are not being used and all the tasks are in the
2671:              				suspended list (which might mean they have an infinite block
2672:              				time rather than actually being suspended) then it is safe to
2673:              				turn all clocks off and just wait for external interrupts. */
2674:              				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == ( uxCurrentNumberOfTasks - uxNonApplicationTasks ) )
2675:              				{
2676:              					eReturn = eNoTasksWaitingTimeout;
2677:              				}
2678:              				else
2679:              				{
2680:              					mtCOVERAGE_TEST_MARKER();
2681:              				}
2682:              			}
2683:              			#endif /* configUSE_TIMERS */
2684:              		}
2685:              
2686:              		return eReturn;
2687:              	}
2688:              #endif /* configUSE_TICKLESS_IDLE */
2689:              /*-----------------------------------------------------------*/
2690:              
2691:              static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2692:              {
001E9C  FA000C     LNK #0xC
001E9E  980710     MOV W0, [W14+2]
001EA0  980721     MOV W1, [W14+4]
001EA2  980732     MOV W2, [W14+6]
001EA4  980743     MOV W3, [W14+8]
001EA6  980754     MOV W4, [W14+10]
2693:              UBaseType_t x;
2694:              
2695:              	/* Store the task name in the TCB. */
2696:              	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
001EA8  EB0200     CLR W4
001EAA  780F04     MOV W4, [W14]
001EAC  37000D     BRA 0x1EC8
001EC6  E80F1E     INC [W14], [W14]
001EC8  78021E     MOV [W14], W4
001ECA  520FE7     SUB W4, #0x7, [W15]
001ECC  36FFF0     BRA LEU, 0x1EAE
001ECE  370001     BRA 0x1ED2
2697:              	{
2698:              		pxTCB->pcTaskName[ x ] = pcName[ x ];
001EAE  90022E     MOV [W14+4], W4
001EB0  42021E     ADD W4, [W14], W4
001EB2  784214     MOV.B [W4], W4
001EB4  90029E     MOV [W14+2], W5
001EB6  42829E     ADD W5, [W14], W5
001EB8  4282FA     ADD W5, #0x1A, W5
001EBA  784A84     MOV.B W4, [W5]
2699:              
2700:              		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
2701:              		configMAX_TASK_NAME_LEN characters just in case the memory after the
2702:              		string is not accessible (extremely unlikely). */
2703:              		if( pcName[ x ] == 0x00 )
001EBC  90022E     MOV [W14+4], W4
001EBE  42021E     ADD W4, [W14], W4
001EC0  784214     MOV.B [W4], W4
001EC2  524FE0     SUB.B W4, #0x0, [W15]
001EC4  320005     BRA Z, 0x1ED0
2704:              		{
2705:              			break;
001ED0  000000     NOP
2706:              		}
2707:              		else
2708:              		{
2709:              			mtCOVERAGE_TEST_MARKER();
2710:              		}
2711:              	}
2712:              
2713:              	/* Ensure the name string is terminated in the case that the string length
2714:              	was greater or equal to configMAX_TASK_NAME_LEN. */
2715:              	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
001ED2  90029E     MOV [W14+2], W5
001ED4  EB4200     CLR.B W4
001ED6  986294     MOV.B W4, [W5+33]
2716:              
2717:              	/* This is used as an array index so must ensure it's not too large.  First
2718:              	remove the privilege bit if one is present. */
2719:              	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
001ED8  90023E     MOV [W14+6], W4
001EDA  520FE4     SUB W4, #0x4, [W15]
001EDC  360002     BRA LEU, 0x1EE2
2720:              	{
2721:              		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
001EDE  200044     MOV #0x4, W4
001EE0  980734     MOV W4, [W14+6]
2722:              	}
2723:              	else
2724:              	{
2725:              		mtCOVERAGE_TEST_MARKER();
2726:              	}
2727:              
2728:              	pxTCB->uxPriority = uxPriority;
001EE2  90021E     MOV [W14+2], W4
001EE4  9002BE     MOV [W14+6], W5
001EE6  980A35     MOV W5, [W4+22]
2729:              	#if ( configUSE_MUTEXES == 1 )
2730:              	{
2731:              		pxTCB->uxBasePriority = uxPriority;
001EE8  90021E     MOV [W14+2], W4
001EEA  9002BE     MOV [W14+6], W5
001EEC  981245     MOV W5, [W4+40]
2732:              	}
2733:              	#endif /* configUSE_MUTEXES */
2734:              
2735:              	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
001EEE  90021E     MOV [W14+2], W4
001EF0  E88204     INC2 W4, W4
001EF2  780004     MOV W4, W0
001EF4  024B60     CALL vListInitialiseItem
001EF6  000000     NOP
2736:              	vListInitialiseItem( &( pxTCB->xEventListItem ) );
001EF8  90021E     MOV [W14+2], W4
001EFA  42026C     ADD W4, #0xC, W4
001EFC  780004     MOV W4, W0
001EFE  024B60     CALL vListInitialiseItem
001F00  000000     NOP
2737:              
2738:              	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
2739:              	back to	the containing TCB from a generic item in a list. */
2740:              	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
001F02  90021E     MOV [W14+2], W4
001F04  90029E     MOV [W14+2], W5
001F06  980245     MOV W5, [W4+8]
2741:              
2742:              	/* Event lists are always in priority order. */
2743:              	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
001F08  90023E     MOV [W14+6], W4
001F0A  1202E5     SUBR W4, #0x5, W5
001F0C  90021E     MOV [W14+2], W4
001F0E  980265     MOV W5, [W4+12]
2744:              	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
001F10  90021E     MOV [W14+2], W4
001F12  90029E     MOV [W14+2], W5
001F14  980A15     MOV W5, [W4+18]
2745:              
2746:              	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
2747:              	{
2748:              		pxTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
2749:              	}
2750:              	#endif /* portCRITICAL_NESTING_IN_TCB */
2751:              
2752:              	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
2753:              	{
2754:              		pxTCB->pxTaskTag = NULL;
2755:              	}
2756:              	#endif /* configUSE_APPLICATION_TASK_TAG */
2757:              
2758:              	#if ( configGENERATE_RUN_TIME_STATS == 1 )
2759:              	{
2760:              		pxTCB->ulRunTimeCounter = 0UL;
2761:              	}
2762:              	#endif /* configGENERATE_RUN_TIME_STATS */
2763:              
2764:              	#if ( portUSING_MPU_WRAPPERS == 1 )
2765:              	{
2766:              		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
2767:              	}
2768:              	#else /* portUSING_MPU_WRAPPERS */
2769:              	{
2770:              		( void ) xRegions;
2771:              		( void ) usStackDepth;
2772:              	}
2773:              	#endif /* portUSING_MPU_WRAPPERS */
2774:              
2775:              	#if ( configUSE_NEWLIB_REENTRANT == 1 )
2776:              	{
2777:              		/* Initialise this task's Newlib reent structure. */
2778:              		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
2779:              	}
2780:              	#endif /* configUSE_NEWLIB_REENTRANT */
2781:              }
001F16  FA8000     ULNK
001F18  060000     RETURN
2782:              /*-----------------------------------------------------------*/
2783:              
2784:              #if ( portUSING_MPU_WRAPPERS == 1 )
2785:              
2786:              	void vTaskAllocateMPURegions( TaskHandle_t xTaskToModify, const MemoryRegion_t * const xRegions )
2787:              	{
2788:              	TCB_t *pxTCB;
2789:              
2790:              		/* If null is passed in here then we are deleting ourselves. */
2791:              		pxTCB = prvGetTCBFromHandle( xTaskToModify );
2792:              
2793:                      vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
2794:              	}
2795:              
2796:              #endif /* portUSING_MPU_WRAPPERS */
2797:              /*-----------------------------------------------------------*/
2798:              
2799:              static void prvInitialiseTaskLists( void )
2800:              {
001F1A  FA0002     LNK #0x2
2801:              UBaseType_t uxPriority;
2802:              
2803:              	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
001F1C  EB0200     CLR W4
001F1E  780F04     MOV W4, [W14]
001F20  370009     BRA 0x1F34
001F32  E80F1E     INC [W14], [W14]
001F34  78021E     MOV [W14], W4
001F36  520FE4     SUB W4, #0x4, [W15]
001F38  36FFF4     BRA LEU, 0x1F22
2804:              	{
2805:              		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
001F22  78021E     MOV [W14], W4
001F24  B922EA     MUL.SU W4, #10, W4
001F26  780284     MOV W4, W5
001F28  25F444     MOV #0x5F44, W4
001F2A  428204     ADD W5, W4, W4
001F2C  780004     MOV W4, W0
001F2E  024B2E     CALL vListInitialise
001F30  000000     NOP
2806:              	}
2807:              
2808:              	vListInitialise( &xDelayedTaskList1 );
001F3A  25F760     MOV #0x5F76, W0
001F3C  024B2E     CALL vListInitialise
001F3E  000000     NOP
2809:              	vListInitialise( &xDelayedTaskList2 );
001F40  25F800     MOV #0x5F80, W0
001F42  024B2E     CALL vListInitialise
001F44  000000     NOP
2810:              	vListInitialise( &xPendingReadyList );
001F46  25F8E0     MOV #0x5F8E, W0
001F48  024B2E     CALL vListInitialise
001F4A  000000     NOP
2811:              
2812:              	#if ( INCLUDE_vTaskDelete == 1 )
2813:              	{
2814:              		vListInitialise( &xTasksWaitingTermination );
001F4C  25F980     MOV #0x5F98, W0
001F4E  024B2E     CALL vListInitialise
001F50  000000     NOP
2815:              	}
2816:              	#endif /* INCLUDE_vTaskDelete */
2817:              
2818:              	#if ( INCLUDE_vTaskSuspend == 1 )
2819:              	{
2820:              		vListInitialise( &xSuspendedTaskList );
001F52  25FA40     MOV #0x5FA4, W0
001F54  024B2E     CALL vListInitialise
001F56  000000     NOP
2821:              	}
2822:              	#endif /* INCLUDE_vTaskSuspend */
2823:              
2824:              	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
2825:              	using list2. */
2826:              	pxDelayedTaskList = &xDelayedTaskList1;
001F58  25F764     MOV #0x5F76, W4
001F5A  8AFC54     MOV W4, pxDelayedTaskList
2827:              	pxOverflowDelayedTaskList = &xDelayedTaskList2;
001F5C  25F804     MOV #0x5F80, W4
001F5E  8AFC64     MOV W4, pxOverflowDelayedTaskList
2828:              }
001F60  FA8000     ULNK
001F62  060000     RETURN
2829:              /*-----------------------------------------------------------*/
2830:              
2831:              static void prvCheckTasksWaitingTermination( void )
2832:              {
001F64  FA0004     LNK #0x4
2833:              	#if ( INCLUDE_vTaskDelete == 1 )
2834:              	{
2835:              		BaseType_t xListIsEmpty;
2836:              
2837:              		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
2838:              		too often in the idle task. */
2839:              		while( uxTasksDeleted > ( UBaseType_t ) 0U )
001F66  370020     BRA 0x1FA8
001FA8  82FD14     MOV uxTasksDeleted, W4
001FAA  520FE0     SUB W4, #0x0, [W15]
001FAC  3AFFDD     BRA NZ, 0x1F68
2840:              		{
2841:              			vTaskSuspendAll();
001F68  07FCDF     RCALL vTaskSuspendAll
2842:              			{
2843:              				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
001F6A  82FCC4     MOV xTasksWaitingTermination, W4
001F6C  A7F004     BTSC W4, #15
001F6E  EA0204     NEG W4, W4
001F70  E90F04     DEC W4, [W14]
001F72  78021E     MOV [W14], W4
001F74  DE224F     LSR W4, #15, W4
001F76  780F04     MOV W4, [W14]
2844:              			}
2845:              			( void ) xTaskResumeAll();
001F78  07FCDD     RCALL xTaskResumeAll
2846:              
2847:              			if( xListIsEmpty == pdFALSE )
001F7A  78021E     MOV [W14], W4
001F7C  520FE0     SUB W4, #0x0, [W15]
001F7E  3A0014     BRA NZ, 0x1FA8
2848:              			{
2849:              				TCB_t *pxTCB;
2850:              
2851:              				taskENTER_CRITICAL();
001F80  02497A     CALL vPortEnterCritical
001F82  000000     NOP
2852:              				{
2853:              					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
001F84  82FCF4     MOV 0x5F9E, W4
001F86  900234     MOV [W4+6], W4
001F88  980714     MOV W4, [W14+2]
2854:              					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
001F8A  90021E     MOV [W14+2], W4
001F8C  E88204     INC2 W4, W4
001F8E  780004     MOV W4, W0
001F90  024C0E     CALL uxListRemove
001F92  000000     NOP
2855:              					--uxCurrentNumberOfTasks;
001F94  82FD74     MOV uxCurrentNumberOfTasks, W4
001F96  E90204     DEC W4, W4
001F98  8AFD74     MOV W4, uxCurrentNumberOfTasks
2856:              					--uxTasksDeleted;
001F9A  82FD14     MOV uxTasksDeleted, W4
001F9C  E90204     DEC W4, W4
001F9E  8AFD14     MOV W4, uxTasksDeleted
2857:              				}
2858:              				taskEXIT_CRITICAL();
001FA0  02498E     CALL vPortExitCritical
001FA2  000000     NOP
2859:              
2860:              				prvDeleteTCB( pxTCB );
001FA4  90001E     MOV [W14+2], W0
001FA6  070109     RCALL prvDeleteTCB
2861:              			}
2862:              			else
2863:              			{
2864:              				mtCOVERAGE_TEST_MARKER();
2865:              			}
2866:              		}
2867:              	}
2868:              	#endif /* vTaskDelete */
2869:              }
001FAE  FA8000     ULNK
001FB0  060000     RETURN
2870:              /*-----------------------------------------------------------*/
2871:              
2872:              static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
2873:              {
001FB2  FA0002     LNK #0x2
001FB4  780F00     MOV W0, [W14]
2874:              	/* The list item will be inserted in wake time order. */
2875:              	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
001FB6  82FA14     MOV pxCurrentTCB, W4
001FB8  78029E     MOV [W14], W5
001FBA  980215     MOV W5, [W4+2]
2876:              
2877:              	if( xTimeToWake < xTickCount )
001FBC  82FD84     MOV xTickCount, W4
001FBE  78029E     MOV [W14], W5
001FC0  528F84     SUB W5, W4, [W15]
001FC2  310008     BRA C, 0x1FD4
2878:              	{
2879:              		/* Wake time has overflowed.  Place this item in the overflow list. */
2880:              		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
001FC4  82FA14     MOV pxCurrentTCB, W4
001FC6  E88284     INC2 W4, W5
001FC8  82FC64     MOV pxOverflowDelayedTaskList, W4
001FCA  780085     MOV W5, W1
001FCC  780004     MOV W4, W0
001FCE  024BAA     CALL vListInsert
001FD0  000000     NOP
001FD2  37000D     BRA 0x1FEE
2881:              	}
2882:              	else
2883:              	{
2884:              		/* The wake time has not overflowed, so the current block list is used. */
2885:              		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
001FD4  82FA14     MOV pxCurrentTCB, W4
001FD6  E88284     INC2 W4, W5
001FD8  82FC54     MOV pxDelayedTaskList, W4
001FDA  780085     MOV W5, W1
001FDC  780004     MOV W4, W0
001FDE  024BAA     CALL vListInsert
001FE0  000000     NOP
2886:              
2887:              		/* If the task entering the blocked state was placed at the head of the
2888:              		list of blocked tasks then xNextTaskUnblockTime needs to be updated
2889:              		too. */
2890:              		if( xTimeToWake < xNextTaskUnblockTime )
001FE2  830304     MOV xNextTaskUnblockTime, W4
001FE4  78029E     MOV [W14], W5
001FE6  528F84     SUB W5, W4, [W15]
001FE8  310002     BRA C, 0x1FEE
2891:              		{
2892:              			xNextTaskUnblockTime = xTimeToWake;
001FEA  78021E     MOV [W14], W4
001FEC  8B0304     MOV W4, xNextTaskUnblockTime
2893:              		}
2894:              		else
2895:              		{
2896:              			mtCOVERAGE_TEST_MARKER();
2897:              		}
2898:              	}
2899:              }
001FEE  FA8000     ULNK
001FF0  060000     RETURN
2900:              /*-----------------------------------------------------------*/
2901:              
2902:              static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
2903:              {
001FF2  FA0006     LNK #0x6
001FF4  980710     MOV W0, [W14+2]
001FF6  980721     MOV W1, [W14+4]
2904:              TCB_t *pxNewTCB;
2905:              
2906:              	/* Allocate space for the TCB.  Where the memory comes from depends on
2907:              	the implementation of the port malloc function. */
2908:              	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
001FF8  2002A0     MOV #0x2A, W0
001FFA  024240     CALL pvPortMalloc
001FFC  000000     NOP
001FFE  780200     MOV W0, W4
002000  780F04     MOV W4, [W14]
2909:              
2910:              	if( pxNewTCB != NULL )
002002  78021E     MOV [W14], W4
002004  520FE0     SUB W4, #0x0, [W15]
002006  320021     BRA Z, 0x204A
2911:              	{
2912:              		/* Allocate space for the stack used by the task being created.
2913:              		The base of the stack memory stored in the TCB so the task can
2914:              		be deleted later if required. */
2915:              		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
002008  90022E     MOV [W14+4], W4
00200A  520FE0     SUB W4, #0x0, [W15]
00200C  3A0007     BRA NZ, 0x201C
00200E  90021E     MOV [W14+2], W4
002010  420204     ADD W4, W4, W4
002012  780004     MOV W4, W0
002014  024240     CALL pvPortMalloc
002016  000000     NOP
002018  780200     MOV W0, W4
00201A  370001     BRA 0x201E
00201C  90022E     MOV [W14+4], W4
00201E  78029E     MOV [W14], W5
002020  980AC4     MOV W4, [W5+24]
2916:              
2917:              		if( pxNewTCB->pxStack == NULL )
002022  78021E     MOV [W14], W4
002024  900A44     MOV [W4+24], W4
002026  520FE0     SUB W4, #0x0, [W15]
002028  3A0006     BRA NZ, 0x2036
2918:              		{
2919:              			/* Could not allocate the stack.  Delete the allocated TCB. */
2920:              			vPortFree( pxNewTCB );
00202A  78001E     MOV [W14], W0
00202C  024330     CALL vPortFree
00202E  000000     NOP
2921:              			pxNewTCB = NULL;
002030  EB0200     CLR W4
002032  780F04     MOV W4, [W14]
002034  37000A     BRA 0x204A
2922:              		}
2923:              		else
2924:              		{
2925:              			/* Avoid dependency on memset() if it is not required. */
2926:              			#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2927:              			{
2928:              				/* Just to help debugging. */
2929:              				( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
002036  90021E     MOV [W14+2], W4
002038  420204     ADD W4, W4, W4
00203A  780284     MOV W4, W5
00203C  78021E     MOV [W14], W4
00203E  900A44     MOV [W4+24], W4
002040  780105     MOV W5, W2
002042  200A51     MOV #0xA5, W1
002044  780004     MOV W4, W0
002046  02083E     CALL _memset
002048  000000     NOP
2930:              			}
2931:              			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
2932:              		}
2933:              	}
2934:              
2935:              	return pxNewTCB;
00204A  78021E     MOV [W14], W4
2936:              }
00204C  780004     MOV W4, W0
00204E  FA8000     ULNK
002050  060000     RETURN
2937:              /*-----------------------------------------------------------*/
2938:              
2939:              #if ( configUSE_TRACE_FACILITY == 1 )
2940:              
2941:              	static UBaseType_t prvListTaskWithinSingleList( TaskStatus_t *pxTaskStatusArray, List_t *pxList, eTaskState eState )
2942:              	{
002052  FA0010     LNK #0x10
002054  781F88     MOV W8, [W15++]
002056  980750     MOV W0, [W14+10]
002058  980761     MOV W1, [W14+12]
00205A  980772     MOV W2, [W14+14]
2943:              	volatile TCB_t *pxNextTCB, *pxFirstTCB;
2944:              	UBaseType_t uxTask = 0;
00205C  EB0200     CLR W4
00205E  780F04     MOV W4, [W14]
2945:              
2946:              		if( listCURRENT_LIST_LENGTH( pxList ) > ( UBaseType_t ) 0 )
002060  90026E     MOV [W14+12], W4
002062  780214     MOV [W4], W4
002064  520FE0     SUB W4, #0x0, [W15]
002066  320077     BRA Z, 0x2156
2947:              		{
2948:              			listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
002068  90026E     MOV [W14+12], W4
00206A  980714     MOV W4, [W14+2]
00206C  90021E     MOV [W14+2], W4
00206E  900214     MOV [W4+2], W4
002070  900294     MOV [W4+2], W5
002072  90021E     MOV [W14+2], W4
002074  980215     MOV W5, [W4+2]
002076  90021E     MOV [W14+2], W4
002078  900294     MOV [W4+2], W5
00207A  90021E     MOV [W14+2], W4
00207C  420264     ADD W4, #0x4, W4
00207E  528F84     SUB W5, W4, [W15]
002080  3A0005     BRA NZ, 0x208C
002082  90021E     MOV [W14+2], W4
002084  900214     MOV [W4+2], W4
002086  900294     MOV [W4+2], W5
002088  90021E     MOV [W14+2], W4
00208A  980215     MOV W5, [W4+2]
00208C  90021E     MOV [W14+2], W4
00208E  900214     MOV [W4+2], W4
002090  900234     MOV [W4+6], W4
002092  980724     MOV W4, [W14+4]
2949:              
2950:              			/* Populate an TaskStatus_t structure within the
2951:              			pxTaskStatusArray array for each task that is referenced from
2952:              			pxList.  See the definition of TaskStatus_t in task.h for the
2953:              			meaning of each TaskStatus_t structure member. */
2954:              			do
2955:              			{
2956:              				listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
002094  9002EE     MOV [W14+12], W5
002096  980735     MOV W5, [W14+6]
002098  90023E     MOV [W14+6], W4
00209A  900214     MOV [W4+2], W4
00209C  900294     MOV [W4+2], W5
00209E  90023E     MOV [W14+6], W4
0020A0  980215     MOV W5, [W4+2]
0020A2  90023E     MOV [W14+6], W4
0020A4  900294     MOV [W4+2], W5
0020A6  90023E     MOV [W14+6], W4
0020A8  420264     ADD W4, #0x4, W4
0020AA  528F84     SUB W5, W4, [W15]
0020AC  3A0005     BRA NZ, 0x20B8
0020AE  90023E     MOV [W14+6], W4
0020B0  900214     MOV [W4+2], W4
0020B2  900294     MOV [W4+2], W5
0020B4  90023E     MOV [W14+6], W4
0020B6  980215     MOV W5, [W4+2]
0020B8  90023E     MOV [W14+6], W4
0020BA  900214     MOV [W4+2], W4
0020BC  900234     MOV [W4+6], W4
0020BE  980744     MOV W4, [W14+8]
2957:              
2958:              				pxTaskStatusArray[ uxTask ].xHandle = ( TaskHandle_t ) pxNextTCB;
0020C0  78021E     MOV [W14], W4
0020C2  B922F2     MUL.SU W4, #18, W4
0020C4  9002DE     MOV [W14+10], W5
0020C6  428204     ADD W5, W4, W4
0020C8  9002CE     MOV [W14+8], W5
0020CA  780A05     MOV W5, [W4]
2959:              				pxTaskStatusArray[ uxTask ].pcTaskName = ( const char * ) &( pxNextTCB->pcTaskName [ 0 ] );
0020CC  78021E     MOV [W14], W4
0020CE  B922F2     MUL.SU W4, #18, W4
0020D0  9002DE     MOV [W14+10], W5
0020D2  428204     ADD W5, W4, W4
0020D4  9002CE     MOV [W14+8], W5
0020D6  4282FA     ADD W5, #0x1A, W5
0020D8  980215     MOV W5, [W4+2]
2960:              				pxTaskStatusArray[ uxTask ].xTaskNumber = pxNextTCB->uxTCBNumber;
0020DA  78021E     MOV [W14], W4
0020DC  B922F2     MUL.SU W4, #18, W4
0020DE  9002DE     MOV [W14+10], W5
0020E0  428204     ADD W5, W4, W4
0020E2  9002CE     MOV [W14+8], W5
0020E4  9012A5     MOV [W5+36], W5
0020E6  980225     MOV W5, [W4+4]
2961:              				pxTaskStatusArray[ uxTask ].eCurrentState = eState;
0020E8  78021E     MOV [W14], W4
0020EA  B922F2     MUL.SU W4, #18, W4
0020EC  9002DE     MOV [W14+10], W5
0020EE  428204     ADD W5, W4, W4
0020F0  9002FE     MOV [W14+14], W5
0020F2  980235     MOV W5, [W4+6]
2962:              				pxTaskStatusArray[ uxTask ].uxCurrentPriority = pxNextTCB->uxPriority;
0020F4  78021E     MOV [W14], W4
0020F6  B922F2     MUL.SU W4, #18, W4
0020F8  9002DE     MOV [W14+10], W5
0020FA  428204     ADD W5, W4, W4
0020FC  9002CE     MOV [W14+8], W5
0020FE  900AB5     MOV [W5+22], W5
002100  980245     MOV W5, [W4+8]
2963:              
2964:              				#if ( INCLUDE_vTaskSuspend == 1 )
2965:              				{
2966:              					/* If the task is in the suspended list then there is a chance
2967:              					it is actually just blocked indefinitely - so really it should
2968:              					be reported as being in the Blocked state. */
2969:              					if( eState == eSuspended )
002102  90027E     MOV [W14+14], W4
002104  520FE3     SUB W4, #0x3, [W15]
002106  3A000A     BRA NZ, 0x211C
2970:              					{
2971:              						if( listLIST_ITEM_CONTAINER( &( pxNextTCB->xEventListItem ) ) != NULL )
002108  90024E     MOV [W14+8], W4
00210A  900A24     MOV [W4+20], W4
00210C  520FE0     SUB W4, #0x0, [W15]
00210E  320006     BRA Z, 0x211C
2972:              						{
2973:              							pxTaskStatusArray[ uxTask ].eCurrentState = eBlocked;
002110  78021E     MOV [W14], W4
002112  B922F2     MUL.SU W4, #18, W4
002114  9002DE     MOV [W14+10], W5
002116  428204     ADD W5, W4, W4
002118  200025     MOV #0x2, W5
00211A  980235     MOV W5, [W4+6]
2974:              						}
2975:              					}
2976:              				}
2977:              				#endif /* INCLUDE_vTaskSuspend */
2978:              
2979:              				#if ( configUSE_MUTEXES == 1 )
2980:              				{
2981:              					pxTaskStatusArray[ uxTask ].uxBasePriority = pxNextTCB->uxBasePriority;
00211C  78021E     MOV [W14], W4
00211E  B922F2     MUL.SU W4, #18, W4
002120  9002DE     MOV [W14+10], W5
002122  428204     ADD W5, W4, W4
002124  9002CE     MOV [W14+8], W5
002126  9012C5     MOV [W5+40], W5
002128  980255     MOV W5, [W4+10]
2982:              				}
2983:              				#else
2984:              				{
2985:              					pxTaskStatusArray[ uxTask ].uxBasePriority = 0;
2986:              				}
2987:              				#endif
2988:              
2989:              				#if ( configGENERATE_RUN_TIME_STATS == 1 )
2990:              				{
2991:              					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = pxNextTCB->ulRunTimeCounter;
2992:              				}
2993:              				#else
2994:              				{
2995:              					pxTaskStatusArray[ uxTask ].ulRunTimeCounter = 0;
00212A  78021E     MOV [W14], W4
00212C  B922F2     MUL.SU W4, #18, W4
00212E  9002DE     MOV [W14+10], W5
002130  428304     ADD W5, W4, W6
002132  B82260     MUL.UU W4, #0, W4
002134  980364     MOV W4, [W6+12]
002136  980375     MOV W5, [W6+14]
2996:              				}
2997:              				#endif
2998:              
2999:              				#if ( portSTACK_GROWTH > 0 )
3000:              				{
3001:              					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxEndOfStack );
002138  78021E     MOV [W14], W4
00213A  B922F2     MUL.SU W4, #18, W4
00213C  9002DE     MOV [W14+10], W5
00213E  428404     ADD W5, W4, W8
002140  90024E     MOV [W14+8], W4
002142  901214     MOV [W4+34], W4
002144  780004     MOV W4, W0
002146  07000C     RCALL prvTaskCheckFreeStackSpace
002148  780200     MOV W0, W4
00214A  980C04     MOV W4, [W8+16]
3002:              				}
3003:              				#else
3004:              				{
3005:              					pxTaskStatusArray[ uxTask ].usStackHighWaterMark = prvTaskCheckFreeStackSpace( ( uint8_t * ) pxNextTCB->pxStack );
3006:              				}
3007:              				#endif
3008:              
3009:              				uxTask++;
00214C  E80F1E     INC [W14], [W14]
3010:              
3011:              			} while( pxNextTCB != pxFirstTCB );
00214E  9002CE     MOV [W14+8], W5
002150  90022E     MOV [W14+4], W4
002152  528F84     SUB W5, W4, [W15]
002154  3AFF9F     BRA NZ, 0x2094
3012:              		}
3013:              		else
3014:              		{
3015:              			mtCOVERAGE_TEST_MARKER();
3016:              		}
3017:              
3018:              		return uxTask;
002156  78021E     MOV [W14], W4
3019:              	}
002158  780004     MOV W4, W0
00215A  78044F     MOV [--W15], W8
00215C  FA8000     ULNK
00215E  060000     RETURN
3020:              
3021:              #endif /* configUSE_TRACE_FACILITY */
3022:              /*-----------------------------------------------------------*/
3023:              
3024:              #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
3025:              
3026:              	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
3027:              	{
002160  FA0006     LNK #0x6
002162  980720     MOV W0, [W14+4]
3028:              	uint32_t ulCount = 0U;
002164  B82260     MUL.UU W4, #0, W4
002166  BE8F04     MOV.D W4, [W14]
3029:              
3030:              		while( *pucStackByte == tskSTACK_FILL_BYTE )
002168  370007     BRA 0x2178
002178  90022E     MOV [W14+4], W4
00217A  784294     MOV.B [W4], W5
00217C  B3CA54     MOV.B #0xA5, W4
00217E  52CF84     SUB.B W5, W4, [W15]
002180  32FFF4     BRA Z, 0x216A
3031:              		{
3032:              			pucStackByte -= portSTACK_GROWTH;
00216A  90022E     MOV [W14+4], W4
00216C  E90204     DEC W4, W4
00216E  980724     MOV W4, [W14+4]
3033:              			ulCount++;
002170  200014     MOV #0x1, W4
002172  200005     MOV #0x0, W5
002174  420F1E     ADD W4, [W14], [W14]
002176  4A975E     ADDC W5, [++W14], [W14--]
3034:              		}
3035:              
3036:              		ulCount /= ( uint32_t ) sizeof( StackType_t );
002182  BE021E     MOV.D [W14], W4
002184  D10285     LSR W5, W5
002186  D38204     RRC W4, W4
002188  BE8F04     MOV.D W4, [W14]
3037:              
3038:              		return ( uint16_t ) ulCount;
00218A  78021E     MOV [W14], W4
3039:              	}
00218C  780004     MOV W4, W0
00218E  FA8000     ULNK
002190  060000     RETURN
3040:              
3041:              #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) */
3042:              /*-----------------------------------------------------------*/
3043:              
3044:              #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
3045:              
3046:              	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
3047:              	{
002192  FA0008     LNK #0x8
002194  980730     MOV W0, [W14+6]
3048:              	TCB_t *pxTCB;
3049:              	uint8_t *pucEndOfStack;
3050:              	UBaseType_t uxReturn;
3051:              
3052:              		pxTCB = prvGetTCBFromHandle( xTask );
002196  90023E     MOV [W14+6], W4
002198  520FE0     SUB W4, #0x0, [W15]
00219A  3A0002     BRA NZ, 0x21A0
00219C  82FA14     MOV pxCurrentTCB, W4
00219E  370001     BRA 0x21A2
0021A0  90023E     MOV [W14+6], W4
0021A2  780F04     MOV W4, [W14]
3053:              
3054:              		#if portSTACK_GROWTH < 0
3055:              		{
3056:              			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
3057:              		}
3058:              		#else
3059:              		{
3060:              			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
0021A4  78021E     MOV [W14], W4
0021A6  901214     MOV [W4+34], W4
0021A8  980714     MOV W4, [W14+2]
3061:              		}
3062:              		#endif
3063:              
3064:              		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
0021AA  90001E     MOV [W14+2], W0
0021AC  07FFD9     RCALL prvTaskCheckFreeStackSpace
0021AE  780200     MOV W0, W4
0021B0  980724     MOV W4, [W14+4]
3065:              
3066:              		return uxReturn;
0021B2  90022E     MOV [W14+4], W4
3067:              	}
0021B4  780004     MOV W4, W0
0021B6  FA8000     ULNK
0021B8  060000     RETURN
3068:              
3069:              #endif /* INCLUDE_uxTaskGetStackHighWaterMark */
3070:              /*-----------------------------------------------------------*/
3071:              
3072:              #if ( INCLUDE_vTaskDelete == 1 )
3073:              
3074:              	static void prvDeleteTCB( TCB_t *pxTCB )
3075:              	{
0021BA  FA0002     LNK #0x2
0021BC  780F00     MOV W0, [W14]
3076:              		/* This call is required specifically for the TriCore port.  It must be
3077:              		above the vPortFree() calls.  The call is also used by ports/demos that
3078:              		want to allocate and clean RAM statically. */
3079:              		portCLEAN_UP_TCB( pxTCB );
3080:              
3081:              		/* Free up the memory allocated by the scheduler for the task.  It is up to
3082:              		the task to free any memory allocated at the application level. */
3083:              		vPortFreeAligned( pxTCB->pxStack );
0021BE  78021E     MOV [W14], W4
0021C0  900A44     MOV [W4+24], W4
0021C2  780004     MOV W4, W0
0021C4  024330     CALL vPortFree
0021C6  000000     NOP
3084:              		vPortFree( pxTCB );
0021C8  78001E     MOV [W14], W0
0021CA  024330     CALL vPortFree
0021CC  000000     NOP
3085:              	}
0021CE  FA8000     ULNK
0021D0  060000     RETURN
3086:              
3087:              #endif /* INCLUDE_vTaskDelete */
3088:              /*-----------------------------------------------------------*/
3089:              
3090:              static void prvResetNextTaskUnblockTime( void )
3091:              {
0021D2  FA0002     LNK #0x2
3092:              TCB_t *pxTCB;
3093:              
3094:              	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
0021D4  82FC54     MOV pxDelayedTaskList, W4
0021D6  780214     MOV [W4], W4
0021D8  520FE0     SUB W4, #0x0, [W15]
0021DA  3A0003     BRA NZ, 0x21E2
3095:              	{
3096:              		/* The new current delayed list is empty.  Set
3097:              		xNextTaskUnblockTime to the maximum possible value so it is
3098:              		extremely unlikely that the
3099:              		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
3100:              		there is an item in the delayed list. */
3101:              		xNextTaskUnblockTime = portMAX_DELAY;
0021DC  EB8200     SETM W4
0021DE  8B0304     MOV W4, xNextTaskUnblockTime
0021E0  370007     BRA 0x21F0
3102:              	}
3103:              	else
3104:              	{
3105:              		/* The new current delayed list is not empty, get the value of
3106:              		the item at the head of the delayed list.  This is the time at
3107:              		which the task at the head of the delayed list should be removed
3108:              		from the Blocked state. */
3109:              		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
0021E2  82FC54     MOV pxDelayedTaskList, W4
0021E4  900234     MOV [W4+6], W4
0021E6  900234     MOV [W4+6], W4
0021E8  780F04     MOV W4, [W14]
3110:              		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
0021EA  78021E     MOV [W14], W4
0021EC  900214     MOV [W4+2], W4
0021EE  8B0304     MOV W4, xNextTaskUnblockTime
3111:              	}
3112:              }
0021F0  FA8000     ULNK
0021F2  060000     RETURN
3113:              /*-----------------------------------------------------------*/
3114:              
3115:              #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
3116:              
3117:              	TaskHandle_t xTaskGetCurrentTaskHandle( void )
3118:              	{
0021F4  FA0002     LNK #0x2
3119:              	TaskHandle_t xReturn;
3120:              
3121:              		/* A critical section is not required as this is not called from
3122:              		an interrupt and the current TCB will always be the same for any
3123:              		individual execution thread. */
3124:              		xReturn = pxCurrentTCB;
0021F6  82FA14     MOV pxCurrentTCB, W4
0021F8  780F04     MOV W4, [W14]
3125:              
3126:              		return xReturn;
0021FA  78021E     MOV [W14], W4
3127:              	}
0021FC  780004     MOV W4, W0
0021FE  FA8000     ULNK
002200  060000     RETURN
3128:              
3129:              #endif /* ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) ) */
3130:              /*-----------------------------------------------------------*/
3131:              
3132:              #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
3133:              
3134:              	BaseType_t xTaskGetSchedulerState( void )
3135:              	{
002202  FA0002     LNK #0x2
3136:              	BaseType_t xReturn;
3137:              
3138:              		if( xSchedulerRunning == pdFALSE )
002204  82FDA4     MOV xSchedulerRunning, W4
002206  520FE0     SUB W4, #0x0, [W15]
002208  3A0003     BRA NZ, 0x2210
3139:              		{
3140:              			xReturn = taskSCHEDULER_NOT_STARTED;
00220A  200014     MOV #0x1, W4
00220C  780F04     MOV W4, [W14]
00220E  370008     BRA 0x2220
3141:              		}
3142:              		else
3143:              		{
3144:              			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
002210  82FDF4     MOV uxSchedulerSuspended, W4
002212  520FE0     SUB W4, #0x0, [W15]
002214  3A0003     BRA NZ, 0x221C
3145:              			{
3146:              				xReturn = taskSCHEDULER_RUNNING;
002216  200024     MOV #0x2, W4
002218  780F04     MOV W4, [W14]
00221A  370002     BRA 0x2220
3147:              			}
3148:              			else
3149:              			{
3150:              				xReturn = taskSCHEDULER_SUSPENDED;
00221C  EB0200     CLR W4
00221E  780F04     MOV W4, [W14]
3151:              			}
3152:              		}
3153:              
3154:              		return xReturn;
002220  78021E     MOV [W14], W4
3155:              	}
002222  780004     MOV W4, W0
002224  FA8000     ULNK
002226  060000     RETURN
3156:              
3157:              #endif /* ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) ) */
3158:              /*-----------------------------------------------------------*/
3159:              
3160:              #if ( configUSE_MUTEXES == 1 )
3161:              
3162:              	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
3163:              	{
002228  FA0004     LNK #0x4
00222A  980710     MOV W0, [W14+2]
3164:              	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
00222C  90021E     MOV [W14+2], W4
00222E  780F04     MOV W4, [W14]
3165:              
3166:              		/* If the mutex was given back by an interrupt while the queue was
3167:              		locked then the mutex holder might now be NULL. */
3168:              		if( pxMutexHolder != NULL )
002230  90021E     MOV [W14+2], W4
002232  520FE0     SUB W4, #0x0, [W15]
002234  320037     BRA Z, 0x22A4
3169:              		{
3170:              			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
002236  78021E     MOV [W14], W4
002238  900AB4     MOV [W4+22], W5
00223A  82FA14     MOV pxCurrentTCB, W4
00223C  900A34     MOV [W4+22], W4
00223E  528F84     SUB W5, W4, [W15]
002240  310031     BRA C, 0x22A4
3171:              			{
3172:              				/* Adjust the mutex holder state to account for its new
3173:              				priority.  Only reset the event list item value if the value is
3174:              				not	being used for anything else. */
3175:              				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
002242  78021E     MOV [W14], W4
002244  900264     MOV [W4+12], W4
002246  520FE0     SUB W4, #0x0, [W15]
002248  350005     BRA LT, 0x2254
3176:              				{
3177:              					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00224A  82FA14     MOV pxCurrentTCB, W4
00224C  900A34     MOV [W4+22], W4
00224E  1202E5     SUBR W4, #0x5, W5
002250  78021E     MOV [W14], W4
002252  980265     MOV W5, [W4+12]
3178:              				}
3179:              				else
3180:              				{
3181:              					mtCOVERAGE_TEST_MARKER();
3182:              				}
3183:              
3184:              				/* If the task being modified is in the ready state it will need to
3185:              				be moved into a new list. */
3186:              				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
002254  78021E     MOV [W14], W4
002256  9002D4     MOV [W4+10], W5
002258  78021E     MOV [W14], W4
00225A  900A34     MOV [W4+22], W4
00225C  B923EA     MUL.SU W4, #10, W6
00225E  25F444     MOV #0x5F44, W4
002260  430204     ADD W6, W4, W4
002262  528F84     SUB W5, W4, [W15]
002264  3A001B     BRA NZ, 0x229C
3187:              				{
3188:              					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
002266  E8821E     INC2 [W14], W4
002268  780004     MOV W4, W0
00226A  024C0E     CALL uxListRemove
00226C  000000     NOP
3189:              					{
3190:              						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3191:              					}
3192:              					else
3193:              					{
3194:              						mtCOVERAGE_TEST_MARKER();
3195:              					}
3196:              
3197:              					/* Inherit the priority before being moved into the new list. */
3198:              					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
00226E  82FA14     MOV pxCurrentTCB, W4
002270  900AB4     MOV [W4+22], W5
002272  78021E     MOV [W14], W4
002274  980A35     MOV W5, [W4+22]
3199:              					prvAddTaskToReadyList( pxTCB );
002276  78021E     MOV [W14], W4
002278  900AB4     MOV [W4+22], W5
00227A  82FD94     MOV uxTopReadyPriority, W4
00227C  528F84     SUB W5, W4, [W15]
00227E  360003     BRA LEU, 0x2286
002280  78021E     MOV [W14], W4
002282  900A34     MOV [W4+22], W4
002284  8AFD94     MOV W4, uxTopReadyPriority
002286  E8829E     INC2 [W14], W5
002288  78021E     MOV [W14], W4
00228A  900A34     MOV [W4+22], W4
00228C  B923EA     MUL.SU W4, #10, W6
00228E  25F444     MOV #0x5F44, W4
002290  430204     ADD W6, W4, W4
002292  780085     MOV W5, W1
002294  780004     MOV W4, W0
002296  024B6E     CALL vListInsertEnd
002298  000000     NOP
00229A  370004     BRA 0x22A4
3200:              				}
3201:              				else
3202:              				{
3203:              					/* Just inherit the priority. */
3204:              					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
00229C  82FA14     MOV pxCurrentTCB, W4
00229E  900AB4     MOV [W4+22], W5
0022A0  78021E     MOV [W14], W4
0022A2  980A35     MOV W5, [W4+22]
3205:              				}
3206:              
3207:              				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
3208:              			}
3209:              			else
3210:              			{
3211:              				mtCOVERAGE_TEST_MARKER();
3212:              			}
3213:              		}
3214:              		else
3215:              		{
3216:              			mtCOVERAGE_TEST_MARKER();
3217:              		}
3218:              	}
0022A4  FA8000     ULNK
0022A6  060000     RETURN
3219:              
3220:              #endif /* configUSE_MUTEXES */
3221:              /*-----------------------------------------------------------*/
3222:              
3223:              #if ( configUSE_MUTEXES == 1 )
3224:              
3225:              	void vTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
3226:              	{
0022A8  FA0004     LNK #0x4
0022AA  980710     MOV W0, [W14+2]
3227:              	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
0022AC  90021E     MOV [W14+2], W4
0022AE  780F04     MOV W4, [W14]
3228:              
3229:              		if( pxMutexHolder != NULL )
0022B0  90021E     MOV [W14+2], W4
0022B2  520FE0     SUB W4, #0x0, [W15]
0022B4  320029     BRA Z, 0x2308
3230:              		{
3231:              			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
0022B6  78021E     MOV [W14], W4
0022B8  900AB4     MOV [W4+22], W5
0022BA  78021E     MOV [W14], W4
0022BC  901244     MOV [W4+40], W4
0022BE  528F84     SUB W5, W4, [W15]
0022C0  320023     BRA Z, 0x2308
3232:              			{
3233:              				/* We must be the running task to be able to give the mutex back.
3234:              				Remove ourselves from the ready list we currently appear in. */
3235:              				if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
0022C2  E8821E     INC2 [W14], W4
0022C4  780004     MOV W4, W0
0022C6  024C0E     CALL uxListRemove
0022C8  000000     NOP
3236:              				{
3237:              					taskRESET_READY_PRIORITY( pxTCB->uxPriority );
3238:              				}
3239:              				else
3240:              				{
3241:              					mtCOVERAGE_TEST_MARKER();
3242:              				}
3243:              
3244:              				/* Disinherit the priority before adding the task into the new
3245:              				ready list. */
3246:              				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
3247:              				pxTCB->uxPriority = pxTCB->uxBasePriority;
0022CA  78021E     MOV [W14], W4
0022CC  9012C4     MOV [W4+40], W5
0022CE  78021E     MOV [W14], W4
0022D0  980A35     MOV W5, [W4+22]
3248:              
3249:              				/* Only reset the event list item value if the value is not
3250:              				being used for anything else. */
3251:              				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
0022D2  78021E     MOV [W14], W4
0022D4  900264     MOV [W4+12], W4
0022D6  520FE0     SUB W4, #0x0, [W15]
0022D8  350005     BRA LT, 0x22E4
3252:              				{
3253:              					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0022DA  78021E     MOV [W14], W4
0022DC  900A34     MOV [W4+22], W4
0022DE  1202E5     SUBR W4, #0x5, W5
0022E0  78021E     MOV [W14], W4
0022E2  980265     MOV W5, [W4+12]
3254:              				}
3255:              				else
3256:              				{
3257:              					mtCOVERAGE_TEST_MARKER();
3258:              				}
3259:              				prvAddTaskToReadyList( pxTCB );
0022E4  78021E     MOV [W14], W4
0022E6  900AB4     MOV [W4+22], W5
0022E8  82FD94     MOV uxTopReadyPriority, W4
0022EA  528F84     SUB W5, W4, [W15]
0022EC  360003     BRA LEU, 0x22F4
0022EE  78021E     MOV [W14], W4
0022F0  900A34     MOV [W4+22], W4
0022F2  8AFD94     MOV W4, uxTopReadyPriority
0022F4  E8829E     INC2 [W14], W5
0022F6  78021E     MOV [W14], W4
0022F8  900A34     MOV [W4+22], W4
0022FA  B923EA     MUL.SU W4, #10, W6
0022FC  25F444     MOV #0x5F44, W4
0022FE  430204     ADD W6, W4, W4
002300  780085     MOV W5, W1
002302  780004     MOV W4, W0
002304  024B6E     CALL vListInsertEnd
002306  000000     NOP
3260:              			}
3261:              			else
3262:              			{
3263:              				mtCOVERAGE_TEST_MARKER();
3264:              			}
3265:              		}
3266:              		else
3267:              		{
3268:              			mtCOVERAGE_TEST_MARKER();
3269:              		}
3270:              	}
002308  FA8000     ULNK
00230A  060000     RETURN
3271:              
3272:              #endif /* configUSE_MUTEXES */
3273:              /*-----------------------------------------------------------*/
3274:              
3275:              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3276:              
3277:              	void vTaskEnterCritical( void )
3278:              	{
3279:              		portDISABLE_INTERRUPTS();
3280:              
3281:              		if( xSchedulerRunning != pdFALSE )
3282:              		{
3283:              			( pxCurrentTCB->uxCriticalNesting )++;
3284:              		}
3285:              		else
3286:              		{
3287:              			mtCOVERAGE_TEST_MARKER();
3288:              		}
3289:              	}
3290:              
3291:              #endif /* portCRITICAL_NESTING_IN_TCB */
3292:              /*-----------------------------------------------------------*/
3293:              
3294:              #if ( portCRITICAL_NESTING_IN_TCB == 1 )
3295:              
3296:              	void vTaskExitCritical( void )
3297:              	{
3298:              		if( xSchedulerRunning != pdFALSE )
3299:              		{
3300:              			if( pxCurrentTCB->uxCriticalNesting > 0U )
3301:              			{
3302:              				( pxCurrentTCB->uxCriticalNesting )--;
3303:              
3304:              				if( pxCurrentTCB->uxCriticalNesting == 0U )
3305:              				{
3306:              					portENABLE_INTERRUPTS();
3307:              				}
3308:              				else
3309:              				{
3310:              					mtCOVERAGE_TEST_MARKER();
3311:              				}
3312:              			}
3313:              			else
3314:              			{
3315:              				mtCOVERAGE_TEST_MARKER();
3316:              			}
3317:              		}
3318:              		else
3319:              		{
3320:              			mtCOVERAGE_TEST_MARKER();
3321:              		}
3322:              	}
3323:              
3324:              #endif /* portCRITICAL_NESTING_IN_TCB */
3325:              /*-----------------------------------------------------------*/
3326:              
3327:              #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3328:              
3329:              	void vTaskList( char * pcWriteBuffer )
3330:              	{
00230C  FA000A     LNK #0xA
00230E  980740     MOV W0, [W14+8]
3331:              	TaskStatus_t *pxTaskStatusArray;
3332:              	volatile UBaseType_t uxArraySize, x;
3333:              	char cStatus;
3334:              
3335:              		/*
3336:              		 * PLEASE NOTE:
3337:              		 *
3338:              		 * This function is provided for convenience only, and is used by many
3339:              		 * of the demo applications.  Do not consider it to be part of the
3340:              		 * scheduler.
3341:              		 *
3342:              		 * vTaskList() calls uxTaskGetSystemState(), then formats part of the
3343:              		 * uxTaskGetSystemState() output into a human readable table that
3344:              		 * displays task names, states and stack usage.
3345:              		 *
3346:              		 * vTaskList() has a dependency on the sprintf() C library function that
3347:              		 * might bloat the code size, use a lot of stack, and provide different
3348:              		 * results on different platforms.  An alternative, tiny, third party,
3349:              		 * and limited functionality implementation of sprintf() is provided in
3350:              		 * many of the FreeRTOS/Demo sub-directories in a file called
3351:              		 * printf-stdarg.c (note printf-stdarg.c does not provide a full
3352:              		 * snprintf() implementation!).
3353:              		 *
3354:              		 * It is recommended that production systems call uxTaskGetSystemState()
3355:              		 * directly to get access to raw stats data, rather than indirectly
3356:              		 * through a call to vTaskList().
3357:              		 */
3358:              
3359:              
3360:              		/* Make sure the write buffer does not contain a string. */
3361:              		*pcWriteBuffer = 0x00;
002310  9002CE     MOV [W14+8], W5
002312  EB4200     CLR.B W4
002314  784A84     MOV.B W4, [W5]
3362:              
3363:              		/* Take a snapshot of the number of tasks in case it changes while this
3364:              		function is executing. */
3365:              		uxArraySize = uxCurrentNumberOfTasks;
002316  82FD74     MOV uxCurrentNumberOfTasks, W4
002318  980724     MOV W4, [W14+4]
3366:              
3367:              		/* Allocate an array index for each task. */
3368:              		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
00231A  82FD74     MOV uxCurrentNumberOfTasks, W4
00231C  B922F2     MUL.SU W4, #18, W4
00231E  780004     MOV W4, W0
002320  024240     CALL pvPortMalloc
002322  000000     NOP
002324  780200     MOV W0, W4
002326  980714     MOV W4, [W14+2]
3369:              
3370:              		if( pxTaskStatusArray != NULL )
002328  90021E     MOV [W14+2], W4
00232A  520FE0     SUB W4, #0x0, [W15]
00232C  32005E     BRA Z, 0x23EA
3371:              		{
3372:              			/* Generate the (binary) data. */
3373:              			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, NULL );
00232E  90022E     MOV [W14+4], W4
002330  EB0100     CLR W2
002332  780084     MOV W4, W1
002334  90001E     MOV [W14+2], W0
002336  07FB7D     RCALL uxTaskGetSystemState
002338  780200     MOV W0, W4
00233A  980724     MOV W4, [W14+4]
3374:              
3375:              			/* Create a human readable table from the binary data. */
3376:              			for( x = 0; x < uxArraySize; x++ )
00233C  EB0200     CLR W4
00233E  980734     MOV W4, [W14+6]
002340  37004D     BRA 0x23DC
0023D6  90023E     MOV [W14+6], W4
0023D8  E80204     INC W4, W4
0023DA  980734     MOV W4, [W14+6]
0023DC  9002BE     MOV [W14+6], W5
0023DE  90022E     MOV [W14+4], W4
0023E0  528F84     SUB W5, W4, [W15]
0023E2  39FFAF     BRA NC, 0x2342
3377:              			{
3378:              				switch( pxTaskStatusArray[ x ].eCurrentState )
002342  90023E     MOV [W14+6], W4
002344  B922F2     MUL.SU W4, #18, W4
002346  90029E     MOV [W14+2], W5
002348  428204     ADD W5, W4, W4
00234A  900234     MOV [W4+6], W4
00234C  B82361     MUL.UU W4, #1, W6
00234E  EB8200     SETM W4
002350  EB8280     SETM W5
002352  420206     ADD W4, W6, W4
002354  4A8287     ADDC W5, W7, W5
002356  200036     MOV #0x3, W6
002358  200007     MOV #0x0, W7
00235A  520F86     SUB W4, W6, [W15]
00235C  5A8F87     SUBB W5, W7, [W15]
00235E  3E0011     BRA GTU, 0x2382
002360  010604     BRA W4
002362  370003     BRA 0x236A
002364  370005     BRA 0x2370
002366  370007     BRA 0x2376
002368  370009     BRA 0x237C
3379:              				{
3380:              				case eReady:		cStatus = tskREADY_CHAR;
00236A  B3C524     MOV.B #0x52, W4
00236C  784F04     MOV.B W4, [W14]
3381:              									break;
00236E  37000C     BRA 0x2388
3382:              
3383:              				case eBlocked:		cStatus = tskBLOCKED_CHAR;
002370  B3C424     MOV.B #0x42, W4
002372  784F04     MOV.B W4, [W14]
3384:              									break;
002374  370009     BRA 0x2388
3385:              
3386:              				case eSuspended:	cStatus = tskSUSPENDED_CHAR;
002376  B3C534     MOV.B #0x53, W4
002378  784F04     MOV.B W4, [W14]
3387:              									break;
00237A  370006     BRA 0x2388
3388:              
3389:              				case eDeleted:		cStatus = tskDELETED_CHAR;
00237C  B3C444     MOV.B #0x44, W4
00237E  784F04     MOV.B W4, [W14]
3390:              									break;
002380  370003     BRA 0x2388
3391:              
3392:              				default:			/* Should not get here, but it is included
3393:              									to prevent static checking errors. */
3394:              									cStatus = 0x00;
002382  EB4200     CLR.B W4
002384  784F04     MOV.B W4, [W14]
3395:              									break;
002386  000000     NOP
3396:              				}
3397:              
3398:              				sprintf( pcWriteBuffer, "%s\t\t%c\t%u\t%u\t%u\r\n", pxTaskStatusArray[ x ].pcTaskName, cStatus, ( unsigned int ) pxTaskStatusArray[ x ].uxCurrentPriority, ( unsigned int ) pxTaskStatusArray[ x ].usStackHighWaterMark, ( unsigned int ) pxTaskStatusArray[ x ].xTaskNumber );
002388  90023E     MOV [W14+6], W4
00238A  B922F2     MUL.SU W4, #18, W4
00238C  90029E     MOV [W14+2], W5
00238E  428204     ADD W5, W4, W4
002390  900024     MOV [W4+4], W0
002392  90023E     MOV [W14+6], W4
002394  B922F2     MUL.SU W4, #18, W4
002396  90029E     MOV [W14+2], W5
002398  428204     ADD W5, W4, W4
00239A  900B84     MOV [W4+16], W7
00239C  90023E     MOV [W14+6], W4
00239E  B922F2     MUL.SU W4, #18, W4
0023A0  90029E     MOV [W14+2], W5
0023A2  428204     ADD W5, W4, W4
0023A4  900344     MOV [W4+8], W6
0023A6  FB029E     SE [W14], W5
0023A8  90023E     MOV [W14+6], W4
0023AA  B922F2     MUL.SU W4, #18, W4
0023AC  90009E     MOV [W14+2], W1
0023AE  408204     ADD W1, W4, W4
0023B0  900214     MOV [W4+2], W4
0023B2  781F80     MOV W0, [W15++]
0023B4  781F87     MOV W7, [W15++]
0023B6  781F86     MOV W6, [W15++]
0023B8  781F85     MOV W5, [W15++]
0023BA  781F84     MOV W4, [W15++]
0023BC  293E74     MOV #0x93E7, W4
0023BE  781F84     MOV W4, [W15++]
0023C0  90004E     MOV [W14+8], W0
0023C2  020862     CALL __sprintf_cdnopsuxX
0023C4  000000     NOP
0023C6  5787EC     SUB W15, #0xC, W15
3399:              				pcWriteBuffer += strlen( pcWriteBuffer );
0023C8  90004E     MOV [W14+8], W0
0023CA  020850     CALL _strlen
0023CC  000000     NOP
0023CE  780200     MOV W0, W4
0023D0  9002CE     MOV [W14+8], W5
0023D2  428204     ADD W5, W4, W4
0023D4  980744     MOV W4, [W14+8]
3400:              			}
3401:              
3402:              			/* Free the array again. */
3403:              			vPortFree( pxTaskStatusArray );
0023E4  90001E     MOV [W14+2], W0
0023E6  024330     CALL vPortFree
0023E8  000000     NOP
3404:              		}
3405:              		else
3406:              		{
3407:              			mtCOVERAGE_TEST_MARKER();
3408:              		}
3409:              	}
0023EA  FA8000     ULNK
0023EC  060000     RETURN
3410:              
3411:              #endif /* ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
3412:              /*----------------------------------------------------------*/
3413:              
3414:              #if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
3415:              
3416:              	void vTaskGetRunTimeStats( char *pcWriteBuffer )
3417:              	{
3418:              	TaskStatus_t *pxTaskStatusArray;
3419:              	volatile UBaseType_t uxArraySize, x;
3420:              	uint32_t ulTotalTime, ulStatsAsPercentage;
3421:              
3422:              		#if( configUSE_TRACE_FACILITY != 1 )
3423:              		{
3424:              			#error configUSE_TRACE_FACILITY must also be set to 1 in FreeRTOSConfig.h to use vTaskGetRunTimeStats().
3425:              		}
3426:              		#endif
3427:              
3428:              		/*
3429:              		 * PLEASE NOTE:
3430:              		 *
3431:              		 * This function is provided for convenience only, and is used by many
3432:              		 * of the demo applications.  Do not consider it to be part of the
3433:              		 * scheduler.
3434:              		 *
3435:              		 * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part
3436:              		 * of the uxTaskGetSystemState() output into a human readable table that
3437:              		 * displays the amount of time each task has spent in the Running state
3438:              		 * in both absolute and percentage terms.
3439:              		 *
3440:              		 * vTaskGetRunTimeStats() has a dependency on the sprintf() C library
3441:              		 * function that might bloat the code size, use a lot of stack, and
3442:              		 * provide different results on different platforms.  An alternative,
3443:              		 * tiny, third party, and limited functionality implementation of
3444:              		 * sprintf() is provided in many of the FreeRTOS/Demo sub-directories in
3445:              		 * a file called printf-stdarg.c (note printf-stdarg.c does not provide
3446:              		 * a full snprintf() implementation!).
3447:              		 *
3448:              		 * It is recommended that production systems call uxTaskGetSystemState()
3449:              		 * directly to get access to raw stats data, rather than indirectly
3450:              		 * through a call to vTaskGetRunTimeStats().
3451:              		 */
3452:              
3453:              		/* Make sure the write buffer does not contain a string. */
3454:              		*pcWriteBuffer = 0x00;
3455:              
3456:              		/* Take a snapshot of the number of tasks in case it changes while this
3457:              		function is executing. */
3458:              		uxArraySize = uxCurrentNumberOfTasks;
3459:              
3460:              		/* Allocate an array index for each task. */
3461:              		pxTaskStatusArray = pvPortMalloc( uxCurrentNumberOfTasks * sizeof( TaskStatus_t ) );
3462:              
3463:              		if( pxTaskStatusArray != NULL )
3464:              		{
3465:              			/* Generate the (binary) data. */
3466:              			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalTime );
3467:              
3468:              			/* For percentage calculations. */
3469:              			ulTotalTime /= 100UL;
3470:              
3471:              			/* Avoid divide by zero errors. */
3472:              			if( ulTotalTime > 0 )
3473:              			{
3474:              				/* Create a human readable table from the binary data. */
3475:              				for( x = 0; x < uxArraySize; x++ )
3476:              				{
3477:              					/* What percentage of the total run time has the task used?
3478:              					This will always be rounded down to the nearest integer.
3479:              					ulTotalRunTimeDiv100 has already been divided by 100. */
3480:              					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalTime;
3481:              
3482:              					if( ulStatsAsPercentage > 0UL )
3483:              					{
3484:              						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3485:              						{
3486:              							sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
3487:              						}
3488:              						#else
3489:              						{
3490:              							/* sizeof( int ) == sizeof( long ) so a smaller
3491:              							printf() library can be used. */
3492:              							sprintf( pcWriteBuffer, "%s\t\t%u\t\t%u%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter, ( unsigned int ) ulStatsAsPercentage );
3493:              						}
3494:              						#endif
3495:              					}
3496:              					else
3497:              					{
3498:              						/* If the percentage is zero here then the task has
3499:              						consumed less than 1% of the total run time. */
3500:              						#ifdef portLU_PRINTF_SPECIFIER_REQUIRED
3501:              						{
3502:              							sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
3503:              						}
3504:              						#else
3505:              						{
3506:              							/* sizeof( int ) == sizeof( long ) so a smaller
3507:              							printf() library can be used. */
3508:              							sprintf( pcWriteBuffer, "%s\t\t%u\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, ( unsigned int ) pxTaskStatusArray[ x ].ulRunTimeCounter );
3509:              						}
3510:              						#endif
3511:              					}
3512:              
3513:              					pcWriteBuffer += strlen( pcWriteBuffer );
3514:              				}
3515:              			}
3516:              			else
3517:              			{
3518:              				mtCOVERAGE_TEST_MARKER();
3519:              			}
3520:              
3521:              			/* Free the array again. */
3522:              			vPortFree( pxTaskStatusArray );
3523:              		}
3524:              		else
3525:              		{
3526:              			mtCOVERAGE_TEST_MARKER();
3527:              		}
3528:              	}
3529:              
3530:              #endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) ) */
3531:              /*-----------------------------------------------------------*/
3532:              
3533:              TickType_t uxTaskResetEventItemValue( void )
3534:              {
0023EE  FA0002     LNK #0x2
3535:              TickType_t uxReturn;
3536:              
3537:              	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
0023F0  82FA14     MOV pxCurrentTCB, W4
0023F2  9002E4     MOV [W4+12], W5
0023F4  780F05     MOV W5, [W14]
3538:              
3539:              	/* Reset the event list item to its normal value - so it can be used with
3540:              	queues and semaphores. */
3541:              	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0023F6  82FA14     MOV pxCurrentTCB, W4
0023F8  82FA15     MOV pxCurrentTCB, W5
0023FA  900AB5     MOV [W5+22], W5
0023FC  1282E5     SUBR W5, #0x5, W5
0023FE  980265     MOV W5, [W4+12]
3542:              
3543:              	return uxReturn;
002400  78021E     MOV [W14], W4
3544:              }
002402  780004     MOV W4, W0
002404  FA8000     ULNK
002406  060000     RETURN
3545:              /*-----------------------------------------------------------*/
3546:              
3547:              #ifdef FREERTOS_MODULE_TEST
3548:              	#include "tasks_test_access_functions.h"
3549:              #endif
3550:              
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/FreeRTOS/queue.c  -
1:                 /*
2:                     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     ***************************************************************************
8:                      *                                                                       *
9:                      *    FreeRTOS provides completely free yet professionally developed,    *
10:                     *    robust, strictly quality controlled, supported, and cross          *
11:                     *    platform software that has become a de facto standard.             *
12:                     *                                                                       *
13:                     *    Help yourself get started quickly and support the FreeRTOS         *
14:                     *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                     *                                                                       *
17:                     *    Thank you!                                                         *
18:                     *                                                                       *
19:                    ***************************************************************************
20:                
21:                    This file is part of the FreeRTOS distribution.
22:                
23:                    FreeRTOS is free software; you can redistribute it and/or modify it under
24:                    the terms of the GNU General Public License (version 2) as published by the
25:                    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                
27:                    >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                    >>! a combined work that includes FreeRTOS without being obliged to provide
29:                    >>! the source code for proprietary components outside of the FreeRTOS
30:                    >>! kernel.
31:                
32:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                    link: http://www.freertos.org/a00114.html
36:                
37:                    1 tab == 4 spaces!
38:                
39:                    ***************************************************************************
40:                     *                                                                       *
41:                     *    Having a problem?  Start by reading the FAQ "My application does   *
42:                     *    not run, what could be wrong?"                                     *
43:                     *                                                                       *
44:                     *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                     *                                                                       *
46:                    ***************************************************************************
47:                
48:                    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                    license and Real Time Engineers Ltd. contact details.
50:                
51:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                
55:                    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                    licenses offer ticketed support, indemnification and middleware.
58:                
59:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                    engineered and independently SIL3 certified version for use in safety and
61:                    mission critical applications that require provable dependability.
62:                
63:                    1 tab == 4 spaces!
64:                */
65:                
66:                #include <stdlib.h>
67:                #include <string.h>
68:                
69:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
70:                all the API functions to use the MPU wrappers.  That should only be done when
71:                task.h is included from an application file. */
72:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
73:                
74:                #include "FreeRTOS.h"
75:                #include "task.h"
76:                #include "queue.h"
77:                
78:                #if ( configUSE_CO_ROUTINES == 1 )
79:                	#include "croutine.h"
80:                #endif
81:                
82:                /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
83:                MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
84:                header files above, but not in this file, in order to generate the correct
85:                privileged Vs unprivileged linkage and placement. */
86:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
87:                
88:                
89:                /* Constants used with the xRxLock and xTxLock structure members. */
90:                #define queueUNLOCKED					( ( BaseType_t ) -1 )
91:                #define queueLOCKED_UNMODIFIED			( ( BaseType_t ) 0 )
92:                
93:                /* When the Queue_t structure is used to represent a base queue its pcHead and
94:                pcTail members are used as pointers into the queue storage area.  When the
95:                Queue_t structure is used to represent a mutex pcHead and pcTail pointers are
96:                not necessary, and the pcHead pointer is set to NULL to indicate that the
97:                pcTail pointer actually points to the mutex holder (if any).  Map alternative
98:                names to the pcHead and pcTail structure members to ensure the readability of
99:                the code is maintained despite this dual use of two structure members.  An
100:               alternative implementation would be to use a union, but use of a union is
101:               against the coding standard (although an exception to the standard has been
102:               permitted where the dual use also significantly changes the type of the
103:               structure member). */
104:               #define pxMutexHolder					pcTail
105:               #define uxQueueType						pcHead
106:               #define queueQUEUE_IS_MUTEX				NULL
107:               
108:               /* Semaphores do not actually store or copy data, so have an item size of
109:               zero. */
110:               #define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
111:               #define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
112:               
113:               #if( configUSE_PREEMPTION == 0 )
114:               	/* If the cooperative scheduler is being used then a yield should not be
115:               	performed just because a higher priority task has been woken. */
116:               	#define queueYIELD_IF_USING_PREEMPTION()
117:               #else
118:               	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
119:               #endif
120:               
121:               /*
122:                * Definition of the queue used by the scheduler.
123:                * Items are queued by copy, not reference.
124:                */
125:               typedef struct QueueDefinition
126:               {
127:               	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
128:               	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
129:               	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
130:               
131:               	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclusive structure members don't appear simultaneously (wasting RAM). */
132:               	{
133:               		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
134:               		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
135:               	} u;
136:               
137:               	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
138:               	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
139:               
140:               	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
141:               	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
142:               	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
143:               
144:               	volatile BaseType_t xRxLock;	/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
145:               	volatile BaseType_t xTxLock;	/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
146:               
147:               	#if ( configUSE_TRACE_FACILITY == 1 )
148:               		UBaseType_t uxQueueNumber;
149:               		uint8_t ucQueueType;
150:               	#endif
151:               
152:               	#if ( configUSE_QUEUE_SETS == 1 )
153:               		struct QueueDefinition *pxQueueSetContainer;
154:               	#endif
155:               
156:               } xQUEUE;
157:               
158:               /* The old xQUEUE name is maintained above then typedefed to the new Queue_t
159:               name below to enable the use of older kernel aware debuggers. */
160:               typedef xQUEUE Queue_t;
161:               
162:               /*-----------------------------------------------------------*/
163:               
164:               /*
165:                * The queue registry is just a means for kernel aware debuggers to locate
166:                * queue structures.  It has no other purpose so is an optional component.
167:                */
168:               #if ( configQUEUE_REGISTRY_SIZE > 0 )
169:               
170:               	/* The type stored within the queue registry array.  This allows a name
171:               	to be assigned to each queue making kernel aware debugging a little
172:               	more user friendly. */
173:               	typedef struct QUEUE_REGISTRY_ITEM
174:               	{
175:               		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
176:               		QueueHandle_t xHandle;
177:               	} xQueueRegistryItem;
178:               
179:               	/* The old xQueueRegistryItem name is maintained above then typedefed to the
180:               	new xQueueRegistryItem name below to enable the use of older kernel aware
181:               	debuggers. */
182:               	typedef xQueueRegistryItem QueueRegistryItem_t;
183:               
184:               	/* The queue registry is simply an array of QueueRegistryItem_t structures.
185:               	The pcQueueName member of a structure being NULL is indicative of the
186:               	array position being vacant. */
187:               	QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
188:               
189:               #endif /* configQUEUE_REGISTRY_SIZE */
190:               
191:               /*
192:                * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
193:                * prevent an ISR from adding or removing items to the queue, but does prevent
194:                * an ISR from removing tasks from the queue event lists.  If an ISR finds a
195:                * queue is locked it will instead increment the appropriate queue lock count
196:                * to indicate that a task may require unblocking.  When the queue in unlocked
197:                * these lock counts are inspected, and the appropriate action taken.
198:                */
199:               static void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
200:               
201:               /*
202:                * Uses a critical section to determine if there is any data in a queue.
203:                *
204:                * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
205:                */
206:               static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
207:               
208:               /*
209:                * Uses a critical section to determine if there is any space in a queue.
210:                *
211:                * @return pdTRUE if there is no space, otherwise pdFALSE;
212:                */
213:               static BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
214:               
215:               /*
216:                * Copies an item into the queue, either at the front of the queue or the
217:                * back of the queue.
218:                */
219:               static void prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
220:               
221:               /*
222:                * Copies an item out of a queue.
223:                */
224:               static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
225:               
226:               #if ( configUSE_QUEUE_SETS == 1 )
227:               	/*
228:               	 * Checks to see if a queue is a member of a queue set, and if so, notifies
229:               	 * the queue set that the queue contains data.
230:               	 */
231:               	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
232:               #endif
233:               
234:               /*-----------------------------------------------------------*/
235:               
236:               /*
237:                * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
238:                * accessing the queue event lists.
239:                */
240:               #define prvLockQueue( pxQueue )								\
241:               	taskENTER_CRITICAL();									\
242:               	{														\
243:               		if( ( pxQueue )->xRxLock == queueUNLOCKED )			\
244:               		{													\
245:               			( pxQueue )->xRxLock = queueLOCKED_UNMODIFIED;	\
246:               		}													\
247:               		if( ( pxQueue )->xTxLock == queueUNLOCKED )			\
248:               		{													\
249:               			( pxQueue )->xTxLock = queueLOCKED_UNMODIFIED;	\
250:               		}													\
251:               	}														\
252:               	taskEXIT_CRITICAL()
253:               /*-----------------------------------------------------------*/
254:               
255:               BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
256:               {
002408  FA0006     LNK #0x6
00240A  980710     MOV W0, [W14+2]
00240C  980721     MOV W1, [W14+4]
257:               Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00240E  90021E     MOV [W14+2], W4
002410  780F04     MOV W4, [W14]
258:               
259:               	configASSERT( pxQueue );
260:               
261:               	taskENTER_CRITICAL();
002412  02497A     CALL vPortEnterCritical
002414  000000     NOP
262:               	{
263:               		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
002416  78021E     MOV [W14], W4
002418  780294     MOV [W4], W5
00241A  78021E     MOV [W14], W4
00241C  900B74     MOV [W4+30], W6
00241E  78021E     MOV [W14], W4
002420  901204     MOV [W4+32], W4
002422  B9B284     MULW.SS W6, W4, W4
002424  428284     ADD W5, W4, W5
002426  78021E     MOV [W14], W4
002428  980215     MOV W5, [W4+2]
264:               		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
00242A  78021E     MOV [W14], W4
00242C  EB0280     CLR W5
00242E  980A65     MOV W5, [W4+28]
265:               		pxQueue->pcWriteTo = pxQueue->pcHead;
002430  78021E     MOV [W14], W4
002432  780294     MOV [W4], W5
002434  78021E     MOV [W14], W4
002436  980225     MOV W5, [W4+4]
266:               		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
002438  78021E     MOV [W14], W4
00243A  780294     MOV [W4], W5
00243C  78021E     MOV [W14], W4
00243E  900A74     MOV [W4+30], W4
002440  E90304     DEC W4, W6
002442  78021E     MOV [W14], W4
002444  901204     MOV [W4+32], W4
002446  B9B284     MULW.SS W6, W4, W4
002448  428284     ADD W5, W4, W5
00244A  78021E     MOV [W14], W4
00244C  980235     MOV W5, [W4+6]
267:               		pxQueue->xRxLock = queueUNLOCKED;
00244E  78021E     MOV [W14], W4
002450  EB8280     SETM W5
002452  981215     MOV W5, [W4+34]
268:               		pxQueue->xTxLock = queueUNLOCKED;
002454  78021E     MOV [W14], W4
002456  EB8280     SETM W5
002458  981225     MOV W5, [W4+36]
269:               
270:               		if( xNewQueue == pdFALSE )
00245A  90022E     MOV [W14+4], W4
00245C  520FE0     SUB W4, #0x0, [W15]
00245E  3A0010     BRA NZ, 0x2480
271:               		{
272:               			/* If there are tasks blocked waiting to read from the queue, then
273:               			the tasks will remain blocked as after this function exits the queue
274:               			will still be empty.  If there are tasks blocked waiting to write to
275:               			the queue, then one should be unblocked as after this function exits
276:               			it will be possible to write to it. */
277:               			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
002460  78021E     MOV [W14], W4
002462  900244     MOV [W4+8], W4
002464  520FE0     SUB W4, #0x0, [W15]
002466  320016     BRA Z, 0x2494
278:               			{
279:               				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
002468  78029E     MOV [W14], W5
00246A  428268     ADD W5, #0x8, W4
00246C  780004     MOV W4, W0
00246E  021CCA     CALL xTaskRemoveFromEventList
002470  000000     NOP
002472  780200     MOV W0, W4
002474  520FE1     SUB W4, #0x1, [W15]
002476  3A000E     BRA NZ, 0x2494
280:               				{
281:               					queueYIELD_IF_USING_PREEMPTION();
002478  024F06     CALL _vPortYield
00247A  000000     NOP
00247C  000000     NOP
00247E  37000A     BRA 0x2494
282:               				}
283:               				else
284:               				{
285:               					mtCOVERAGE_TEST_MARKER();
286:               				}
287:               			}
288:               			else
289:               			{
290:               				mtCOVERAGE_TEST_MARKER();
291:               			}
292:               		}
293:               		else
294:               		{
295:               			/* Ensure the event queues start in the correct state. */
296:               			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
002480  78029E     MOV [W14], W5
002482  428268     ADD W5, #0x8, W4
002484  780004     MOV W4, W0
002486  024B2E     CALL vListInitialise
002488  000000     NOP
297:               			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
00248A  78029E     MOV [W14], W5
00248C  428272     ADD W5, #0x12, W4
00248E  780004     MOV W4, W0
002490  024B2E     CALL vListInitialise
002492  000000     NOP
298:               		}
299:               	}
300:               	taskEXIT_CRITICAL();
002494  02498E     CALL vPortExitCritical
002496  000000     NOP
301:               
302:               	/* A value is returned for calling semantic consistency with previous
303:               	versions. */
304:               	return pdPASS;
002498  200014     MOV #0x1, W4
305:               }
00249A  780004     MOV W4, W0
00249C  FA8000     ULNK
00249E  060000     RETURN
306:               /*-----------------------------------------------------------*/
307:               
308:               QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
309:               {
0024A0  FA000C     LNK #0xC
0024A2  980730     MOV W0, [W14+6]
0024A4  980741     MOV W1, [W14+8]
0024A6  984F22     MOV.B W2, [W14+10]
310:               Queue_t *pxNewQueue;
311:               size_t xQueueSizeInBytes;
312:               QueueHandle_t xReturn = NULL;
0024A8  EB0200     CLR W4
0024AA  780F04     MOV W4, [W14]
313:               
314:               	/* Remove compiler warnings about unused parameters should
315:               	configUSE_TRACE_FACILITY not be set to 1. */
316:               	( void ) ucQueueType;
317:               
318:               	/* Allocate the new queue structure. */
319:               	if( uxQueueLength > ( UBaseType_t ) 0 )
0024AC  90023E     MOV [W14+6], W4
0024AE  520FE0     SUB W4, #0x0, [W15]
0024B0  32002A     BRA Z, 0x2506
320:               	{
321:               		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
0024B2  2002A0     MOV #0x2A, W0
0024B4  024240     CALL pvPortMalloc
0024B6  000000     NOP
0024B8  780200     MOV W0, W4
0024BA  980714     MOV W4, [W14+2]
322:               		if( pxNewQueue != NULL )
0024BC  90021E     MOV [W14+2], W4
0024BE  520FE0     SUB W4, #0x0, [W15]
0024C0  320022     BRA Z, 0x2506
323:               		{
324:               			/* Create the list of pointers to queue items.  The queue is one byte
325:               			longer than asked for to make wrap checking easier/faster. */
326:               			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0024C2  9002BE     MOV [W14+6], W5
0024C4  90024E     MOV [W14+8], W4
0024C6  B9AA84     MULW.SS W5, W4, W4
0024C8  E80204     INC W4, W4
0024CA  980724     MOV W4, [W14+4]
327:               
328:               			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
0024CC  90002E     MOV [W14+4], W0
0024CE  024240     CALL pvPortMalloc
0024D0  000000     NOP
0024D2  780200     MOV W0, W4
0024D4  780284     MOV W4, W5
0024D6  90021E     MOV [W14+2], W4
0024D8  780A05     MOV W5, [W4]
329:               			if( pxNewQueue->pcHead != NULL )
0024DA  90021E     MOV [W14+2], W4
0024DC  780214     MOV [W4], W4
0024DE  520FE0     SUB W4, #0x0, [W15]
0024E0  32000F     BRA Z, 0x2500
330:               			{
331:               				/* Initialise the queue members as described above where the
332:               				queue type is defined. */
333:               				pxNewQueue->uxLength = uxQueueLength;
0024E2  90021E     MOV [W14+2], W4
0024E4  9002BE     MOV [W14+6], W5
0024E6  980A75     MOV W5, [W4+30]
334:               				pxNewQueue->uxItemSize = uxItemSize;
0024E8  90021E     MOV [W14+2], W4
0024EA  9002CE     MOV [W14+8], W5
0024EC  981205     MOV W5, [W4+32]
335:               				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
0024EE  200011     MOV #0x1, W1
0024F0  90001E     MOV [W14+2], W0
0024F2  07FF8A     RCALL xQueueGenericReset
336:               
337:               				#if ( configUSE_TRACE_FACILITY == 1 )
338:               				{
339:               					pxNewQueue->ucQueueType = ucQueueType;
0024F4  90021E     MOV [W14+2], W4
0024F6  904AAE     MOV.B [W14+10], W5
0024F8  986A05     MOV.B W5, [W4+40]
340:               				}
341:               				#endif /* configUSE_TRACE_FACILITY */
342:               
343:               				#if( configUSE_QUEUE_SETS == 1 )
344:               				{
345:               					pxNewQueue->pxQueueSetContainer = NULL;
346:               				}
347:               				#endif /* configUSE_QUEUE_SETS */
348:               
349:               				traceQUEUE_CREATE( pxNewQueue );
350:               				xReturn = pxNewQueue;
0024FA  90021E     MOV [W14+2], W4
0024FC  780F04     MOV W4, [W14]
0024FE  370003     BRA 0x2506
351:               			}
352:               			else
353:               			{
354:               				traceQUEUE_CREATE_FAILED( ucQueueType );
355:               				vPortFree( pxNewQueue );
002500  90001E     MOV [W14+2], W0
002502  024330     CALL vPortFree
002504  000000     NOP
356:               			}
357:               		}
358:               		else
359:               		{
360:               			mtCOVERAGE_TEST_MARKER();
361:               		}
362:               	}
363:               	else
364:               	{
365:               		mtCOVERAGE_TEST_MARKER();
366:               	}
367:               
368:               	configASSERT( xReturn );
369:               
370:               	return xReturn;
002506  78021E     MOV [W14], W4
371:               }
002508  780004     MOV W4, W0
00250A  FA8000     ULNK
00250C  060000     RETURN
372:               /*-----------------------------------------------------------*/
373:               
374:               #if ( configUSE_MUTEXES == 1 )
375:               
376:               	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
377:               	{
00250E  FA0004     LNK #0x4
002510  984720     MOV.B W0, [W14+2]
378:               	Queue_t *pxNewQueue;
379:               
380:               		/* Prevent compiler warnings about unused parameters if
381:               		configUSE_TRACE_FACILITY does not equal 1. */
382:               		( void ) ucQueueType;
383:               
384:               		/* Allocate the new queue structure. */
385:               		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
002512  2002A0     MOV #0x2A, W0
002514  024240     CALL pvPortMalloc
002516  000000     NOP
002518  780200     MOV W0, W4
00251A  780F04     MOV W4, [W14]
386:               		if( pxNewQueue != NULL )
00251C  78021E     MOV [W14], W4
00251E  520FE0     SUB W4, #0x0, [W15]
002520  32002D     BRA Z, 0x257C
387:               		{
388:               			/* Information required for priority inheritance. */
389:               			pxNewQueue->pxMutexHolder = NULL;
002522  78021E     MOV [W14], W4
002524  EB0280     CLR W5
002526  980215     MOV W5, [W4+2]
390:               			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
002528  78021E     MOV [W14], W4
00252A  EB0280     CLR W5
00252C  780A05     MOV W5, [W4]
391:               
392:               			/* Queues used as a mutex no data is actually copied into or out
393:               			of the queue. */
394:               			pxNewQueue->pcWriteTo = NULL;
00252E  78021E     MOV [W14], W4
002530  EB0280     CLR W5
002532  980225     MOV W5, [W4+4]
395:               			pxNewQueue->u.pcReadFrom = NULL;
002534  78021E     MOV [W14], W4
002536  EB0280     CLR W5
002538  980235     MOV W5, [W4+6]
396:               
397:               			/* Each mutex has a length of 1 (like a binary semaphore) and
398:               			an item size of 0 as nothing is actually copied into or out
399:               			of the mutex. */
400:               			pxNewQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
00253A  78021E     MOV [W14], W4
00253C  EB0280     CLR W5
00253E  980A65     MOV W5, [W4+28]
401:               			pxNewQueue->uxLength = ( UBaseType_t ) 1U;
002540  78021E     MOV [W14], W4
002542  200015     MOV #0x1, W5
002544  980A75     MOV W5, [W4+30]
402:               			pxNewQueue->uxItemSize = ( UBaseType_t ) 0U;
002546  78021E     MOV [W14], W4
002548  EB0280     CLR W5
00254A  981205     MOV W5, [W4+32]
403:               			pxNewQueue->xRxLock = queueUNLOCKED;
00254C  78021E     MOV [W14], W4
00254E  EB8280     SETM W5
002550  981215     MOV W5, [W4+34]
404:               			pxNewQueue->xTxLock = queueUNLOCKED;
002552  78021E     MOV [W14], W4
002554  EB8280     SETM W5
002556  981225     MOV W5, [W4+36]
405:               
406:               			#if ( configUSE_TRACE_FACILITY == 1 )
407:               			{
408:               				pxNewQueue->ucQueueType = ucQueueType;
002558  78021E     MOV [W14], W4
00255A  9042AE     MOV.B [W14+2], W5
00255C  986A05     MOV.B W5, [W4+40]
409:               			}
410:               			#endif
411:               
412:               			#if ( configUSE_QUEUE_SETS == 1 )
413:               			{
414:               				pxNewQueue->pxQueueSetContainer = NULL;
415:               			}
416:               			#endif
417:               
418:               			/* Ensure the event queues start with the correct state. */
419:               			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
00255E  78029E     MOV [W14], W5
002560  428268     ADD W5, #0x8, W4
002562  780004     MOV W4, W0
002564  024B2E     CALL vListInitialise
002566  000000     NOP
420:               			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
002568  78029E     MOV [W14], W5
00256A  428272     ADD W5, #0x12, W4
00256C  780004     MOV W4, W0
00256E  024B2E     CALL vListInitialise
002570  000000     NOP
421:               
422:               			traceCREATE_MUTEX( pxNewQueue );
423:               
424:               			/* Start with the semaphore in the expected state. */
425:               			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
002572  EB0180     CLR W3
002574  EB0100     CLR W2
002576  EB0080     CLR W1
002578  78001E     MOV [W14], W0
00257A  070004     RCALL xQueueGenericSend
426:               		}
427:               		else
428:               		{
429:               			traceCREATE_MUTEX_FAILED();
430:               		}
431:               
432:               		configASSERT( pxNewQueue );
433:               		return pxNewQueue;
00257C  78021E     MOV [W14], W4
434:               	}
00257E  780004     MOV W4, W0
002580  FA8000     ULNK
002582  060000     RETURN
435:               
436:               #endif /* configUSE_MUTEXES */
437:               /*-----------------------------------------------------------*/
438:               
439:               #if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
440:               
441:               	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
442:               	{
443:               	void *pxReturn;
444:               
445:               		/* This function is called by xSemaphoreGetMutexHolder(), and should not
446:               		be called directly.  Note:  This is a good way of determining if the
447:               		calling task is the mutex holder, but not a good way of determining the
448:               		identity of the mutex holder, as the holder may change between the
449:               		following critical section exiting and the function returning. */
450:               		taskENTER_CRITICAL();
451:               		{
452:               			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
453:               			{
454:               				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
455:               			}
456:               			else
457:               			{
458:               				pxReturn = NULL;
459:               			}
460:               		}
461:               		taskEXIT_CRITICAL();
462:               
463:               		return pxReturn;
464:               	}
465:               
466:               #endif
467:               /*-----------------------------------------------------------*/
468:               
469:               #if ( configUSE_RECURSIVE_MUTEXES == 1 )
470:               
471:               	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
472:               	{
473:               	BaseType_t xReturn;
474:               	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
475:               
476:               		configASSERT( pxMutex );
477:               
478:               		/* If this is the task that holds the mutex then pxMutexHolder will not
479:               		change outside of this task.  If this task does not hold the mutex then
480:               		pxMutexHolder can never coincidentally equal the tasks handle, and as
481:               		this is the only condition we are interested in it does not matter if
482:               		pxMutexHolder is accessed simultaneously by another task.  Therefore no
483:               		mutual exclusion is required to test the pxMutexHolder variable. */
484:               		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
485:               		{
486:               			traceGIVE_MUTEX_RECURSIVE( pxMutex );
487:               
488:               			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
489:               			the task handle, therefore no underflow check is required.  Also,
490:               			uxRecursiveCallCount is only modified by the mutex holder, and as
491:               			there can only be one, no mutual exclusion is required to modify the
492:               			uxRecursiveCallCount member. */
493:               			( pxMutex->u.uxRecursiveCallCount )--;
494:               
495:               			/* Have we unwound the call count? */
496:               			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
497:               			{
498:               				/* Return the mutex.  This will automatically unblock any other
499:               				task that might be waiting to access the mutex. */
500:               				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
501:               			}
502:               			else
503:               			{
504:               				mtCOVERAGE_TEST_MARKER();
505:               			}
506:               
507:               			xReturn = pdPASS;
508:               		}
509:               		else
510:               		{
511:               			/* We cannot give the mutex because we are not the holder. */
512:               			xReturn = pdFAIL;
513:               
514:               			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
515:               		}
516:               
517:               		return xReturn;
518:               	}
519:               
520:               #endif /* configUSE_RECURSIVE_MUTEXES */
521:               /*-----------------------------------------------------------*/
522:               
523:               #if ( configUSE_RECURSIVE_MUTEXES == 1 )
524:               
525:               	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
526:               	{
527:               	BaseType_t xReturn;
528:               	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
529:               
530:               		configASSERT( pxMutex );
531:               
532:               		/* Comments regarding mutual exclusion as per those within
533:               		xQueueGiveMutexRecursive(). */
534:               
535:               		traceTAKE_MUTEX_RECURSIVE( pxMutex );
536:               
537:               		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
538:               		{
539:               			( pxMutex->u.uxRecursiveCallCount )++;
540:               			xReturn = pdPASS;
541:               		}
542:               		else
543:               		{
544:               			xReturn = xQueueGenericReceive( pxMutex, NULL, xTicksToWait, pdFALSE );
545:               
546:               			/* pdPASS will only be returned if we successfully obtained the mutex,
547:               			we may have blocked to reach here. */
548:               			if( xReturn == pdPASS )
549:               			{
550:               				( pxMutex->u.uxRecursiveCallCount )++;
551:               			}
552:               			else
553:               			{
554:               				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
555:               			}
556:               		}
557:               
558:               		return xReturn;
559:               	}
560:               
561:               #endif /* configUSE_RECURSIVE_MUTEXES */
562:               /*-----------------------------------------------------------*/
563:               
564:               #if ( configUSE_COUNTING_SEMAPHORES == 1 )
565:               
566:               	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
567:               	{
568:               	QueueHandle_t xHandle;
569:               
570:               		configASSERT( uxMaxCount != 0 );
571:               		configASSERT( uxInitialCount <= uxMaxCount );
572:               
573:               		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
574:               
575:               		if( xHandle != NULL )
576:               		{
577:               			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
578:               
579:               			traceCREATE_COUNTING_SEMAPHORE();
580:               		}
581:               		else
582:               		{
583:               			traceCREATE_COUNTING_SEMAPHORE_FAILED();
584:               		}
585:               
586:               		configASSERT( xHandle );
587:               		return xHandle;
588:               	}
589:               
590:               #endif /* configUSE_COUNTING_SEMAPHORES */
591:               /*-----------------------------------------------------------*/
592:               
593:               BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
594:               {
002584  FA0010     LNK #0x10
002586  980740     MOV W0, [W14+8]
002588  980751     MOV W1, [W14+10]
00258A  980762     MOV W2, [W14+12]
00258C  980773     MOV W3, [W14+14]
595:               BaseType_t xEntryTimeSet = pdFALSE;
00258E  EB0200     CLR W4
002590  780F04     MOV W4, [W14]
596:               TimeOut_t xTimeOut;
597:               Queue_t * const pxQueue = ( Queue_t * ) xQueue;
002592  90024E     MOV [W14+8], W4
002594  980714     MOV W4, [W14+2]
002596  370001     BRA 0x259A
598:               
599:               	configASSERT( pxQueue );
600:               	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
601:               	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
602:               	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
603:               	{
604:               		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
605:               	}
606:               	#endif
607:               
608:               
609:               	/* This function relaxes the coding standard somewhat to allow return
610:               	statements within the function itself.  This is done in the interest
611:               	of execution time efficiency. */
612:               	for( ;; )
613:               	{
614:               		taskENTER_CRITICAL();
00259A  02497A     CALL vPortEnterCritical
00259C  000000     NOP
615:               		{
616:               			/* Is there room on the queue now?  The running task must be
617:               			the highest priority task wanting to access the queue.  If
618:               			the head item in the queue is to be overwritten then it does
619:               			not matter if the queue is full. */
620:               			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
00259E  90021E     MOV [W14+2], W4
0025A0  900AE4     MOV [W4+28], W5
0025A2  90021E     MOV [W14+2], W4
0025A4  900A74     MOV [W4+30], W4
0025A6  528F84     SUB W5, W4, [W15]
0025A8  390003     BRA NC, 0x25B0
0025AA  90027E     MOV [W14+14], W4
0025AC  520FE2     SUB W4, #0x2, [W15]
0025AE  3A0017     BRA NZ, 0x25DE
621:               			{
622:               				traceQUEUE_SEND( pxQueue );
623:               				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
0025B0  90017E     MOV [W14+14], W2
0025B2  9000DE     MOV [W14+10], W1
0025B4  90001E     MOV [W14+2], W0
0025B6  0701F6     RCALL _prvCopyDataToQueue
624:               
625:               				#if ( configUSE_QUEUE_SETS == 1 )
626:               				{
627:               					if( pxQueue->pxQueueSetContainer != NULL )
628:               					{
629:               						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
630:               						{
631:               							/* The queue is a member of a queue set, and posting
632:               							to the queue set caused a higher priority task to
633:               							unblock. A context switch is required. */
634:               							queueYIELD_IF_USING_PREEMPTION();
635:               						}
636:               						else
637:               						{
638:               							mtCOVERAGE_TEST_MARKER();
639:               						}
640:               					}
641:               					else
642:               					{
643:               						/* If there was a task waiting for data to arrive on the
644:               						queue then unblock it now. */
645:               						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
646:               						{
647:               							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
648:               							{
649:               								/* The unblocked task has a priority higher than
650:               								our own so yield immediately.  Yes it is ok to
651:               								do this from within the critical section - the
652:               								kernel takes care of that. */
653:               								queueYIELD_IF_USING_PREEMPTION();
654:               							}
655:               							else
656:               							{
657:               								mtCOVERAGE_TEST_MARKER();
658:               							}
659:               						}
660:               						else
661:               						{
662:               							mtCOVERAGE_TEST_MARKER();
663:               						}
664:               					}
665:               				}
666:               				#else /* configUSE_QUEUE_SETS */
667:               				{
668:               					/* If there was a task waiting for data to arrive on the
669:               					queue then unblock it now. */
670:               					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0025B8  90021E     MOV [W14+2], W4
0025BA  900A14     MOV [W4+18], W4
0025BC  520FE0     SUB W4, #0x0, [W15]
0025BE  32000B     BRA Z, 0x25D6
671:               					{
672:               						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
0025C0  90021E     MOV [W14+2], W4
0025C2  420272     ADD W4, #0x12, W4
0025C4  780004     MOV W4, W0
0025C6  021CCA     CALL xTaskRemoveFromEventList
0025C8  000000     NOP
0025CA  780200     MOV W0, W4
0025CC  520FE1     SUB W4, #0x1, [W15]
0025CE  3A0003     BRA NZ, 0x25D6
673:               						{
674:               							/* The unblocked task has a priority higher than
675:               							our own so yield immediately.  Yes it is ok to do
676:               							this from within the critical section - the kernel
677:               							takes care of that. */
678:               							queueYIELD_IF_USING_PREEMPTION();
0025D0  024F06     CALL _vPortYield
0025D2  000000     NOP
0025D4  000000     NOP
679:               						}
680:               						else
681:               						{
682:               							mtCOVERAGE_TEST_MARKER();
683:               						}
684:               					}
685:               					else
686:               					{
687:               						mtCOVERAGE_TEST_MARKER();
688:               					}
689:               				}
690:               				#endif /* configUSE_QUEUE_SETS */
691:               
692:               				taskEXIT_CRITICAL();
0025D6  02498E     CALL vPortExitCritical
0025D8  000000     NOP
693:               
694:               				/* Return to the original privilege level before exiting the
695:               				function. */
696:               				return pdPASS;
0025DA  200014     MOV #0x1, W4
0025DC  370050     BRA 0x267E
697:               			}
698:               			else
699:               			{
700:               				if( xTicksToWait == ( TickType_t ) 0 )
0025DE  90026E     MOV [W14+12], W4
0025E0  520FE0     SUB W4, #0x0, [W15]
0025E2  3A0004     BRA NZ, 0x25EC
701:               				{
702:               					/* The queue was full and no block time is specified (or
703:               					the block time has expired) so leave now. */
704:               					taskEXIT_CRITICAL();
0025E4  02498E     CALL vPortExitCritical
0025E6  000000     NOP
705:               
706:               					/* Return to the original privilege level before exiting
707:               					the function. */
708:               					traceQUEUE_SEND_FAILED( pxQueue );
709:               					return errQUEUE_FULL;
0025E8  EB0200     CLR W4
0025EA  370049     BRA 0x267E
710:               				}
711:               				else if( xEntryTimeSet == pdFALSE )
0025EC  78021E     MOV [W14], W4
0025EE  520FE0     SUB W4, #0x0, [W15]
0025F0  3A0006     BRA NZ, 0x25FE
712:               				{
713:               					/* The queue was full and a block time was specified so
714:               					configure the timeout structure. */
715:               					vTaskSetTimeOutState( &xTimeOut );
0025F2  470264     ADD W14, #0x4, W4
0025F4  780004     MOV W4, W0
0025F6  021DB8     CALL vTaskSetTimeOutState
0025F8  000000     NOP
716:               					xEntryTimeSet = pdTRUE;
0025FA  200014     MOV #0x1, W4
0025FC  780F04     MOV W4, [W14]
717:               				}
718:               				else
719:               				{
720:               					/* Entry time was already set. */
721:               					mtCOVERAGE_TEST_MARKER();
722:               				}
723:               			}
724:               		}
725:               		taskEXIT_CRITICAL();
0025FE  02498E     CALL vPortExitCritical
002600  000000     NOP
726:               
727:               		/* Interrupts and other tasks can send to and receive from the queue
728:               		now the critical section has been exited. */
729:               
730:               		vTaskSuspendAll();
002602  021928     CALL vTaskSuspendAll
002604  000000     NOP
731:               		prvLockQueue( pxQueue );
002606  02497A     CALL vPortEnterCritical
002608  000000     NOP
00260A  90021E     MOV [W14+2], W4
00260C  901214     MOV [W4+34], W4
00260E  420FE1     ADD W4, #0x1, [W15]
002610  3A0003     BRA NZ, 0x2618
002612  90021E     MOV [W14+2], W4
002614  EB0280     CLR W5
002616  981215     MOV W5, [W4+34]
002618  90021E     MOV [W14+2], W4
00261A  901224     MOV [W4+36], W4
00261C  420FE1     ADD W4, #0x1, [W15]
00261E  3A0003     BRA NZ, 0x2626
002620  90021E     MOV [W14+2], W4
002622  EB0280     CLR W5
002624  981225     MOV W5, [W4+36]
002626  02498E     CALL vPortExitCritical
002628  000000     NOP
732:               
733:               		/* Update the timeout state to see if it has expired yet. */
734:               		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
00262A  4702EC     ADD W14, #0xC, W5
00262C  470264     ADD W14, #0x4, W4
00262E  780085     MOV W5, W1
002630  780004     MOV W4, W0
002632  021DCC     CALL xTaskCheckForTimeOut
002634  000000     NOP
002636  780200     MOV W0, W4
002638  520FE0     SUB W4, #0x0, [W15]
00263A  3A001C     BRA NZ, 0x2674
735:               		{
736:               			if( prvIsQueueFull( pxQueue ) != pdFALSE )
00263C  90001E     MOV [W14+2], W0
00263E  0702A2     RCALL _prvIsQueueFull
002640  780200     MOV W0, W4
002642  520FE0     SUB W4, #0x0, [W15]
002644  320012     BRA Z, 0x266A
737:               			{
738:               				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
739:               				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
002646  9002EE     MOV [W14+12], W5
002648  90021E     MOV [W14+2], W4
00264A  420268     ADD W4, #0x8, W4
00264C  780085     MOV W5, W1
00264E  780004     MOV W4, W0
002650  021C18     CALL vTaskPlaceOnEventList
002652  000000     NOP
740:               
741:               				/* Unlocking the queue means queue events can effect the
742:               				event list.  It is possible	that interrupts occurring now
743:               				remove this task from the event	list again - but as the
744:               				scheduler is suspended the task will go onto the pending
745:               				ready last instead of the actual ready list. */
746:               				prvUnlockQueue( pxQueue );
002654  90001E     MOV [W14+2], W0
002656  07022E     RCALL _prvUnlockQueue
747:               
748:               				/* Resuming the scheduler will move tasks from the pending
749:               				ready list into the ready list - so it is feasible that this
750:               				task is already in a ready list before it yields - in which
751:               				case the yield will not cause a context switch unless there
752:               				is also a higher priority task in the pending ready list. */
753:               				if( xTaskResumeAll() == pdFALSE )
002658  021934     CALL xTaskResumeAll
00265A  000000     NOP
00265C  780200     MOV W0, W4
00265E  520FE0     SUB W4, #0x0, [W15]
002660  3AFF9B     BRA NZ, 0x2598
754:               				{
755:               					portYIELD_WITHIN_API();
002662  024F06     CALL _vPortYield
002664  000000     NOP
002666  000000     NOP
756:               				}
757:               			}
758:               			else
759:               			{
760:               				/* Try again. */
761:               				prvUnlockQueue( pxQueue );
00266A  90001E     MOV [W14+2], W0
00266C  070223     RCALL _prvUnlockQueue
762:               				( void ) xTaskResumeAll();
00266E  021934     CALL xTaskResumeAll
002670  000000     NOP
763:               			}
764:               		}
765:               		else
766:               		{
767:               			/* The timeout has expired. */
768:               			prvUnlockQueue( pxQueue );
002674  90001E     MOV [W14+2], W0
002676  07021E     RCALL _prvUnlockQueue
769:               			( void ) xTaskResumeAll();
002678  021934     CALL xTaskResumeAll
00267A  000000     NOP
770:               
771:               			/* Return to the original privilege level before exiting the
772:               			function. */
773:               			traceQUEUE_SEND_FAILED( pxQueue );
774:               			return errQUEUE_FULL;
00267C  EB0200     CLR W4
775:               		}
776:               	}
002598  000000     NOP
002668  37FF98     BRA 0x259A
002672  37FF93     BRA 0x259A
777:               }
00267E  780004     MOV W4, W0
002680  FA8000     ULNK
002682  060000     RETURN
778:               /*-----------------------------------------------------------*/
779:               
780:               #if ( configUSE_ALTERNATIVE_API == 1 )
781:               
782:               	BaseType_t xQueueAltGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, BaseType_t xCopyPosition )
783:               	{
784:               	BaseType_t xEntryTimeSet = pdFALSE;
785:               	TimeOut_t xTimeOut;
786:               	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
787:               
788:               		configASSERT( pxQueue );
789:               		configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
790:               
791:               		for( ;; )
792:               		{
793:               			taskENTER_CRITICAL();
794:               			{
795:               				/* Is there room on the queue now?  To be running we must be
796:               				the highest priority task wanting to access the queue. */
797:               				if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
798:               				{
799:               					traceQUEUE_SEND( pxQueue );
800:               					prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
801:               
802:               					/* If there was a task waiting for data to arrive on the
803:               					queue then unblock it now. */
804:               					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
805:               					{
806:               						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
807:               						{
808:               							/* The unblocked task has a priority higher than
809:               							our own so yield immediately. */
810:               							portYIELD_WITHIN_API();
811:               						}
812:               						else
813:               						{
814:               							mtCOVERAGE_TEST_MARKER();
815:               						}
816:               					}
817:               					else
818:               					{
819:               						mtCOVERAGE_TEST_MARKER();
820:               					}
821:               
822:               					taskEXIT_CRITICAL();
823:               					return pdPASS;
824:               				}
825:               				else
826:               				{
827:               					if( xTicksToWait == ( TickType_t ) 0 )
828:               					{
829:               						taskEXIT_CRITICAL();
830:               						return errQUEUE_FULL;
831:               					}
832:               					else if( xEntryTimeSet == pdFALSE )
833:               					{
834:               						vTaskSetTimeOutState( &xTimeOut );
835:               						xEntryTimeSet = pdTRUE;
836:               					}
837:               				}
838:               			}
839:               			taskEXIT_CRITICAL();
840:               
841:               			taskENTER_CRITICAL();
842:               			{
843:               				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
844:               				{
845:               					if( prvIsQueueFull( pxQueue ) != pdFALSE )
846:               					{
847:               						traceBLOCKING_ON_QUEUE_SEND( pxQueue );
848:               						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
849:               						portYIELD_WITHIN_API();
850:               					}
851:               					else
852:               					{
853:               						mtCOVERAGE_TEST_MARKER();
854:               					}
855:               				}
856:               				else
857:               				{
858:               					taskEXIT_CRITICAL();
859:               					traceQUEUE_SEND_FAILED( pxQueue );
860:               					return errQUEUE_FULL;
861:               				}
862:               			}
863:               			taskEXIT_CRITICAL();
864:               		}
865:               	}
866:               
867:               #endif /* configUSE_ALTERNATIVE_API */
868:               /*-----------------------------------------------------------*/
869:               
870:               #if ( configUSE_ALTERNATIVE_API == 1 )
871:               
872:               	BaseType_t xQueueAltGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, BaseType_t xJustPeeking )
873:               	{
874:               	BaseType_t xEntryTimeSet = pdFALSE;
875:               	TimeOut_t xTimeOut;
876:               	int8_t *pcOriginalReadPosition;
877:               	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
878:               
879:               		configASSERT( pxQueue );
880:               		configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
881:               
882:               		for( ;; )
883:               		{
884:               			taskENTER_CRITICAL();
885:               			{
886:               				if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
887:               				{
888:               					/* Remember our read position in case we are just peeking. */
889:               					pcOriginalReadPosition = pxQueue->u.pcReadFrom;
890:               
891:               					prvCopyDataFromQueue( pxQueue, pvBuffer );
892:               
893:               					if( xJustPeeking == pdFALSE )
894:               					{
895:               						traceQUEUE_RECEIVE( pxQueue );
896:               
897:               						/* Data is actually being removed (not just peeked). */
898:               						--( pxQueue->uxMessagesWaiting );
899:               
900:               						#if ( configUSE_MUTEXES == 1 )
901:               						{
902:               							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
903:               							{
904:               								/* Record the information required to implement
905:               								priority inheritance should it become necessary. */
906:               								pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle();
907:               							}
908:               							else
909:               							{
910:               								mtCOVERAGE_TEST_MARKER();
911:               							}
912:               						}
913:               						#endif
914:               
915:               						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
916:               						{
917:               							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
918:               							{
919:               								portYIELD_WITHIN_API();
920:               							}
921:               							else
922:               							{
923:               								mtCOVERAGE_TEST_MARKER();
924:               							}
925:               						}
926:               					}
927:               					else
928:               					{
929:               						traceQUEUE_PEEK( pxQueue );
930:               
931:               						/* We are not removing the data, so reset our read
932:               						pointer. */
933:               						pxQueue->u.pcReadFrom = pcOriginalReadPosition;
934:               
935:               						/* The data is being left in the queue, so see if there are
936:               						any other tasks waiting for the data. */
937:               						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
938:               						{
939:               							/* Tasks that are removed from the event list will get added to
940:               							the pending ready list as the scheduler is still suspended. */
941:               							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
942:               							{
943:               								/* The task waiting has a higher priority than this task. */
944:               								portYIELD_WITHIN_API();
945:               							}
946:               							else
947:               							{
948:               								mtCOVERAGE_TEST_MARKER();
949:               							}
950:               						}
951:               						else
952:               						{
953:               							mtCOVERAGE_TEST_MARKER();
954:               						}
955:               					}
956:               
957:               					taskEXIT_CRITICAL();
958:               					return pdPASS;
959:               				}
960:               				else
961:               				{
962:               					if( xTicksToWait == ( TickType_t ) 0 )
963:               					{
964:               						taskEXIT_CRITICAL();
965:               						traceQUEUE_RECEIVE_FAILED( pxQueue );
966:               						return errQUEUE_EMPTY;
967:               					}
968:               					else if( xEntryTimeSet == pdFALSE )
969:               					{
970:               						vTaskSetTimeOutState( &xTimeOut );
971:               						xEntryTimeSet = pdTRUE;
972:               					}
973:               				}
974:               			}
975:               			taskEXIT_CRITICAL();
976:               
977:               			taskENTER_CRITICAL();
978:               			{
979:               				if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
980:               				{
981:               					if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
982:               					{
983:               						traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
984:               
985:               						#if ( configUSE_MUTEXES == 1 )
986:               						{
987:               							if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
988:               							{
989:               								taskENTER_CRITICAL();
990:               								{
991:               									vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
992:               								}
993:               								taskEXIT_CRITICAL();
994:               							}
995:               							else
996:               							{
997:               								mtCOVERAGE_TEST_MARKER();
998:               							}
999:               						}
1000:              						#endif
1001:              
1002:              						vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
1003:              						portYIELD_WITHIN_API();
1004:              					}
1005:              					else
1006:              					{
1007:              						mtCOVERAGE_TEST_MARKER();
1008:              					}
1009:              				}
1010:              				else
1011:              				{
1012:              					taskEXIT_CRITICAL();
1013:              					traceQUEUE_RECEIVE_FAILED( pxQueue );
1014:              					return errQUEUE_EMPTY;
1015:              				}
1016:              			}
1017:              			taskEXIT_CRITICAL();
1018:              		}
1019:              	}
1020:              
1021:              
1022:              #endif /* configUSE_ALTERNATIVE_API */
1023:              /*-----------------------------------------------------------*/
1024:              
1025:              BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
1026:              {
002684  FA000E     LNK #0xE
002686  980730     MOV W0, [W14+6]
002688  980741     MOV W1, [W14+8]
00268A  980752     MOV W2, [W14+10]
00268C  980763     MOV W3, [W14+12]
1027:              BaseType_t xReturn;
1028:              UBaseType_t uxSavedInterruptStatus;
1029:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
00268E  90023E     MOV [W14+6], W4
002690  980714     MOV W4, [W14+2]
1030:              
1031:              	configASSERT( pxQueue );
1032:              	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1033:              	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
1034:              
1035:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1036:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1037:              	above the maximum system call priority are kept permanently enabled, even
1038:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1039:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1040:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1041:              	failure if a FreeRTOS API function is called from an interrupt that has been
1042:              	assigned a priority above the configured maximum system call priority.
1043:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1044:              	that have been assigned a priority at or (logically) below the maximum
1045:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1046:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1047:              	More information (albeit Cortex-M specific) is provided on the following
1048:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1049:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1050:              
1051:              	/* Similar to xQueueGenericSend, except without blocking if there is no room
1052:              	in the queue.  Also don't directly wake a task that was blocked on a queue
1053:              	read, instead return a flag to say whether a context switch is required or
1054:              	not (i.e. has a task with a higher priority than us been woken by this
1055:              	post). */
1056:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
002692  EB0200     CLR W4
002694  980724     MOV W4, [W14+4]
1057:              	{
1058:              		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
002696  90021E     MOV [W14+2], W4
002698  900AE4     MOV [W4+28], W5
00269A  90021E     MOV [W14+2], W4
00269C  900A74     MOV [W4+30], W4
00269E  528F84     SUB W5, W4, [W15]
0026A0  390003     BRA NC, 0x26A8
0026A2  90026E     MOV [W14+12], W4
0026A4  520FE2     SUB W4, #0x2, [W15]
0026A6  3A0023     BRA NZ, 0x26EE
1059:              		{
1060:              			traceQUEUE_SEND_FROM_ISR( pxQueue );
1061:              
1062:              			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
0026A8  90016E     MOV [W14+12], W2
0026AA  9000CE     MOV [W14+8], W1
0026AC  90001E     MOV [W14+2], W0
0026AE  07017A     RCALL _prvCopyDataToQueue
1063:              
1064:              			/* The event list is not altered if the queue is locked.  This will
1065:              			be done when the queue is unlocked later. */
1066:              			if( pxQueue->xTxLock == queueUNLOCKED )
0026B0  90021E     MOV [W14+2], W4
0026B2  901224     MOV [W4+36], W4
0026B4  420FE1     ADD W4, #0x1, [W15]
0026B6  3A0013     BRA NZ, 0x26DE
1067:              			{
1068:              				#if ( configUSE_QUEUE_SETS == 1 )
1069:              				{
1070:              					if( pxQueue->pxQueueSetContainer != NULL )
1071:              					{
1072:              						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) == pdTRUE )
1073:              						{
1074:              							/* The queue is a member of a queue set, and posting
1075:              							to the queue set caused a higher priority task to
1076:              							unblock.  A context switch is required. */
1077:              							if( pxHigherPriorityTaskWoken != NULL )
1078:              							{
1079:              								*pxHigherPriorityTaskWoken = pdTRUE;
1080:              							}
1081:              							else
1082:              							{
1083:              								mtCOVERAGE_TEST_MARKER();
1084:              							}
1085:              						}
1086:              						else
1087:              						{
1088:              							mtCOVERAGE_TEST_MARKER();
1089:              						}
1090:              					}
1091:              					else
1092:              					{
1093:              						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1094:              						{
1095:              							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1096:              							{
1097:              								/* The task waiting has a higher priority so record that a
1098:              								context	switch is required. */
1099:              								if( pxHigherPriorityTaskWoken != NULL )
1100:              								{
1101:              									*pxHigherPriorityTaskWoken = pdTRUE;
1102:              								}
1103:              								else
1104:              								{
1105:              									mtCOVERAGE_TEST_MARKER();
1106:              								}
1107:              							}
1108:              							else
1109:              							{
1110:              								mtCOVERAGE_TEST_MARKER();
1111:              							}
1112:              						}
1113:              						else
1114:              						{
1115:              							mtCOVERAGE_TEST_MARKER();
1116:              						}
1117:              					}
1118:              				}
1119:              				#else /* configUSE_QUEUE_SETS */
1120:              				{
1121:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
0026B8  90021E     MOV [W14+2], W4
0026BA  900A14     MOV [W4+18], W4
0026BC  520FE0     SUB W4, #0x0, [W15]
0026BE  320014     BRA Z, 0x26E8
1122:              					{
1123:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0026C0  90021E     MOV [W14+2], W4
0026C2  420272     ADD W4, #0x12, W4
0026C4  780004     MOV W4, W0
0026C6  021CCA     CALL xTaskRemoveFromEventList
0026C8  000000     NOP
0026CA  780200     MOV W0, W4
0026CC  520FE0     SUB W4, #0x0, [W15]
0026CE  32000C     BRA Z, 0x26E8
1124:              						{
1125:              							/* The task waiting has a higher priority so record that a
1126:              							context	switch is required. */
1127:              							if( pxHigherPriorityTaskWoken != NULL )
0026D0  90025E     MOV [W14+10], W4
0026D2  520FE0     SUB W4, #0x0, [W15]
0026D4  320009     BRA Z, 0x26E8
1128:              							{
1129:              								*pxHigherPriorityTaskWoken = pdTRUE;
0026D6  90025E     MOV [W14+10], W4
0026D8  200015     MOV #0x1, W5
0026DA  780A05     MOV W5, [W4]
0026DC  370005     BRA 0x26E8
1130:              							}
1131:              							else
1132:              							{
1133:              								mtCOVERAGE_TEST_MARKER();
1134:              							}
1135:              						}
1136:              						else
1137:              						{
1138:              							mtCOVERAGE_TEST_MARKER();
1139:              						}
1140:              					}
1141:              					else
1142:              					{
1143:              						mtCOVERAGE_TEST_MARKER();
1144:              					}
1145:              				}
1146:              				#endif /* configUSE_QUEUE_SETS */
1147:              			}
1148:              			else
1149:              			{
1150:              				/* Increment the lock count so the task that unlocks the queue
1151:              				knows that data was posted while it was locked. */
1152:              				++( pxQueue->xTxLock );
0026DE  90021E     MOV [W14+2], W4
0026E0  901224     MOV [W4+36], W4
0026E2  E80284     INC W4, W5
0026E4  90021E     MOV [W14+2], W4
0026E6  981225     MOV W5, [W4+36]
1153:              			}
1154:              
1155:              			xReturn = pdPASS;
0026E8  200014     MOV #0x1, W4
0026EA  780F04     MOV W4, [W14]
0026EC  370002     BRA 0x26F2
1156:              		}
1157:              		else
1158:              		{
1159:              			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
1160:              			xReturn = errQUEUE_FULL;
0026EE  EB0200     CLR W4
0026F0  780F04     MOV W4, [W14]
1161:              		}
1162:              	}
1163:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1164:              
1165:              	return xReturn;
0026F2  78021E     MOV [W14], W4
1166:              }
0026F4  780004     MOV W4, W0
0026F6  FA8000     ULNK
0026F8  060000     RETURN
1167:              /*-----------------------------------------------------------*/
1168:              
1169:              BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
1170:              {
0026FA  FA0012     LNK #0x12
0026FC  980750     MOV W0, [W14+10]
0026FE  980761     MOV W1, [W14+12]
002700  980772     MOV W2, [W14+14]
002702  980F03     MOV W3, [W14+16]
1171:              BaseType_t xEntryTimeSet = pdFALSE;
002704  EB0200     CLR W4
002706  780F04     MOV W4, [W14]
1172:              TimeOut_t xTimeOut;
1173:              int8_t *pcOriginalReadPosition;
1174:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
002708  90025E     MOV [W14+10], W4
00270A  980714     MOV W4, [W14+2]
00270C  370001     BRA 0x2710
1175:              
1176:              	configASSERT( pxQueue );
1177:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1178:              	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
1179:              	{
1180:              		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
1181:              	}
1182:              	#endif
1183:              
1184:              	/* This function relaxes the coding standard somewhat to allow return
1185:              	statements within the function itself.  This is done in the interest
1186:              	of execution time efficiency. */
1187:              
1188:              	for( ;; )
1189:              	{
1190:              		taskENTER_CRITICAL();
002710  02497A     CALL vPortEnterCritical
002712  000000     NOP
1191:              		{
1192:              			/* Is there data in the queue now?  To be running we must be
1193:              			the highest priority task wanting to access the queue. */
1194:              			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
002714  90021E     MOV [W14+2], W4
002716  900A64     MOV [W4+28], W4
002718  520FE0     SUB W4, #0x0, [W15]
00271A  32003E     BRA Z, 0x2798
1195:              			{
1196:              				/* Remember the read position in case the queue is only being
1197:              				peeked. */
1198:              				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
00271C  90021E     MOV [W14+2], W4
00271E  9002B4     MOV [W4+6], W5
002720  980725     MOV W5, [W14+4]
1199:              
1200:              				prvCopyDataFromQueue( pxQueue, pvBuffer );
002722  9000EE     MOV [W14+12], W1
002724  90001E     MOV [W14+2], W0
002726  0701A3     RCALL _prvCopyDataFromQueue
1201:              
1202:              				if( xJustPeeking == pdFALSE )
002728  900A0E     MOV [W14+16], W4
00272A  520FE0     SUB W4, #0x0, [W15]
00272C  3A001F     BRA NZ, 0x276C
1203:              				{
1204:              					traceQUEUE_RECEIVE( pxQueue );
1205:              
1206:              					/* Actually removing data, not just peeking. */
1207:              					--( pxQueue->uxMessagesWaiting );
00272E  90021E     MOV [W14+2], W4
002730  900A64     MOV [W4+28], W4
002732  E90284     DEC W4, W5
002734  90021E     MOV [W14+2], W4
002736  980A65     MOV W5, [W4+28]
1208:              
1209:              					#if ( configUSE_MUTEXES == 1 )
1210:              					{
1211:              						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
002738  90021E     MOV [W14+2], W4
00273A  780214     MOV [W4], W4
00273C  520FE0     SUB W4, #0x0, [W15]
00273E  3A0006     BRA NZ, 0x274C
1212:              						{
1213:              							/* Record the information required to implement
1214:              							priority inheritance should it become necessary. */
1215:              							pxQueue->pxMutexHolder = ( int8_t * ) xTaskGetCurrentTaskHandle(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
002740  0221F4     CALL xTaskGetCurrentTaskHandle
002742  000000     NOP
002744  780200     MOV W0, W4
002746  780284     MOV W4, W5
002748  90021E     MOV [W14+2], W4
00274A  980215     MOV W5, [W4+2]
1216:              						}
1217:              						else
1218:              						{
1219:              							mtCOVERAGE_TEST_MARKER();
1220:              						}
1221:              					}
1222:              					#endif
1223:              
1224:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
00274C  90021E     MOV [W14+2], W4
00274E  900244     MOV [W4+8], W4
002750  520FE0     SUB W4, #0x0, [W15]
002752  32001E     BRA Z, 0x2790
1225:              					{
1226:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
002754  90021E     MOV [W14+2], W4
002756  420268     ADD W4, #0x8, W4
002758  780004     MOV W4, W0
00275A  021CCA     CALL xTaskRemoveFromEventList
00275C  000000     NOP
00275E  780200     MOV W0, W4
002760  520FE1     SUB W4, #0x1, [W15]
002762  3A0016     BRA NZ, 0x2790
1227:              						{
1228:              							queueYIELD_IF_USING_PREEMPTION();
002764  024F06     CALL _vPortYield
002766  000000     NOP
002768  000000     NOP
00276A  370012     BRA 0x2790
1229:              						}
1230:              						else
1231:              						{
1232:              							mtCOVERAGE_TEST_MARKER();
1233:              						}
1234:              					}
1235:              					else
1236:              					{
1237:              						mtCOVERAGE_TEST_MARKER();
1238:              					}
1239:              				}
1240:              				else
1241:              				{
1242:              					traceQUEUE_PEEK( pxQueue );
1243:              
1244:              					/* The data is not being removed, so reset the read
1245:              					pointer. */
1246:              					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
00276C  90021E     MOV [W14+2], W4
00276E  9002AE     MOV [W14+4], W5
002770  980235     MOV W5, [W4+6]
1247:              
1248:              					/* The data is being left in the queue, so see if there are
1249:              					any other tasks waiting for the data. */
1250:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
002772  90021E     MOV [W14+2], W4
002774  900A14     MOV [W4+18], W4
002776  520FE0     SUB W4, #0x0, [W15]
002778  32000B     BRA Z, 0x2790
1251:              					{
1252:              						/* Tasks that are removed from the event list will get added to
1253:              						the pending ready list as the scheduler is still suspended. */
1254:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
00277A  90021E     MOV [W14+2], W4
00277C  420272     ADD W4, #0x12, W4
00277E  780004     MOV W4, W0
002780  021CCA     CALL xTaskRemoveFromEventList
002782  000000     NOP
002784  780200     MOV W0, W4
002786  520FE0     SUB W4, #0x0, [W15]
002788  320003     BRA Z, 0x2790
1255:              						{
1256:              							/* The task waiting has a higher priority than this task. */
1257:              							queueYIELD_IF_USING_PREEMPTION();
00278A  024F06     CALL _vPortYield
00278C  000000     NOP
00278E  000000     NOP
1258:              						}
1259:              						else
1260:              						{
1261:              							mtCOVERAGE_TEST_MARKER();
1262:              						}
1263:              					}
1264:              					else
1265:              					{
1266:              						mtCOVERAGE_TEST_MARKER();
1267:              					}
1268:              				}
1269:              
1270:              				taskEXIT_CRITICAL();
002790  02498E     CALL vPortExitCritical
002792  000000     NOP
1271:              				return pdPASS;
002794  200014     MOV #0x1, W4
002796  37005D     BRA 0x2852
1272:              			}
1273:              			else
1274:              			{
1275:              				if( xTicksToWait == ( TickType_t ) 0 )
002798  90027E     MOV [W14+14], W4
00279A  520FE0     SUB W4, #0x0, [W15]
00279C  3A0004     BRA NZ, 0x27A6
1276:              				{
1277:              					/* The queue was empty and no block time is specified (or
1278:              					the block time has expired) so leave now. */
1279:              					taskEXIT_CRITICAL();
00279E  02498E     CALL vPortExitCritical
0027A0  000000     NOP
1280:              					traceQUEUE_RECEIVE_FAILED( pxQueue );
1281:              					return errQUEUE_EMPTY;
0027A2  EB0200     CLR W4
0027A4  370056     BRA 0x2852
1282:              				}
1283:              				else if( xEntryTimeSet == pdFALSE )
0027A6  78021E     MOV [W14], W4
0027A8  520FE0     SUB W4, #0x0, [W15]
0027AA  3A0006     BRA NZ, 0x27B8
1284:              				{
1285:              					/* The queue was empty and a block time was specified so
1286:              					configure the timeout structure. */
1287:              					vTaskSetTimeOutState( &xTimeOut );
0027AC  470266     ADD W14, #0x6, W4
0027AE  780004     MOV W4, W0
0027B0  021DB8     CALL vTaskSetTimeOutState
0027B2  000000     NOP
1288:              					xEntryTimeSet = pdTRUE;
0027B4  200014     MOV #0x1, W4
0027B6  780F04     MOV W4, [W14]
1289:              				}
1290:              				else
1291:              				{
1292:              					/* Entry time was already set. */
1293:              					mtCOVERAGE_TEST_MARKER();
1294:              				}
1295:              			}
1296:              		}
1297:              		taskEXIT_CRITICAL();
0027B8  02498E     CALL vPortExitCritical
0027BA  000000     NOP
1298:              
1299:              		/* Interrupts and other tasks can send to and receive from the queue
1300:              		now the critical section has been exited. */
1301:              
1302:              		vTaskSuspendAll();
0027BC  021928     CALL vTaskSuspendAll
0027BE  000000     NOP
1303:              		prvLockQueue( pxQueue );
0027C0  02497A     CALL vPortEnterCritical
0027C2  000000     NOP
0027C4  90021E     MOV [W14+2], W4
0027C6  901214     MOV [W4+34], W4
0027C8  420FE1     ADD W4, #0x1, [W15]
0027CA  3A0003     BRA NZ, 0x27D2
0027CC  90021E     MOV [W14+2], W4
0027CE  EB0280     CLR W5
0027D0  981215     MOV W5, [W4+34]
0027D2  90021E     MOV [W14+2], W4
0027D4  901224     MOV [W4+36], W4
0027D6  420FE1     ADD W4, #0x1, [W15]
0027D8  3A0003     BRA NZ, 0x27E0
0027DA  90021E     MOV [W14+2], W4
0027DC  EB0280     CLR W5
0027DE  981225     MOV W5, [W4+36]
0027E0  02498E     CALL vPortExitCritical
0027E2  000000     NOP
1304:              
1305:              		/* Update the timeout state to see if it has expired yet. */
1306:              		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
0027E4  4702EE     ADD W14, #0xE, W5
0027E6  470266     ADD W14, #0x6, W4
0027E8  780085     MOV W5, W1
0027EA  780004     MOV W4, W0
0027EC  021DCC     CALL xTaskCheckForTimeOut
0027EE  000000     NOP
0027F0  780200     MOV W0, W4
0027F2  520FE0     SUB W4, #0x0, [W15]
0027F4  3A0029     BRA NZ, 0x2848
1307:              		{
1308:              			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
0027F6  90001E     MOV [W14+2], W0
0027F8  0701A3     RCALL _prvIsQueueEmpty
0027FA  780200     MOV W0, W4
0027FC  520FE0     SUB W4, #0x0, [W15]
0027FE  32001F     BRA Z, 0x283E
1309:              			{
1310:              				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
1311:              
1312:              				#if ( configUSE_MUTEXES == 1 )
1313:              				{
1314:              					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
002800  90021E     MOV [W14+2], W4
002802  780214     MOV [W4], W4
002804  520FE0     SUB W4, #0x0, [W15]
002806  3A0009     BRA NZ, 0x281A
1315:              					{
1316:              						taskENTER_CRITICAL();
002808  02497A     CALL vPortEnterCritical
00280A  000000     NOP
1317:              						{
1318:              							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
00280C  90021E     MOV [W14+2], W4
00280E  900214     MOV [W4+2], W4
002810  780004     MOV W4, W0
002812  022228     CALL vTaskPriorityInherit
002814  000000     NOP
1319:              						}
1320:              						taskEXIT_CRITICAL();
002816  02498E     CALL vPortExitCritical
002818  000000     NOP
1321:              					}
1322:              					else
1323:              					{
1324:              						mtCOVERAGE_TEST_MARKER();
1325:              					}
1326:              				}
1327:              				#endif
1328:              
1329:              				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
00281A  9002FE     MOV [W14+14], W5
00281C  90021E     MOV [W14+2], W4
00281E  420272     ADD W4, #0x12, W4
002820  780085     MOV W5, W1
002822  780004     MOV W4, W0
002824  021C18     CALL vTaskPlaceOnEventList
002826  000000     NOP
1330:              				prvUnlockQueue( pxQueue );
002828  90001E     MOV [W14+2], W0
00282A  070144     RCALL _prvUnlockQueue
1331:              				if( xTaskResumeAll() == pdFALSE )
00282C  021934     CALL xTaskResumeAll
00282E  000000     NOP
002830  780200     MOV W0, W4
002832  520FE0     SUB W4, #0x0, [W15]
002834  3AFF6C     BRA NZ, 0x270E
1332:              				{
1333:              					portYIELD_WITHIN_API();
002836  024F06     CALL _vPortYield
002838  000000     NOP
00283A  000000     NOP
1334:              				}
1335:              				else
1336:              				{
1337:              					mtCOVERAGE_TEST_MARKER();
1338:              				}
1339:              			}
1340:              			else
1341:              			{
1342:              				/* Try again. */
1343:              				prvUnlockQueue( pxQueue );
00283E  90001E     MOV [W14+2], W0
002840  070139     RCALL _prvUnlockQueue
1344:              				( void ) xTaskResumeAll();
002842  021934     CALL xTaskResumeAll
002844  000000     NOP
1345:              			}
1346:              		}
1347:              		else
1348:              		{
1349:              			prvUnlockQueue( pxQueue );
002848  90001E     MOV [W14+2], W0
00284A  070134     RCALL _prvUnlockQueue
1350:              			( void ) xTaskResumeAll();
00284C  021934     CALL xTaskResumeAll
00284E  000000     NOP
1351:              			traceQUEUE_RECEIVE_FAILED( pxQueue );
1352:              			return errQUEUE_EMPTY;
002850  EB0200     CLR W4
1353:              		}
1354:              	}
00270E  000000     NOP
00283C  37FF69     BRA 0x2710
002846  37FF64     BRA 0x2710
1355:              }
002852  780004     MOV W4, W0
002854  FA8000     ULNK
002856  060000     RETURN
1356:              /*-----------------------------------------------------------*/
1357:              
1358:              BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
1359:              {
002858  FA000C     LNK #0xC
00285A  980730     MOV W0, [W14+6]
00285C  980741     MOV W1, [W14+8]
00285E  980752     MOV W2, [W14+10]
1360:              BaseType_t xReturn;
1361:              UBaseType_t uxSavedInterruptStatus;
1362:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
002860  90023E     MOV [W14+6], W4
002862  980714     MOV W4, [W14+2]
1363:              
1364:              	configASSERT( pxQueue );
1365:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1366:              
1367:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1368:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1369:              	above the maximum system call priority are kept permanently enabled, even
1370:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1371:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1372:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1373:              	failure if a FreeRTOS API function is called from an interrupt that has been
1374:              	assigned a priority above the configured maximum system call priority.
1375:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1376:              	that have been assigned a priority at or (logically) below the maximum
1377:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1378:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1379:              	More information (albeit Cortex-M specific) is provided on the following
1380:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1381:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1382:              
1383:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
002864  EB0200     CLR W4
002866  980724     MOV W4, [W14+4]
1384:              	{
1385:              		/* Cannot block in an ISR, so check there is data available. */
1386:              		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
002868  90021E     MOV [W14+2], W4
00286A  900A64     MOV [W4+28], W4
00286C  520FE0     SUB W4, #0x0, [W15]
00286E  320027     BRA Z, 0x28BE
1387:              		{
1388:              			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
1389:              
1390:              			prvCopyDataFromQueue( pxQueue, pvBuffer );
002870  9000CE     MOV [W14+8], W1
002872  90001E     MOV [W14+2], W0
002874  0700FC     RCALL _prvCopyDataFromQueue
1391:              			--( pxQueue->uxMessagesWaiting );
002876  90021E     MOV [W14+2], W4
002878  900A64     MOV [W4+28], W4
00287A  E90284     DEC W4, W5
00287C  90021E     MOV [W14+2], W4
00287E  980A65     MOV W5, [W4+28]
1392:              
1393:              			/* If the queue is locked the event list will not be modified.
1394:              			Instead update the lock count so the task that unlocks the queue
1395:              			will know that an ISR has removed data while the queue was
1396:              			locked. */
1397:              			if( pxQueue->xRxLock == queueUNLOCKED )
002880  90021E     MOV [W14+2], W4
002882  901214     MOV [W4+34], W4
002884  420FE1     ADD W4, #0x1, [W15]
002886  3A0013     BRA NZ, 0x28AE
1398:              			{
1399:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
002888  90021E     MOV [W14+2], W4
00288A  900244     MOV [W4+8], W4
00288C  520FE0     SUB W4, #0x0, [W15]
00288E  320014     BRA Z, 0x28B8
1400:              				{
1401:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
002890  90021E     MOV [W14+2], W4
002892  420268     ADD W4, #0x8, W4
002894  780004     MOV W4, W0
002896  021CCA     CALL xTaskRemoveFromEventList
002898  000000     NOP
00289A  780200     MOV W0, W4
00289C  520FE0     SUB W4, #0x0, [W15]
00289E  32000C     BRA Z, 0x28B8
1402:              					{
1403:              						/* The task waiting has a higher priority than us so
1404:              						force a context switch. */
1405:              						if( pxHigherPriorityTaskWoken != NULL )
0028A0  90025E     MOV [W14+10], W4
0028A2  520FE0     SUB W4, #0x0, [W15]
0028A4  320009     BRA Z, 0x28B8
1406:              						{
1407:              							*pxHigherPriorityTaskWoken = pdTRUE;
0028A6  90025E     MOV [W14+10], W4
0028A8  200015     MOV #0x1, W5
0028AA  780A05     MOV W5, [W4]
0028AC  370005     BRA 0x28B8
1408:              						}
1409:              						else
1410:              						{
1411:              							mtCOVERAGE_TEST_MARKER();
1412:              						}
1413:              					}
1414:              					else
1415:              					{
1416:              						mtCOVERAGE_TEST_MARKER();
1417:              					}
1418:              				}
1419:              				else
1420:              				{
1421:              					mtCOVERAGE_TEST_MARKER();
1422:              				}
1423:              			}
1424:              			else
1425:              			{
1426:              				/* Increment the lock count so the task that unlocks the queue
1427:              				knows that data was removed while it was locked. */
1428:              				++( pxQueue->xRxLock );
0028AE  90021E     MOV [W14+2], W4
0028B0  901214     MOV [W4+34], W4
0028B2  E80284     INC W4, W5
0028B4  90021E     MOV [W14+2], W4
0028B6  981215     MOV W5, [W4+34]
1429:              			}
1430:              
1431:              			xReturn = pdPASS;
0028B8  200014     MOV #0x1, W4
0028BA  780F04     MOV W4, [W14]
0028BC  370002     BRA 0x28C2
1432:              		}
1433:              		else
1434:              		{
1435:              			xReturn = pdFAIL;
0028BE  EB0200     CLR W4
0028C0  780F04     MOV W4, [W14]
1436:              			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
1437:              		}
1438:              	}
1439:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1440:              
1441:              	return xReturn;
0028C2  78021E     MOV [W14], W4
1442:              }
0028C4  780004     MOV W4, W0
0028C6  FA8000     ULNK
0028C8  060000     RETURN
1443:              /*-----------------------------------------------------------*/
1444:              
1445:              BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
1446:              {
0028CA  FA000C     LNK #0xC
0028CC  980740     MOV W0, [W14+8]
0028CE  980751     MOV W1, [W14+10]
1447:              BaseType_t xReturn;
1448:              UBaseType_t uxSavedInterruptStatus;
1449:              int8_t *pcOriginalReadPosition;
1450:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
0028D0  90024E     MOV [W14+8], W4
0028D2  980714     MOV W4, [W14+2]
1451:              
1452:              	configASSERT( pxQueue );
1453:              	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
1454:              
1455:              	/* RTOS ports that support interrupt nesting have the concept of a maximum
1456:              	system call (or maximum API call) interrupt priority.  Interrupts that are
1457:              	above the maximum system call priority are kept permanently enabled, even
1458:              	when the RTOS kernel is in a critical section, but cannot make any calls to
1459:              	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
1460:              	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
1461:              	failure if a FreeRTOS API function is called from an interrupt that has been
1462:              	assigned a priority above the configured maximum system call priority.
1463:              	Only FreeRTOS functions that end in FromISR can be called from interrupts
1464:              	that have been assigned a priority at or (logically) below the maximum
1465:              	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
1466:              	safe API to ensure interrupt entry is as fast and as simple as possible.
1467:              	More information (albeit Cortex-M specific) is provided on the following
1468:              	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
1469:              	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
1470:              
1471:              	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
0028D4  EB0200     CLR W4
0028D6  980724     MOV W4, [W14+4]
1472:              	{
1473:              		/* Cannot block in an ISR, so check there is data available. */
1474:              		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
0028D8  90021E     MOV [W14+2], W4
0028DA  900A64     MOV [W4+28], W4
0028DC  520FE0     SUB W4, #0x0, [W15]
0028DE  32000C     BRA Z, 0x28F8
1475:              		{
1476:              			traceQUEUE_PEEK_FROM_ISR( pxQueue );
1477:              
1478:              			/* Remember the read position so it can be reset as nothing is
1479:              			actually being removed from the queue. */
1480:              			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
0028E0  90021E     MOV [W14+2], W4
0028E2  9002B4     MOV [W4+6], W5
0028E4  980735     MOV W5, [W14+6]
1481:              			prvCopyDataFromQueue( pxQueue, pvBuffer );
0028E6  9000DE     MOV [W14+10], W1
0028E8  90001E     MOV [W14+2], W0
0028EA  0700C1     RCALL _prvCopyDataFromQueue
1482:              			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
0028EC  90021E     MOV [W14+2], W4
0028EE  9002BE     MOV [W14+6], W5
0028F0  980235     MOV W5, [W4+6]
1483:              
1484:              			xReturn = pdPASS;
0028F2  200014     MOV #0x1, W4
0028F4  780F04     MOV W4, [W14]
0028F6  370002     BRA 0x28FC
1485:              		}
1486:              		else
1487:              		{
1488:              			xReturn = pdFAIL;
0028F8  EB0200     CLR W4
0028FA  780F04     MOV W4, [W14]
1489:              			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
1490:              		}
1491:              	}
1492:              	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
1493:              
1494:              	return xReturn;
0028FC  78021E     MOV [W14], W4
1495:              }
0028FE  780004     MOV W4, W0
002900  FA8000     ULNK
002902  060000     RETURN
1496:              /*-----------------------------------------------------------*/
1497:              
1498:              UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
1499:              {
002904  FA0004     LNK #0x4
002906  980710     MOV W0, [W14+2]
1500:              UBaseType_t uxReturn;
1501:              
1502:              	configASSERT( xQueue );
1503:              
1504:              	taskENTER_CRITICAL();
002908  02497A     CALL vPortEnterCritical
00290A  000000     NOP
1505:              	{
1506:              		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
00290C  90021E     MOV [W14+2], W4
00290E  900AE4     MOV [W4+28], W5
002910  780F05     MOV W5, [W14]
1507:              	}
1508:              	taskEXIT_CRITICAL();
002912  02498E     CALL vPortExitCritical
002914  000000     NOP
1509:              
1510:              	return uxReturn;
002916  78021E     MOV [W14], W4
1511:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
002918  780004     MOV W4, W0
00291A  FA8000     ULNK
00291C  060000     RETURN
1512:              /*-----------------------------------------------------------*/
1513:              
1514:              UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
1515:              {
00291E  FA0006     LNK #0x6
002920  980720     MOV W0, [W14+4]
1516:              UBaseType_t uxReturn;
1517:              Queue_t *pxQueue;
1518:              
1519:              	pxQueue = ( Queue_t * ) xQueue;
002922  90022E     MOV [W14+4], W4
002924  780F04     MOV W4, [W14]
1520:              	configASSERT( pxQueue );
1521:              
1522:              	taskENTER_CRITICAL();
002926  02497A     CALL vPortEnterCritical
002928  000000     NOP
1523:              	{
1524:              		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
00292A  78021E     MOV [W14], W4
00292C  900AF4     MOV [W4+30], W5
00292E  78021E     MOV [W14], W4
002930  900A64     MOV [W4+28], W4
002932  528204     SUB W5, W4, W4
002934  980714     MOV W4, [W14+2]
1525:              	}
1526:              	taskEXIT_CRITICAL();
002936  02498E     CALL vPortExitCritical
002938  000000     NOP
1527:              
1528:              	return uxReturn;
00293A  90021E     MOV [W14+2], W4
1529:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00293C  780004     MOV W4, W0
00293E  FA8000     ULNK
002940  060000     RETURN
1530:              /*-----------------------------------------------------------*/
1531:              
1532:              UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
1533:              {
002942  FA0004     LNK #0x4
002944  980710     MOV W0, [W14+2]
1534:              UBaseType_t uxReturn;
1535:              
1536:              	configASSERT( xQueue );
1537:              
1538:              	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
002946  90021E     MOV [W14+2], W4
002948  900AE4     MOV [W4+28], W5
00294A  780F05     MOV W5, [W14]
1539:              
1540:              	return uxReturn;
00294C  78021E     MOV [W14], W4
1541:              } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
00294E  780004     MOV W4, W0
002950  FA8000     ULNK
002952  060000     RETURN
1542:              /*-----------------------------------------------------------*/
1543:              
1544:              void vQueueDelete( QueueHandle_t xQueue )
1545:              {
002954  FA0004     LNK #0x4
002956  980710     MOV W0, [W14+2]
1546:              Queue_t * const pxQueue = ( Queue_t * ) xQueue;
002958  90021E     MOV [W14+2], W4
00295A  780F04     MOV W4, [W14]
1547:              
1548:              	configASSERT( pxQueue );
1549:              
1550:              	traceQUEUE_DELETE( pxQueue );
1551:              	#if ( configQUEUE_REGISTRY_SIZE > 0 )
1552:              	{
1553:              		vQueueUnregisterQueue( pxQueue );
1554:              	}
1555:              	#endif
1556:              	if( pxQueue->pcHead != NULL )
00295C  78021E     MOV [W14], W4
00295E  780214     MOV [W4], W4
002960  520FE0     SUB W4, #0x0, [W15]
002962  320005     BRA Z, 0x296E
1557:              	{
1558:              		vPortFree( pxQueue->pcHead );
002964  78021E     MOV [W14], W4
002966  780214     MOV [W4], W4
002968  780004     MOV W4, W0
00296A  024330     CALL vPortFree
00296C  000000     NOP
1559:              	}
1560:              	vPortFree( pxQueue );
00296E  78001E     MOV [W14], W0
002970  024330     CALL vPortFree
002972  000000     NOP
1561:              }
002974  FA8000     ULNK
002976  060000     RETURN
1562:              /*-----------------------------------------------------------*/
1563:              
1564:              #if ( configUSE_TRACE_FACILITY == 1 )
1565:              
1566:              	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
1567:              	{
002978  FA0002     LNK #0x2
00297A  780F00     MOV W0, [W14]
1568:              		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
00297C  78021E     MOV [W14], W4
00297E  901234     MOV [W4+38], W4
1569:              	}
002980  780004     MOV W4, W0
002982  FA8000     ULNK
002984  060000     RETURN
1570:              
1571:              #endif /* configUSE_TRACE_FACILITY */
1572:              /*-----------------------------------------------------------*/
1573:              
1574:              #if ( configUSE_TRACE_FACILITY == 1 )
1575:              
1576:              	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
1577:              	{
002986  FA0004     LNK #0x4
002988  780F00     MOV W0, [W14]
00298A  980711     MOV W1, [W14+2]
1578:              		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
00298C  78021E     MOV [W14], W4
00298E  90029E     MOV [W14+2], W5
002990  981235     MOV W5, [W4+38]
1579:              	}
002992  FA8000     ULNK
002994  060000     RETURN
1580:              
1581:              #endif /* configUSE_TRACE_FACILITY */
1582:              /*-----------------------------------------------------------*/
1583:              
1584:              #if ( configUSE_TRACE_FACILITY == 1 )
1585:              
1586:              	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
1587:              	{
002996  FA0002     LNK #0x2
002998  780F00     MOV W0, [W14]
1588:              		return ( ( Queue_t * ) xQueue )->ucQueueType;
00299A  78021E     MOV [W14], W4
00299C  906A04     MOV.B [W4+40], W4
1589:              	}
00299E  784004     MOV.B W4, W0
0029A0  FA8000     ULNK
0029A2  060000     RETURN
1590:              
1591:              #endif /* configUSE_TRACE_FACILITY */
1592:              /*-----------------------------------------------------------*/
1593:              
1594:              static void prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
1595:              {
0029A4  FA0006     LNK #0x6
0029A6  780F00     MOV W0, [W14]
0029A8  980711     MOV W1, [W14+2]
0029AA  980722     MOV W2, [W14+4]
1596:              	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
0029AC  78021E     MOV [W14], W4
0029AE  901204     MOV [W4+32], W4
0029B0  520FE0     SUB W4, #0x0, [W15]
0029B2  3A000D     BRA NZ, 0x29CE
1597:              	{
1598:              		#if ( configUSE_MUTEXES == 1 )
1599:              		{
1600:              			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
0029B4  78021E     MOV [W14], W4
0029B6  780214     MOV [W4], W4
0029B8  520FE0     SUB W4, #0x0, [W15]
0029BA  3A0052     BRA NZ, 0x2A60
1601:              			{
1602:              				/* The mutex is no longer being held. */
1603:              				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
0029BC  78021E     MOV [W14], W4
0029BE  900214     MOV [W4+2], W4
0029C0  780004     MOV W4, W0
0029C2  0222A8     CALL vTaskPriorityDisinherit
0029C4  000000     NOP
1604:              				pxQueue->pxMutexHolder = NULL;
0029C6  78021E     MOV [W14], W4
0029C8  EB0280     CLR W5
0029CA  980215     MOV W5, [W4+2]
0029CC  370049     BRA 0x2A60
1605:              			}
1606:              			else
1607:              			{
1608:              				mtCOVERAGE_TEST_MARKER();
1609:              			}
1610:              		}
1611:              		#endif /* configUSE_MUTEXES */
1612:              	}
1613:              	else if( xPosition == queueSEND_TO_BACK )
0029CE  90022E     MOV [W14+4], W4
0029D0  520FE0     SUB W4, #0x0, [W15]
0029D2  3A001B     BRA NZ, 0x2A0A
1614:              	{
1615:              		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
0029D4  78021E     MOV [W14], W4
0029D6  901284     MOV [W4+32], W5
0029D8  78021E     MOV [W14], W4
0029DA  900224     MOV [W4+4], W4
0029DC  780105     MOV W5, W2
0029DE  90009E     MOV [W14+2], W1
0029E0  780004     MOV W4, W0
0029E2  02082C     CALL _memcpy
0029E4  000000     NOP
1616:              		pxQueue->pcWriteTo += pxQueue->uxItemSize;
0029E6  78021E     MOV [W14], W4
0029E8  9002A4     MOV [W4+4], W5
0029EA  78021E     MOV [W14], W4
0029EC  901204     MOV [W4+32], W4
0029EE  428284     ADD W5, W4, W5
0029F0  78021E     MOV [W14], W4
0029F2  980225     MOV W5, [W4+4]
1617:              		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
0029F4  78021E     MOV [W14], W4
0029F6  9002A4     MOV [W4+4], W5
0029F8  78021E     MOV [W14], W4
0029FA  900214     MOV [W4+2], W4
0029FC  528F84     SUB W5, W4, [W15]
0029FE  390030     BRA NC, 0x2A60
1618:              		{
1619:              			pxQueue->pcWriteTo = pxQueue->pcHead;
002A00  78021E     MOV [W14], W4
002A02  780294     MOV [W4], W5
002A04  78021E     MOV [W14], W4
002A06  980225     MOV W5, [W4+4]
002A08  37002B     BRA 0x2A60
1620:              		}
1621:              		else
1622:              		{
1623:              			mtCOVERAGE_TEST_MARKER();
1624:              		}
1625:              	}
1626:              	else
1627:              	{
1628:              		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
002A0A  78021E     MOV [W14], W4
002A0C  901284     MOV [W4+32], W5
002A0E  78021E     MOV [W14], W4
002A10  900234     MOV [W4+6], W4
002A12  780105     MOV W5, W2
002A14  90009E     MOV [W14+2], W1
002A16  780004     MOV W4, W0
002A18  02082C     CALL _memcpy
002A1A  000000     NOP
1629:              		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
002A1C  78021E     MOV [W14], W4
002A1E  9002B4     MOV [W4+6], W5
002A20  78021E     MOV [W14], W4
002A22  901204     MOV [W4+32], W4
002A24  EA0204     NEG W4, W4
002A26  428284     ADD W5, W4, W5
002A28  78021E     MOV [W14], W4
002A2A  980235     MOV W5, [W4+6]
1630:              		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
002A2C  78021E     MOV [W14], W4
002A2E  9002B4     MOV [W4+6], W5
002A30  78021E     MOV [W14], W4
002A32  780214     MOV [W4], W4
002A34  528F84     SUB W5, W4, [W15]
002A36  310008     BRA C, 0x2A48
1631:              		{
1632:              			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
002A38  78021E     MOV [W14], W4
002A3A  900294     MOV [W4+2], W5
002A3C  78021E     MOV [W14], W4
002A3E  901204     MOV [W4+32], W4
002A40  EA0204     NEG W4, W4
002A42  428284     ADD W5, W4, W5
002A44  78021E     MOV [W14], W4
002A46  980235     MOV W5, [W4+6]
1633:              		}
1634:              		else
1635:              		{
1636:              			mtCOVERAGE_TEST_MARKER();
1637:              		}
1638:              
1639:              		if( xPosition == queueOVERWRITE )
002A48  90022E     MOV [W14+4], W4
002A4A  520FE2     SUB W4, #0x2, [W15]
002A4C  3A0009     BRA NZ, 0x2A60
1640:              		{
1641:              			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
002A4E  78021E     MOV [W14], W4
002A50  900A64     MOV [W4+28], W4
002A52  520FE0     SUB W4, #0x0, [W15]
002A54  320005     BRA Z, 0x2A60
1642:              			{
1643:              				/* An item is not being added but overwritten, so subtract
1644:              				one from the recorded number of items in the queue so when
1645:              				one is added again below the number of recorded items remains
1646:              				correct. */
1647:              				--( pxQueue->uxMessagesWaiting );
002A56  78021E     MOV [W14], W4
002A58  900A64     MOV [W4+28], W4
002A5A  E90284     DEC W4, W5
002A5C  78021E     MOV [W14], W4
002A5E  980A65     MOV W5, [W4+28]
1648:              			}
1649:              			else
1650:              			{
1651:              				mtCOVERAGE_TEST_MARKER();
1652:              			}
1653:              		}
1654:              		else
1655:              		{
1656:              			mtCOVERAGE_TEST_MARKER();
1657:              		}
1658:              	}
1659:              
1660:              	++( pxQueue->uxMessagesWaiting );
002A60  78021E     MOV [W14], W4
002A62  900A64     MOV [W4+28], W4
002A64  E80284     INC W4, W5
002A66  78021E     MOV [W14], W4
002A68  980A65     MOV W5, [W4+28]
1661:              }
002A6A  FA8000     ULNK
002A6C  060000     RETURN
1662:              /*-----------------------------------------------------------*/
1663:              
1664:              static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
1665:              {
002A6E  FA0004     LNK #0x4
002A70  780F00     MOV W0, [W14]
002A72  980711     MOV W1, [W14+2]
1666:              	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
002A74  78021E     MOV [W14], W4
002A76  780214     MOV [W4], W4
002A78  520FE0     SUB W4, #0x0, [W15]
002A7A  32001A     BRA Z, 0x2AB0
1667:              	{
1668:              		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
002A7C  78021E     MOV [W14], W4
002A7E  9002B4     MOV [W4+6], W5
002A80  78021E     MOV [W14], W4
002A82  901204     MOV [W4+32], W4
002A84  428284     ADD W5, W4, W5
002A86  78021E     MOV [W14], W4
002A88  980235     MOV W5, [W4+6]
1669:              		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
002A8A  78021E     MOV [W14], W4
002A8C  9002B4     MOV [W4+6], W5
002A8E  78021E     MOV [W14], W4
002A90  900214     MOV [W4+2], W4
002A92  528F84     SUB W5, W4, [W15]
002A94  390004     BRA NC, 0x2A9E
1670:              		{
1671:              			pxQueue->u.pcReadFrom = pxQueue->pcHead;
002A96  78021E     MOV [W14], W4
002A98  780294     MOV [W4], W5
002A9A  78021E     MOV [W14], W4
002A9C  980235     MOV W5, [W4+6]
1672:              		}
1673:              		else
1674:              		{
1675:              			mtCOVERAGE_TEST_MARKER();
1676:              		}
1677:              		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
002A9E  78021E     MOV [W14], W4
002AA0  901284     MOV [W4+32], W5
002AA2  78021E     MOV [W14], W4
002AA4  900234     MOV [W4+6], W4
002AA6  780105     MOV W5, W2
002AA8  780084     MOV W4, W1
002AAA  90001E     MOV [W14+2], W0
002AAC  02082C     CALL _memcpy
002AAE  000000     NOP
1678:              	}
1679:              	else
1680:              	{
1681:              		mtCOVERAGE_TEST_MARKER();
1682:              	}
1683:              }
002AB0  FA8000     ULNK
002AB2  060000     RETURN
1684:              /*-----------------------------------------------------------*/
1685:              
1686:              static void prvUnlockQueue( Queue_t * const pxQueue )
1687:              {
002AB4  FA0002     LNK #0x2
002AB6  780F00     MOV W0, [W14]
1688:              	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
1689:              
1690:              	/* The lock counts contains the number of extra data items placed or
1691:              	removed from the queue while the queue was locked.  When a queue is
1692:              	locked items can be added or removed, but the event lists cannot be
1693:              	updated. */
1694:              	taskENTER_CRITICAL();
002AB8  02497A     CALL vPortEnterCritical
002ABA  000000     NOP
1695:              	{
1696:              		/* See if data was added to the queue while it was locked. */
1697:              		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
002ABC  370013     BRA 0x2AE4
002AE4  78021E     MOV [W14], W4
002AE6  901224     MOV [W4+36], W4
002AE8  520FE0     SUB W4, #0x0, [W15]
002AEA  3CFFE9     BRA GT, 0x2ABE
002AEC  370001     BRA 0x2AF0
1698:              		{
1699:              			/* Data was posted while the queue was locked.  Are any tasks
1700:              			blocked waiting for data to become available? */
1701:              			#if ( configUSE_QUEUE_SETS == 1 )
1702:              			{
1703:              				if( pxQueue->pxQueueSetContainer != NULL )
1704:              				{
1705:              					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) == pdTRUE )
1706:              					{
1707:              						/* The queue is a member of a queue set, and posting to
1708:              						the queue set caused a higher priority task to unblock.
1709:              						A context switch is required. */
1710:              						vTaskMissedYield();
1711:              					}
1712:              					else
1713:              					{
1714:              						mtCOVERAGE_TEST_MARKER();
1715:              					}
1716:              				}
1717:              				else
1718:              				{
1719:              					/* Tasks that are removed from the event list will get added to
1720:              					the pending ready list as the scheduler is still suspended. */
1721:              					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1722:              					{
1723:              						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1724:              						{
1725:              							/* The task waiting has a higher priority so record that a
1726:              							context	switch is required. */
1727:              							vTaskMissedYield();
1728:              						}
1729:              						else
1730:              						{
1731:              							mtCOVERAGE_TEST_MARKER();
1732:              						}
1733:              					}
1734:              					else
1735:              					{
1736:              						break;
1737:              					}
1738:              				}
1739:              			}
1740:              			#else /* configUSE_QUEUE_SETS */
1741:              			{
1742:              				/* Tasks that are removed from the event list will get added to
1743:              				the pending ready list as the scheduler is still suspended. */
1744:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
002ABE  78021E     MOV [W14], W4
002AC0  900A14     MOV [W4+18], W4
002AC2  520FE0     SUB W4, #0x0, [W15]
002AC4  320014     BRA Z, 0x2AEE
1745:              				{
1746:              					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
002AC6  78029E     MOV [W14], W5
002AC8  428272     ADD W5, #0x12, W4
002ACA  780004     MOV W4, W0
002ACC  021CCA     CALL xTaskRemoveFromEventList
002ACE  000000     NOP
002AD0  780200     MOV W0, W4
002AD2  520FE0     SUB W4, #0x0, [W15]
002AD4  320002     BRA Z, 0x2ADA
1747:              					{
1748:              						/* The task waiting has a higher priority so record that a
1749:              						context	switch is required. */
1750:              						vTaskMissedYield();
002AD6  021E3E     CALL vTaskMissedYield
002AD8  000000     NOP
1751:              					}
1752:              					else
1753:              					{
1754:              						mtCOVERAGE_TEST_MARKER();
1755:              					}
1756:              				}
1757:              				else
1758:              				{
1759:              					break;
002AEE  000000     NOP
1760:              				}
1761:              			}
1762:              			#endif /* configUSE_QUEUE_SETS */
1763:              
1764:              			--( pxQueue->xTxLock );
002ADA  78021E     MOV [W14], W4
002ADC  901224     MOV [W4+36], W4
002ADE  E90284     DEC W4, W5
002AE0  78021E     MOV [W14], W4
002AE2  981225     MOV W5, [W4+36]
1765:              		}
1766:              
1767:              		pxQueue->xTxLock = queueUNLOCKED;
002AF0  78021E     MOV [W14], W4
002AF2  EB8280     SETM W5
002AF4  981225     MOV W5, [W4+36]
1768:              	}
1769:              	taskEXIT_CRITICAL();
002AF6  02498E     CALL vPortExitCritical
002AF8  000000     NOP
1770:              
1771:              	/* Do the same for the Rx lock. */
1772:              	taskENTER_CRITICAL();
002AFA  02497A     CALL vPortEnterCritical
002AFC  000000     NOP
1773:              	{
1774:              		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
002AFE  370013     BRA 0x2B26
002B26  78021E     MOV [W14], W4
002B28  901214     MOV [W4+34], W4
002B2A  520FE0     SUB W4, #0x0, [W15]
002B2C  3CFFE9     BRA GT, 0x2B00
002B2E  370001     BRA 0x2B32
1775:              		{
1776:              			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
002B00  78021E     MOV [W14], W4
002B02  900244     MOV [W4+8], W4
002B04  520FE0     SUB W4, #0x0, [W15]
002B06  320014     BRA Z, 0x2B30
1777:              			{
1778:              				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
002B08  78029E     MOV [W14], W5
002B0A  428268     ADD W5, #0x8, W4
002B0C  780004     MOV W4, W0
002B0E  021CCA     CALL xTaskRemoveFromEventList
002B10  000000     NOP
002B12  780200     MOV W0, W4
002B14  520FE0     SUB W4, #0x0, [W15]
002B16  320002     BRA Z, 0x2B1C
1779:              				{
1780:              					vTaskMissedYield();
002B18  021E3E     CALL vTaskMissedYield
002B1A  000000     NOP
1781:              				}
1782:              				else
1783:              				{
1784:              					mtCOVERAGE_TEST_MARKER();
1785:              				}
1786:              
1787:              				--( pxQueue->xRxLock );
002B1C  78021E     MOV [W14], W4
002B1E  901214     MOV [W4+34], W4
002B20  E90284     DEC W4, W5
002B22  78021E     MOV [W14], W4
002B24  981215     MOV W5, [W4+34]
1788:              			}
1789:              			else
1790:              			{
1791:              				break;
002B30  000000     NOP
1792:              			}
1793:              		}
1794:              
1795:              		pxQueue->xRxLock = queueUNLOCKED;
002B32  78021E     MOV [W14], W4
002B34  EB8280     SETM W5
002B36  981215     MOV W5, [W4+34]
1796:              	}
1797:              	taskEXIT_CRITICAL();
002B38  02498E     CALL vPortExitCritical
002B3A  000000     NOP
1798:              }
002B3C  FA8000     ULNK
002B3E  060000     RETURN
1799:              /*-----------------------------------------------------------*/
1800:              
1801:              static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
1802:              {
002B40  FA0004     LNK #0x4
002B42  980710     MOV W0, [W14+2]
1803:              BaseType_t xReturn;
1804:              
1805:              	taskENTER_CRITICAL();
002B44  02497A     CALL vPortEnterCritical
002B46  000000     NOP
1806:              	{
1807:              		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
002B48  90021E     MOV [W14+2], W4
002B4A  900A64     MOV [W4+28], W4
002B4C  520FE0     SUB W4, #0x0, [W15]
002B4E  3A0003     BRA NZ, 0x2B56
1808:              		{
1809:              			xReturn = pdTRUE;
002B50  200014     MOV #0x1, W4
002B52  780F04     MOV W4, [W14]
002B54  370002     BRA 0x2B5A
1810:              		}
1811:              		else
1812:              		{
1813:              			xReturn = pdFALSE;
002B56  EB0200     CLR W4
002B58  780F04     MOV W4, [W14]
1814:              		}
1815:              	}
1816:              	taskEXIT_CRITICAL();
002B5A  02498E     CALL vPortExitCritical
002B5C  000000     NOP
1817:              
1818:              	return xReturn;
002B5E  78021E     MOV [W14], W4
1819:              }
002B60  780004     MOV W4, W0
002B62  FA8000     ULNK
002B64  060000     RETURN
1820:              /*-----------------------------------------------------------*/
1821:              
1822:              BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
1823:              {
002B66  FA0004     LNK #0x4
002B68  980710     MOV W0, [W14+2]
1824:              BaseType_t xReturn;
1825:              
1826:              	configASSERT( xQueue );
1827:              	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
002B6A  90021E     MOV [W14+2], W4
002B6C  900A64     MOV [W4+28], W4
002B6E  520FE0     SUB W4, #0x0, [W15]
002B70  3A0003     BRA NZ, 0x2B78
1828:              	{
1829:              		xReturn = pdTRUE;
002B72  200014     MOV #0x1, W4
002B74  780F04     MOV W4, [W14]
002B76  370002     BRA 0x2B7C
1830:              	}
1831:              	else
1832:              	{
1833:              		xReturn = pdFALSE;
002B78  EB0200     CLR W4
002B7A  780F04     MOV W4, [W14]
1834:              	}
1835:              
1836:              	return xReturn;
002B7C  78021E     MOV [W14], W4
1837:              } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
002B7E  780004     MOV W4, W0
002B80  FA8000     ULNK
002B82  060000     RETURN
1838:              /*-----------------------------------------------------------*/
1839:              
1840:              static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
1841:              {
002B84  FA0004     LNK #0x4
002B86  980710     MOV W0, [W14+2]
1842:              BaseType_t xReturn;
1843:              
1844:              	taskENTER_CRITICAL();
002B88  02497A     CALL vPortEnterCritical
002B8A  000000     NOP
1845:              	{
1846:              		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
002B8C  90021E     MOV [W14+2], W4
002B8E  900AE4     MOV [W4+28], W5
002B90  90021E     MOV [W14+2], W4
002B92  900A74     MOV [W4+30], W4
002B94  528F84     SUB W5, W4, [W15]
002B96  3A0003     BRA NZ, 0x2B9E
1847:              		{
1848:              			xReturn = pdTRUE;
002B98  200014     MOV #0x1, W4
002B9A  780F04     MOV W4, [W14]
002B9C  370002     BRA 0x2BA2
1849:              		}
1850:              		else
1851:              		{
1852:              			xReturn = pdFALSE;
002B9E  EB0200     CLR W4
002BA0  780F04     MOV W4, [W14]
1853:              		}
1854:              	}
1855:              	taskEXIT_CRITICAL();
002BA2  02498E     CALL vPortExitCritical
002BA4  000000     NOP
1856:              
1857:              	return xReturn;
002BA6  78021E     MOV [W14], W4
1858:              }
002BA8  780004     MOV W4, W0
002BAA  FA8000     ULNK
002BAC  060000     RETURN
1859:              /*-----------------------------------------------------------*/
1860:              
1861:              BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
1862:              {
002BAE  FA0004     LNK #0x4
002BB0  980710     MOV W0, [W14+2]
1863:              BaseType_t xReturn;
1864:              
1865:              	configASSERT( xQueue );
1866:              	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
002BB2  90021E     MOV [W14+2], W4
002BB4  900AE4     MOV [W4+28], W5
002BB6  90021E     MOV [W14+2], W4
002BB8  900A74     MOV [W4+30], W4
002BBA  528F84     SUB W5, W4, [W15]
002BBC  3A0003     BRA NZ, 0x2BC4
1867:              	{
1868:              		xReturn = pdTRUE;
002BBE  200014     MOV #0x1, W4
002BC0  780F04     MOV W4, [W14]
002BC2  370002     BRA 0x2BC8
1869:              	}
1870:              	else
1871:              	{
1872:              		xReturn = pdFALSE;
002BC4  EB0200     CLR W4
002BC6  780F04     MOV W4, [W14]
1873:              	}
1874:              
1875:              	return xReturn;
002BC8  78021E     MOV [W14], W4
1876:              } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
002BCA  780004     MOV W4, W0
002BCC  FA8000     ULNK
002BCE  060000     RETURN
1877:              /*-----------------------------------------------------------*/
1878:              
1879:              #if ( configUSE_CO_ROUTINES == 1 )
1880:              
1881:              	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
1882:              	{
1883:              	BaseType_t xReturn;
1884:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1885:              
1886:              		/* If the queue is already full we may have to block.  A critical section
1887:              		is required to prevent an interrupt removing something from the queue
1888:              		between the check to see if the queue is full and blocking on the queue. */
1889:              		portDISABLE_INTERRUPTS();
1890:              		{
1891:              			if( prvIsQueueFull( pxQueue ) != pdFALSE )
1892:              			{
1893:              				/* The queue is full - do we want to block or just leave without
1894:              				posting? */
1895:              				if( xTicksToWait > ( TickType_t ) 0 )
1896:              				{
1897:              					/* As this is called from a coroutine we cannot block directly, but
1898:              					return indicating that we need to block. */
1899:              					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
1900:              					portENABLE_INTERRUPTS();
1901:              					return errQUEUE_BLOCKED;
1902:              				}
1903:              				else
1904:              				{
1905:              					portENABLE_INTERRUPTS();
1906:              					return errQUEUE_FULL;
1907:              				}
1908:              			}
1909:              		}
1910:              		portENABLE_INTERRUPTS();
1911:              
1912:              		portDISABLE_INTERRUPTS();
1913:              		{
1914:              			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
1915:              			{
1916:              				/* There is room in the queue, copy the data into the queue. */
1917:              				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
1918:              				xReturn = pdPASS;
1919:              
1920:              				/* Were any co-routines waiting for data to become available? */
1921:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
1922:              				{
1923:              					/* In this instance the co-routine could be placed directly
1924:              					into the ready list as we are within a critical section.
1925:              					Instead the same pending ready list mechanism is used as if
1926:              					the event were caused from within an interrupt. */
1927:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
1928:              					{
1929:              						/* The co-routine waiting has a higher priority so record
1930:              						that a yield might be appropriate. */
1931:              						xReturn = errQUEUE_YIELD;
1932:              					}
1933:              					else
1934:              					{
1935:              						mtCOVERAGE_TEST_MARKER();
1936:              					}
1937:              				}
1938:              				else
1939:              				{
1940:              					mtCOVERAGE_TEST_MARKER();
1941:              				}
1942:              			}
1943:              			else
1944:              			{
1945:              				xReturn = errQUEUE_FULL;
1946:              			}
1947:              		}
1948:              		portENABLE_INTERRUPTS();
1949:              
1950:              		return xReturn;
1951:              	}
1952:              
1953:              #endif /* configUSE_CO_ROUTINES */
1954:              /*-----------------------------------------------------------*/
1955:              
1956:              #if ( configUSE_CO_ROUTINES == 1 )
1957:              
1958:              	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
1959:              	{
1960:              	BaseType_t xReturn;
1961:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
1962:              
1963:              		/* If the queue is already empty we may have to block.  A critical section
1964:              		is required to prevent an interrupt adding something to the queue
1965:              		between the check to see if the queue is empty and blocking on the queue. */
1966:              		portDISABLE_INTERRUPTS();
1967:              		{
1968:              			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
1969:              			{
1970:              				/* There are no messages in the queue, do we want to block or just
1971:              				leave with nothing? */
1972:              				if( xTicksToWait > ( TickType_t ) 0 )
1973:              				{
1974:              					/* As this is a co-routine we cannot block directly, but return
1975:              					indicating that we need to block. */
1976:              					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
1977:              					portENABLE_INTERRUPTS();
1978:              					return errQUEUE_BLOCKED;
1979:              				}
1980:              				else
1981:              				{
1982:              					portENABLE_INTERRUPTS();
1983:              					return errQUEUE_FULL;
1984:              				}
1985:              			}
1986:              			else
1987:              			{
1988:              				mtCOVERAGE_TEST_MARKER();
1989:              			}
1990:              		}
1991:              		portENABLE_INTERRUPTS();
1992:              
1993:              		portDISABLE_INTERRUPTS();
1994:              		{
1995:              			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
1996:              			{
1997:              				/* Data is available from the queue. */
1998:              				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
1999:              				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2000:              				{
2001:              					pxQueue->u.pcReadFrom = pxQueue->pcHead;
2002:              				}
2003:              				else
2004:              				{
2005:              					mtCOVERAGE_TEST_MARKER();
2006:              				}
2007:              				--( pxQueue->uxMessagesWaiting );
2008:              				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
2009:              
2010:              				xReturn = pdPASS;
2011:              
2012:              				/* Were any co-routines waiting for space to become available? */
2013:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2014:              				{
2015:              					/* In this instance the co-routine could be placed directly
2016:              					into the ready list as we are within a critical section.
2017:              					Instead the same pending ready list mechanism is used as if
2018:              					the event were caused from within an interrupt. */
2019:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2020:              					{
2021:              						xReturn = errQUEUE_YIELD;
2022:              					}
2023:              					else
2024:              					{
2025:              						mtCOVERAGE_TEST_MARKER();
2026:              					}
2027:              				}
2028:              				else
2029:              				{
2030:              					mtCOVERAGE_TEST_MARKER();
2031:              				}
2032:              			}
2033:              			else
2034:              			{
2035:              				xReturn = pdFAIL;
2036:              			}
2037:              		}
2038:              		portENABLE_INTERRUPTS();
2039:              
2040:              		return xReturn;
2041:              	}
2042:              
2043:              #endif /* configUSE_CO_ROUTINES */
2044:              /*-----------------------------------------------------------*/
2045:              
2046:              #if ( configUSE_CO_ROUTINES == 1 )
2047:              
2048:              	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
2049:              	{
2050:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2051:              
2052:              		/* Cannot block within an ISR so if there is no space on the queue then
2053:              		exit without doing anything. */
2054:              		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
2055:              		{
2056:              			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
2057:              
2058:              			/* We only want to wake one co-routine per ISR, so check that a
2059:              			co-routine has not already been woken. */
2060:              			if( xCoRoutinePreviouslyWoken == pdFALSE )
2061:              			{
2062:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
2063:              				{
2064:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
2065:              					{
2066:              						return pdTRUE;
2067:              					}
2068:              					else
2069:              					{
2070:              						mtCOVERAGE_TEST_MARKER();
2071:              					}
2072:              				}
2073:              				else
2074:              				{
2075:              					mtCOVERAGE_TEST_MARKER();
2076:              				}
2077:              			}
2078:              			else
2079:              			{
2080:              				mtCOVERAGE_TEST_MARKER();
2081:              			}
2082:              		}
2083:              		else
2084:              		{
2085:              			mtCOVERAGE_TEST_MARKER();
2086:              		}
2087:              
2088:              		return xCoRoutinePreviouslyWoken;
2089:              	}
2090:              
2091:              #endif /* configUSE_CO_ROUTINES */
2092:              /*-----------------------------------------------------------*/
2093:              
2094:              #if ( configUSE_CO_ROUTINES == 1 )
2095:              
2096:              	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
2097:              	{
2098:              	BaseType_t xReturn;
2099:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
2100:              
2101:              		/* We cannot block from an ISR, so check there is data available. If
2102:              		not then just leave without doing anything. */
2103:              		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
2104:              		{
2105:              			/* Copy the data from the queue. */
2106:              			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
2107:              			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
2108:              			{
2109:              				pxQueue->u.pcReadFrom = pxQueue->pcHead;
2110:              			}
2111:              			else
2112:              			{
2113:              				mtCOVERAGE_TEST_MARKER();
2114:              			}
2115:              			--( pxQueue->uxMessagesWaiting );
2116:              			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
2117:              
2118:              			if( ( *pxCoRoutineWoken ) == pdFALSE )
2119:              			{
2120:              				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
2121:              				{
2122:              					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
2123:              					{
2124:              						*pxCoRoutineWoken = pdTRUE;
2125:              					}
2126:              					else
2127:              					{
2128:              						mtCOVERAGE_TEST_MARKER();
2129:              					}
2130:              				}
2131:              				else
2132:              				{
2133:              					mtCOVERAGE_TEST_MARKER();
2134:              				}
2135:              			}
2136:              			else
2137:              			{
2138:              				mtCOVERAGE_TEST_MARKER();
2139:              			}
2140:              
2141:              			xReturn = pdPASS;
2142:              		}
2143:              		else
2144:              		{
2145:              			xReturn = pdFAIL;
2146:              		}
2147:              
2148:              		return xReturn;
2149:              	}
2150:              
2151:              #endif /* configUSE_CO_ROUTINES */
2152:              /*-----------------------------------------------------------*/
2153:              
2154:              #if ( configQUEUE_REGISTRY_SIZE > 0 )
2155:              
2156:              	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
2157:              	{
2158:              	UBaseType_t ux;
2159:              
2160:              		/* See if there is an empty space in the registry.  A NULL name denotes
2161:              		a free slot. */
2162:              		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2163:              		{
2164:              			if( xQueueRegistry[ ux ].pcQueueName == NULL )
2165:              			{
2166:              				/* Store the information on this queue. */
2167:              				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
2168:              				xQueueRegistry[ ux ].xHandle = xQueue;
2169:              
2170:              				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
2171:              				break;
2172:              			}
2173:              			else
2174:              			{
2175:              				mtCOVERAGE_TEST_MARKER();
2176:              			}
2177:              		}
2178:              	}
2179:              
2180:              #endif /* configQUEUE_REGISTRY_SIZE */
2181:              /*-----------------------------------------------------------*/
2182:              
2183:              #if ( configQUEUE_REGISTRY_SIZE > 0 )
2184:              
2185:              	void vQueueUnregisterQueue( QueueHandle_t xQueue )
2186:              	{
2187:              	UBaseType_t ux;
2188:              
2189:              		/* See if the handle of the queue being unregistered in actually in the
2190:              		registry. */
2191:              		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
2192:              		{
2193:              			if( xQueueRegistry[ ux ].xHandle == xQueue )
2194:              			{
2195:              				/* Set the name to NULL to show that this slot if free again. */
2196:              				xQueueRegistry[ ux ].pcQueueName = NULL;
2197:              				break;
2198:              			}
2199:              			else
2200:              			{
2201:              				mtCOVERAGE_TEST_MARKER();
2202:              			}
2203:              		}
2204:              
2205:              	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
2206:              
2207:              #endif /* configQUEUE_REGISTRY_SIZE */
2208:              /*-----------------------------------------------------------*/
2209:              
2210:              #if ( configUSE_TIMERS == 1 )
2211:              
2212:              	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
2213:              	{
002BD0  FA0006     LNK #0x6
002BD2  980710     MOV W0, [W14+2]
002BD4  980721     MOV W1, [W14+4]
2214:              	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
002BD6  90021E     MOV [W14+2], W4
002BD8  780F04     MOV W4, [W14]
2215:              
2216:              		/* This function should not be called by application code hence the
2217:              		'Restricted' in its name.  It is not part of the public API.  It is
2218:              		designed for use by kernel code, and has special calling requirements.
2219:              		It can result in vListInsert() being called on a list that can only
2220:              		possibly ever have one item in it, so the list will be fast, but even
2221:              		so it should be called with the scheduler locked and not from a critical
2222:              		section. */
2223:              
2224:              		/* Only do anything if there are no messages in the queue.  This function
2225:              		will not actually cause the task to block, just place it on a blocked
2226:              		list.  It will not block until the scheduler is unlocked - at which
2227:              		time a yield will be performed.  If an item is added to the queue while
2228:              		the queue is locked, and the calling task blocks on the queue, then the
2229:              		calling task will be immediately unblocked when the queue is unlocked. */
2230:              		prvLockQueue( pxQueue );
002BDA  02497A     CALL vPortEnterCritical
002BDC  000000     NOP
002BDE  78021E     MOV [W14], W4
002BE0  901214     MOV [W4+34], W4
002BE2  420FE1     ADD W4, #0x1, [W15]
002BE4  3A0003     BRA NZ, 0x2BEC
002BE6  78021E     MOV [W14], W4
002BE8  EB0280     CLR W5
002BEA  981215     MOV W5, [W4+34]
002BEC  78021E     MOV [W14], W4
002BEE  901224     MOV [W4+36], W4
002BF0  420FE1     ADD W4, #0x1, [W15]
002BF2  3A0003     BRA NZ, 0x2BFA
002BF4  78021E     MOV [W14], W4
002BF6  EB0280     CLR W5
002BF8  981225     MOV W5, [W4+36]
002BFA  02498E     CALL vPortExitCritical
002BFC  000000     NOP
2231:              		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
002BFE  78021E     MOV [W14], W4
002C00  900A64     MOV [W4+28], W4
002C02  520FE0     SUB W4, #0x0, [W15]
002C04  3A0006     BRA NZ, 0x2C12
2232:              		{
2233:              			/* There is nothing in the queue, block for the specified period. */
2234:              			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
002C06  78029E     MOV [W14], W5
002C08  428272     ADD W5, #0x12, W4
002C0A  9000AE     MOV [W14+4], W1
002C0C  780004     MOV W4, W0
002C0E  021CA0     CALL vTaskPlaceOnEventListRestricted
002C10  000000     NOP
2235:              		}
2236:              		else
2237:              		{
2238:              			mtCOVERAGE_TEST_MARKER();
2239:              		}
2240:              		prvUnlockQueue( pxQueue );
002C12  78001E     MOV [W14], W0
002C14  07FF4F     RCALL _prvUnlockQueue
2241:              	}
002C16  FA8000     ULNK
002C18  060000     RETURN
2242:              
2243:              #endif /* configUSE_TIMERS */
2244:              /*-----------------------------------------------------------*/
2245:              
2246:              #if ( configUSE_QUEUE_SETS == 1 )
2247:              
2248:              	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
2249:              	{
2250:              	QueueSetHandle_t pxQueue;
2251:              
2252:              		pxQueue = xQueueGenericCreate( uxEventQueueLength, sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
2253:              
2254:              		return pxQueue;
2255:              	}
2256:              
2257:              #endif /* configUSE_QUEUE_SETS */
2258:              /*-----------------------------------------------------------*/
2259:              
2260:              #if ( configUSE_QUEUE_SETS == 1 )
2261:              
2262:              	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2263:              	{
2264:              	BaseType_t xReturn;
2265:              
2266:              		taskENTER_CRITICAL();
2267:              		{
2268:              			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
2269:              			{
2270:              				/* Cannot add a queue/semaphore to more than one queue set. */
2271:              				xReturn = pdFAIL;
2272:              			}
2273:              			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
2274:              			{
2275:              				/* Cannot add a queue/semaphore to a queue set if there are already
2276:              				items in the queue/semaphore. */
2277:              				xReturn = pdFAIL;
2278:              			}
2279:              			else
2280:              			{
2281:              				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
2282:              				xReturn = pdPASS;
2283:              			}
2284:              		}
2285:              		taskEXIT_CRITICAL();
2286:              
2287:              		return xReturn;
2288:              	}
2289:              
2290:              #endif /* configUSE_QUEUE_SETS */
2291:              /*-----------------------------------------------------------*/
2292:              
2293:              #if ( configUSE_QUEUE_SETS == 1 )
2294:              
2295:              	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
2296:              	{
2297:              	BaseType_t xReturn;
2298:              	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
2299:              
2300:              		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
2301:              		{
2302:              			/* The queue was not a member of the set. */
2303:              			xReturn = pdFAIL;
2304:              		}
2305:              		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
2306:              		{
2307:              			/* It is dangerous to remove a queue from a set when the queue is
2308:              			not empty because the queue set will still hold pending events for
2309:              			the queue. */
2310:              			xReturn = pdFAIL;
2311:              		}
2312:              		else
2313:              		{
2314:              			taskENTER_CRITICAL();
2315:              			{
2316:              				/* The queue is no longer contained in the set. */
2317:              				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
2318:              			}
2319:              			taskEXIT_CRITICAL();
2320:              			xReturn = pdPASS;
2321:              		}
2322:              
2323:              		return xReturn;
2324:              	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
2325:              
2326:              #endif /* configUSE_QUEUE_SETS */
2327:              /*-----------------------------------------------------------*/
2328:              
2329:              #if ( configUSE_QUEUE_SETS == 1 )
2330:              
2331:              	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
2332:              	{
2333:              	QueueSetMemberHandle_t xReturn = NULL;
2334:              
2335:              		( void ) xQueueGenericReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait, pdFALSE ); /*lint !e961 Casting from one typedef to another is not redundant. */
2336:              		return xReturn;
2337:              	}
2338:              
2339:              #endif /* configUSE_QUEUE_SETS */
2340:              /*-----------------------------------------------------------*/
2341:              
2342:              #if ( configUSE_QUEUE_SETS == 1 )
2343:              
2344:              	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
2345:              	{
2346:              	QueueSetMemberHandle_t xReturn = NULL;
2347:              
2348:              		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
2349:              		return xReturn;
2350:              	}
2351:              
2352:              #endif /* configUSE_QUEUE_SETS */
2353:              /*-----------------------------------------------------------*/
2354:              
2355:              #if ( configUSE_QUEUE_SETS == 1 )
2356:              
2357:              	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
2358:              	{
2359:              	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
2360:              	BaseType_t xReturn = pdFALSE;
2361:              
2362:              		/* This function must be called form a critical section. */
2363:              
2364:              		configASSERT( pxQueueSetContainer );
2365:              		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
2366:              
2367:              		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
2368:              		{
2369:              			traceQUEUE_SEND( pxQueueSetContainer );
2370:              			/* The data copies is the handle of the queue that contains data. */
2371:              			prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
2372:              			if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
2373:              			{
2374:              				if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
2375:              				{
2376:              					/* The task waiting has a higher priority */
2377:              					xReturn = pdTRUE;
2378:              				}
2379:              				else
2380:              				{
2381:              					mtCOVERAGE_TEST_MARKER();
2382:              				}
2383:              			}
2384:              			else
2385:              			{
2386:              				mtCOVERAGE_TEST_MARKER();
2387:              			}
2388:              		}
2389:              		else
2390:              		{
2391:              			mtCOVERAGE_TEST_MARKER();
2392:              		}
2393:              
2394:              		return xReturn;
2395:              	}
2396:              
2397:              #endif /* configUSE_QUEUE_SETS */
2398:              
2399:              
2400:              
2401:              
2402:              
2403:              
2404:              
2405:              
2406:              
2407:              
2408:              
2409:              
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/FreeRTOS/portable/MemMang/heap.c
1:                 /*
2:                     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     ***************************************************************************
8:                      *                                                                       *
9:                      *    FreeRTOS provides completely free yet professionally developed,    *
10:                     *    robust, strictly quality controlled, supported, and cross          *
11:                     *    platform software that has become a de facto standard.             *
12:                     *                                                                       *
13:                     *    Help yourself get started quickly and support the FreeRTOS         *
14:                     *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                     *                                                                       *
17:                     *    Thank you!                                                         *
18:                     *                                                                       *
19:                    ***************************************************************************
20:                
21:                    This file is part of the FreeRTOS distribution.
22:                
23:                    FreeRTOS is free software; you can redistribute it and/or modify it under
24:                    the terms of the GNU General Public License (version 2) as published by the
25:                    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                
27:                    >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                    >>! a combined work that includes FreeRTOS without being obliged to provide
29:                    >>! the source code for proprietary components outside of the FreeRTOS
30:                    >>! kernel.
31:                
32:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                    link: http://www.freertos.org/a00114.html
36:                
37:                    1 tab == 4 spaces!
38:                
39:                    ***************************************************************************
40:                     *                                                                       *
41:                     *    Having a problem?  Start by reading the FAQ "My application does   *
42:                     *    not run, what could be wrong?"                                     *
43:                     *                                                                       *
44:                     *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                     *                                                                       *
46:                    ***************************************************************************
47:                
48:                    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                    license and Real Time Engineers Ltd. contact details.
50:                
51:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                
55:                    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                    licenses offer ticketed support, indemnification and middleware.
58:                
59:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                    engineered and independently SIL3 certified version for use in safety and
61:                    mission critical applications that require provable dependability.
62:                
63:                    1 tab == 4 spaces!
64:                */
65:                
66:                /*
67:                 * A sample implementation of pvPortMalloc() and vPortFree() that combines
68:                 * (coalescences) adjacent memory blocks as they are freed, and in so doing
69:                 * limits memory fragmentation.
70:                 *
71:                 * See heap_1.c, heap_2.c and heap_3.c for alternative implementations, and the
72:                 * memory management pages of http://www.FreeRTOS.org for more information.
73:                 */
74:                #include <stdlib.h>
75:                
76:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
77:                all the API functions to use the MPU wrappers.  That should only be done when
78:                task.h is included from an application file. */
79:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
80:                
81:                #include "FreeRTOS.h"
82:                #include "task.h"
83:                
84:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
85:                
86:                /* Block sizes must not get too small. */
87:                #define heapMINIMUM_BLOCK_SIZE	( ( size_t ) ( heapSTRUCT_SIZE * 2 ) )
88:                
89:                /* Assumes 8bit bytes! */
90:                #define heapBITS_PER_BYTE		( ( size_t ) 8 )
91:                
92:                /* A few bytes might be lost to byte aligning the heap start address. */
93:                #define heapADJUSTED_HEAP_SIZE	( configTOTAL_HEAP_SIZE - portBYTE_ALIGNMENT )
94:                
95:                /* Allocate the memory for the heap. */
96:                static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];
97:                
98:                /* Define the linked list structure.  This is used to link free blocks in order
99:                of their memory address. */
100:               typedef struct A_BLOCK_LINK
101:               {
102:               	struct A_BLOCK_LINK *pxNextFreeBlock;	/*<< The next free block in the list. */
103:               	size_t xBlockSize;						/*<< The size of the free block. */
104:               } BlockLink_t;
105:               
106:               /*-----------------------------------------------------------*/
107:               
108:               /*
109:                * Inserts a block of memory that is being freed into the correct position in
110:                * the list of free memory blocks.  The block being freed will be merged with
111:                * the block in front it and/or the block behind it if the memory blocks are
112:                * adjacent to each other.
113:                */
114:               static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert );
115:               
116:               /*
117:                * Called automatically to setup the required heap structures the first time
118:                * pvPortMalloc() is called.
119:                */
120:               static void prvHeapInit( void );
121:               
122:               /*-----------------------------------------------------------*/
123:               
124:               /* The size of the structure placed at the beginning of each allocated memory
125:               block must by correctly byte aligned. */
126:               static const uint16_t heapSTRUCT_SIZE	= ( ( sizeof ( BlockLink_t ) + ( portBYTE_ALIGNMENT - 1 ) ) & ~portBYTE_ALIGNMENT_MASK );
127:               
128:               /* Ensure the pxEnd pointer will end up on the correct byte alignment. */
129:               static const size_t xTotalHeapSize = ( ( size_t ) heapADJUSTED_HEAP_SIZE ) & ( ( size_t ) ~portBYTE_ALIGNMENT_MASK );
130:               
131:               /* Create a couple of list links to mark the start and end of the list. */
132:               static BlockLink_t xStart, *pxEnd = NULL;
133:               
134:               /* Keeps track of the number of free bytes remaining, but says nothing about
135:               fragmentation. */
136:               static size_t xFreeBytesRemaining = ( ( size_t ) heapADJUSTED_HEAP_SIZE ) & ( ( size_t ) ~portBYTE_ALIGNMENT_MASK );
137:               static size_t xMinimumEverFreeBytesRemaining = ( ( size_t ) heapADJUSTED_HEAP_SIZE ) & ( ( size_t ) ~portBYTE_ALIGNMENT_MASK );
138:               
139:               /* Gets set to the top bit of an size_t type.  When this bit in the xBlockSize
140:               member of an BlockLink_t structure is set then the block belongs to the
141:               application.  When the bit is free the block is still part of the free heap
142:               space. */
143:               static size_t xBlockAllocatedBit = 0;
144:               
145:               /*-----------------------------------------------------------*/
146:               
147:               void *pvPortMalloc( size_t xWantedSize )
148:               {
004240  FA000A     LNK #0xA
004242  980740     MOV W0, [W14+8]
149:               BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
150:               void *pvReturn = NULL;
004244  EB0200     CLR W4
004246  980724     MOV W4, [W14+4]
151:               
152:               	vTaskSuspendAll();
004248  021928     CALL vTaskSuspendAll
00424A  000000     NOP
153:               	{
154:               		/* If this is the first call to malloc then the heap will require
155:               		initialisation to setup the list of free blocks. */
156:               		if( pxEnd == NULL )
00424C  82F3A4     MOV pxEnd, W4
00424E  520FE0     SUB W4, #0x0, [W15]
004250  3A0001     BRA NZ, 0x4254
157:               		{
158:               			prvHeapInit();
004252  0700A5     RCALL _prvHeapInit
159:               		}
160:               		else
161:               		{
162:               			mtCOVERAGE_TEST_MARKER();
163:               		}
164:               
165:               		/* Check the requested block size is not so large that the top bit is
166:               		set.  The top bit of the block size member of the BlockLink_t structure
167:               		is used to determine who owns the block - the application or the
168:               		kernel, so it must be free. */
169:               		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
004254  82F3B5     MOV xBlockAllocatedBit, W5
004256  90024E     MOV [W14+8], W4
004258  628204     AND W5, W4, W4
00425A  520FE0     SUB W4, #0x0, [W15]
00425C  3A0063     BRA NZ, 0x4324
170:               		{
171:               			/* The wanted size is increased so it can contain a BlockLink_t
172:               			structure in addition to the requested amount of bytes. */
173:               			if( xWantedSize > 0 )
00425E  90024E     MOV [W14+8], W4
004260  520FE0     SUB W4, #0x0, [W15]
004262  32000E     BRA Z, 0x4280
174:               			{
175:               				xWantedSize += heapSTRUCT_SIZE;
004264  84A0F4     MOV 0x941E, W4
004266  9002CE     MOV [W14+8], W5
004268  428204     ADD W5, W4, W4
00426A  980744     MOV W4, [W14+8]
176:               
177:               				/* Ensure that blocks are always aligned to the required number
178:               				of bytes. */
179:               				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
00426C  90024E     MOV [W14+8], W4
00426E  620261     AND W4, #0x1, W4
004270  784204     MOV.B W4, W4
004272  524FE0     SUB.B W4, #0x0, [W15]
004274  320005     BRA Z, 0x4280
180:               				{
181:               					/* Byte alignment required. */
182:               					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
004276  9002CE     MOV [W14+8], W5
004278  2FFFE4     MOV #0xFFFE, W4
00427A  628204     AND W5, W4, W4
00427C  E88204     INC2 W4, W4
00427E  980744     MOV W4, [W14+8]
183:               				}
184:               				else
185:               				{
186:               					mtCOVERAGE_TEST_MARKER();
187:               				}
188:               			}
189:               			else
190:               			{
191:               				mtCOVERAGE_TEST_MARKER();
192:               			}
193:               
194:               			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
004280  90024E     MOV [W14+8], W4
004282  520FE0     SUB W4, #0x0, [W15]
004284  32004F     BRA Z, 0x4324
004286  8302C4     MOV xFreeBytesRemaining, W4
004288  9002CE     MOV [W14+8], W5
00428A  528F84     SUB W5, W4, [W15]
00428C  3E004B     BRA GTU, 0x4324
195:               			{
196:               				/* Traverse the list from the start	(lowest address) block until
197:               				one	of adequate size is found. */
198:               				pxPreviousBlock = &xStart;
00428E  25E704     MOV #0x5E70, W4
004290  980714     MOV W4, [W14+2]
199:               				pxBlock = xStart.pxNextFreeBlock;
004292  82F384     MOV xStart, W4
004294  780F04     MOV W4, [W14]
200:               				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
004296  370004     BRA 0x42A0
0042A0  78021E     MOV [W14], W4
0042A2  900294     MOV [W4+2], W5
0042A4  90024E     MOV [W14+8], W4
0042A6  528F84     SUB W5, W4, [W15]
0042A8  310004     BRA C, 0x42B2
0042AA  78021E     MOV [W14], W4
0042AC  780214     MOV [W4], W4
0042AE  520FE0     SUB W4, #0x0, [W15]
0042B0  3AFFF3     BRA NZ, 0x4298
201:               				{
202:               					pxPreviousBlock = pxBlock;
004298  78029E     MOV [W14], W5
00429A  980715     MOV W5, [W14+2]
203:               					pxBlock = pxBlock->pxNextFreeBlock;
00429C  78021E     MOV [W14], W4
00429E  780F14     MOV [W4], [W14]
204:               				}
205:               
206:               				/* If the end marker was reached then a block of adequate size
207:               				was	not found. */
208:               				if( pxBlock != pxEnd )
0042B2  82F3A4     MOV pxEnd, W4
0042B4  78029E     MOV [W14], W5
0042B6  528F84     SUB W5, W4, [W15]
0042B8  320035     BRA Z, 0x4324
209:               				{
210:               					/* Return the memory space pointed to - jumping over the
211:               					BlockLink_t structure at its start. */
212:               					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
0042BA  90021E     MOV [W14+2], W4
0042BC  780294     MOV [W4], W5
0042BE  84A0F4     MOV 0x941E, W4
0042C0  428204     ADD W5, W4, W4
0042C2  980724     MOV W4, [W14+4]
213:               
214:               					/* This block is being returned for use so must be taken out
215:               					of the list of free blocks. */
216:               					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
0042C4  78021E     MOV [W14], W4
0042C6  780294     MOV [W4], W5
0042C8  90021E     MOV [W14+2], W4
0042CA  780A05     MOV W5, [W4]
217:               
218:               					/* If the block is larger than required it can be split into
219:               					two. */
220:               					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
0042CC  78021E     MOV [W14], W4
0042CE  900294     MOV [W4+2], W5
0042D0  90024E     MOV [W14+8], W4
0042D2  528284     SUB W5, W4, W5
0042D4  84A0F4     MOV 0x941E, W4
0042D6  420204     ADD W4, W4, W4
0042D8  528F84     SUB W5, W4, [W15]
0042DA  36000E     BRA LEU, 0x42F8
221:               					{
222:               						/* This block is to be split into two.  Create a new
223:               						block following the number of bytes requested. The void
224:               						cast is used to prevent byte alignment warnings from the
225:               						compiler. */
226:               						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
0042DC  90024E     MOV [W14+8], W4
0042DE  42021E     ADD W4, [W14], W4
0042E0  980734     MOV W4, [W14+6]
227:               
228:               						/* Calculate the sizes of two blocks split from the
229:               						single block. */
230:               						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
0042E2  78021E     MOV [W14], W4
0042E4  900294     MOV [W4+2], W5
0042E6  90024E     MOV [W14+8], W4
0042E8  528284     SUB W5, W4, W5
0042EA  90023E     MOV [W14+6], W4
0042EC  980215     MOV W5, [W4+2]
231:               						pxBlock->xBlockSize = xWantedSize;
0042EE  78021E     MOV [W14], W4
0042F0  90034E     MOV [W14+8], W6
0042F2  980216     MOV W6, [W4+2]
232:               
233:               						/* Insert the new block into the list of free blocks. */
234:               						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
0042F4  90003E     MOV [W14+6], W0
0042F6  07007E     RCALL _prvInsertBlockIntoFreeList
235:               					}
236:               					else
237:               					{
238:               						mtCOVERAGE_TEST_MARKER();
239:               					}
240:               
241:               					xFreeBytesRemaining -= pxBlock->xBlockSize;
0042F8  8302C5     MOV xFreeBytesRemaining, W5
0042FA  78021E     MOV [W14], W4
0042FC  900214     MOV [W4+2], W4
0042FE  528204     SUB W5, W4, W4
004300  8B02C4     MOV W4, xFreeBytesRemaining
242:               
243:               					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
004302  8302C5     MOV xFreeBytesRemaining, W5
004304  8302D4     MOV xMinimumEverFreeBytesRemaining, W4
004306  528F84     SUB W5, W4, [W15]
004308  310002     BRA C, 0x430E
244:               					{
245:               						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
00430A  8302C4     MOV xFreeBytesRemaining, W4
00430C  8B02D4     MOV W4, xMinimumEverFreeBytesRemaining
246:               					}
247:               					else
248:               					{
249:               						mtCOVERAGE_TEST_MARKER();
250:               					}
251:               
252:               					/* The block is being returned - it is allocated and owned
253:               					by the application and has no "next" block. */
254:               					pxBlock->xBlockSize |= xBlockAllocatedBit;
00430E  78021E     MOV [W14], W4
004310  900294     MOV [W4+2], W5
004312  82F3B4     MOV xBlockAllocatedBit, W4
004314  780304     MOV W4, W6
004316  730305     IOR W6, W5, W6
004318  780286     MOV W6, W5
00431A  78021E     MOV [W14], W4
00431C  980215     MOV W5, [W4+2]
255:               					pxBlock->pxNextFreeBlock = NULL;
00431E  78021E     MOV [W14], W4
004320  EB0280     CLR W5
004322  780A05     MOV W5, [W4]
256:               				}
257:               				else
258:               				{
259:               					mtCOVERAGE_TEST_MARKER();
260:               				}
261:               			}
262:               			else
263:               			{
264:               				mtCOVERAGE_TEST_MARKER();
265:               			}
266:               		}
267:               		else
268:               		{
269:               			mtCOVERAGE_TEST_MARKER();
270:               		}
271:               
272:               		traceMALLOC( pvReturn, xWantedSize );
273:               	}
274:               	xTaskResumeAll();
004324  021934     CALL xTaskResumeAll
004326  000000     NOP
275:               
276:               	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
277:               	{
278:               		if( pvReturn == NULL )
279:               		{
280:               			extern void vApplicationMallocFailedHook( void );
281:               			vApplicationMallocFailedHook();
282:               		}
283:               		else
284:               		{
285:               			mtCOVERAGE_TEST_MARKER();
286:               		}
287:               	}
288:               	#endif
289:               
290:               	return pvReturn;
004328  90022E     MOV [W14+4], W4
291:               }
00432A  780004     MOV W4, W0
00432C  FA8000     ULNK
00432E  060000     RETURN
292:               /*-----------------------------------------------------------*/
293:               
294:               void vPortFree( void *pv )
295:               {
004330  FA0006     LNK #0x6
004332  980720     MOV W0, [W14+4]
296:               uint8_t *puc = ( uint8_t * ) pv;
004334  90022E     MOV [W14+4], W4
004336  780F04     MOV W4, [W14]
297:               BlockLink_t *pxLink;
298:               
299:               	if( pv != NULL )
004338  90022E     MOV [W14+4], W4
00433A  520FE0     SUB W4, #0x0, [W15]
00433C  320021     BRA Z, 0x4380
300:               	{
301:               		/* The memory being freed will have an BlockLink_t structure immediately
302:               		before it. */
303:               		puc -= heapSTRUCT_SIZE;
00433E  84A0F4     MOV 0x941E, W4
004340  EA0204     NEG W4, W4
004342  420F1E     ADD W4, [W14], [W14]
304:               
305:               		/* This casting is to keep the compiler from issuing warnings. */
306:               		pxLink = ( void * ) puc;
004344  78021E     MOV [W14], W4
004346  980714     MOV W4, [W14+2]
307:               
308:               		/* Check the block is actually allocated. */
309:               		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
310:               		configASSERT( pxLink->pxNextFreeBlock == NULL );
311:               
312:               		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
004348  90021E     MOV [W14+2], W4
00434A  900294     MOV [W4+2], W5
00434C  82F3B4     MOV xBlockAllocatedBit, W4
00434E  628204     AND W5, W4, W4
004350  520FE0     SUB W4, #0x0, [W15]
004352  320016     BRA Z, 0x4380
313:               		{
314:               			if( pxLink->pxNextFreeBlock == NULL )
004354  90021E     MOV [W14+2], W4
004356  780214     MOV [W4], W4
004358  520FE0     SUB W4, #0x0, [W15]
00435A  3A0012     BRA NZ, 0x4380
315:               			{
316:               				/* The block is being returned to the heap - it is no longer
317:               				allocated. */
318:               				pxLink->xBlockSize &= ~xBlockAllocatedBit;
00435C  90021E     MOV [W14+2], W4
00435E  900294     MOV [W4+2], W5
004360  82F3B4     MOV xBlockAllocatedBit, W4
004362  EA8204     COM W4, W4
004364  628284     AND W5, W4, W5
004366  90021E     MOV [W14+2], W4
004368  980215     MOV W5, [W4+2]
319:               
320:               				vTaskSuspendAll();
00436A  021928     CALL vTaskSuspendAll
00436C  000000     NOP
321:               				{
322:               					/* Add this block to the list of free blocks. */
323:               					xFreeBytesRemaining += pxLink->xBlockSize;
00436E  90021E     MOV [W14+2], W4
004370  900294     MOV [W4+2], W5
004372  8302C4     MOV xFreeBytesRemaining, W4
004374  428204     ADD W5, W4, W4
004376  8B02C4     MOV W4, xFreeBytesRemaining
324:               					traceFREE( pv, pxLink->xBlockSize );
325:               					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );					
004378  90001E     MOV [W14+2], W0
00437A  07003C     RCALL _prvInsertBlockIntoFreeList
326:               				}
327:               				xTaskResumeAll();
00437C  021934     CALL xTaskResumeAll
00437E  000000     NOP
328:               			}
329:               			else
330:               			{
331:               				mtCOVERAGE_TEST_MARKER();
332:               			}
333:               		}
334:               		else
335:               		{
336:               			mtCOVERAGE_TEST_MARKER();
337:               		}
338:               	}
339:               }
004380  FA8000     ULNK
004382  060000     RETURN
340:               /*-----------------------------------------------------------*/
341:               
342:               size_t xPortGetFreeHeapSize( void )
343:               {
004384  FA0000     LNK #0x0
344:               	return xFreeBytesRemaining;
004386  8302C4     MOV xFreeBytesRemaining, W4
345:               }
004388  780004     MOV W4, W0
00438A  FA8000     ULNK
00438C  060000     RETURN
346:               /*-----------------------------------------------------------*/
347:               
348:               size_t xPortGetMinimumEverFreeHeapSize( void )
349:               {
00438E  FA0000     LNK #0x0
350:               	return xMinimumEverFreeBytesRemaining;
004390  8302D4     MOV xMinimumEverFreeBytesRemaining, W4
351:               }
004392  780004     MOV W4, W0
004394  FA8000     ULNK
004396  060000     RETURN
352:               /*-----------------------------------------------------------*/
353:               
354:               void vPortInitialiseBlocks( void )
355:               {
004398  FA0000     LNK #0x0
356:               	/* This just exists to keep the linker quiet. */
357:               }
00439A  FA8000     ULNK
00439C  060000     RETURN
358:               /*-----------------------------------------------------------*/
359:               
360:               static void prvHeapInit( void )
361:               {
00439E  FA0006     LNK #0x6
362:               BlockLink_t *pxFirstFreeBlock;
363:               uint8_t *pucHeapEnd, *pucAlignedHeap;
364:               
365:               	/* Ensure the heap starts on a correctly aligned boundary. */
366:               	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
0043A0  210525     MOV #0x1052, W5
0043A2  2FFFE4     MOV #0xFFFE, W4
0043A4  628204     AND W5, W4, W4
0043A6  780F04     MOV W4, [W14]
367:               
368:               	/* xStart is used to hold a pointer to the first item in the list of free
369:               	blocks.  The void cast is used to prevent compiler warnings. */
370:               	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
0043A8  78021E     MOV [W14], W4
0043AA  8AF384     MOV W4, xStart
371:               	xStart.xBlockSize = ( size_t ) 0;
0043AC  EB0200     CLR W4
0043AE  8AF394     MOV W4, 0x5E72
372:               
373:               	/* pxEnd is used to mark the end of the list of free blocks and is inserted
374:               	at the end of the heap space. */
375:               	pucHeapEnd = pucAlignedHeap + xTotalHeapSize;
0043B0  84A104     MOV 0x9420, W4
0043B2  42021E     ADD W4, [W14], W4
0043B4  980714     MOV W4, [W14+2]
376:               	pucHeapEnd -= heapSTRUCT_SIZE;
0043B6  84A0F4     MOV 0x941E, W4
0043B8  EA0204     NEG W4, W4
0043BA  90029E     MOV [W14+2], W5
0043BC  428204     ADD W5, W4, W4
0043BE  980714     MOV W4, [W14+2]
377:               	pxEnd = ( void * ) pucHeapEnd;
0043C0  90021E     MOV [W14+2], W4
0043C2  8AF3A4     MOV W4, pxEnd
378:               	configASSERT( ( ( ( uint32_t ) pxEnd ) & ( ( uint32_t ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
379:               	pxEnd->xBlockSize = 0;
0043C4  82F3A4     MOV pxEnd, W4
0043C6  EB0280     CLR W5
0043C8  980215     MOV W5, [W4+2]
380:               	pxEnd->pxNextFreeBlock = NULL;
0043CA  82F3A4     MOV pxEnd, W4
0043CC  EB0280     CLR W5
0043CE  780A05     MOV W5, [W4]
381:               
382:               	/* To start with there is a single free block that is sized to take up the
383:               	entire heap space, minus the space taken by pxEnd. */
384:               	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
0043D0  78021E     MOV [W14], W4
0043D2  980724     MOV W4, [W14+4]
385:               	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
0043D4  84A105     MOV 0x9420, W5
0043D6  84A0F4     MOV 0x941E, W4
0043D8  528284     SUB W5, W4, W5
0043DA  90022E     MOV [W14+4], W4
0043DC  980215     MOV W5, [W4+2]
386:               	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
0043DE  82F3A5     MOV pxEnd, W5
0043E0  90022E     MOV [W14+4], W4
0043E2  780A05     MOV W5, [W4]
387:               
388:               	/* The heap now contains pxEnd. */
389:               	xFreeBytesRemaining -= heapSTRUCT_SIZE;
0043E4  8302C5     MOV xFreeBytesRemaining, W5
0043E6  84A0F4     MOV 0x941E, W4
0043E8  528204     SUB W5, W4, W4
0043EA  8B02C4     MOV W4, xFreeBytesRemaining
390:               
391:               	/* Work out the position of the top bit in a size_t variable. */
392:               	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
0043EC  280004     MOV #0x8000, W4
0043EE  8AF3B4     MOV W4, xBlockAllocatedBit
393:               }
0043F0  FA8000     ULNK
0043F2  060000     RETURN
394:               /*-----------------------------------------------------------*/
395:               
396:               static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
397:               {
0043F4  FA0006     LNK #0x6
0043F6  980720     MOV W0, [W14+4]
398:               BlockLink_t *pxIterator;
399:               uint8_t *puc;
400:               
401:               	/* Iterate through the list until a block is found that has a higher address
402:               	than the block being inserted. */
403:               	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
0043F8  25E704     MOV #0x5E70, W4
0043FA  780F04     MOV W4, [W14]
0043FC  370002     BRA 0x4402
0043FE  78021E     MOV [W14], W4
004400  780F14     MOV [W4], [W14]
004402  78021E     MOV [W14], W4
004404  780294     MOV [W4], W5
004406  90022E     MOV [W14+4], W4
004408  528F84     SUB W5, W4, [W15]
00440A  39FFF9     BRA NC, 0x43FE
404:               	{
405:               		/* Nothing to do here, just iterate to the right position. */
406:               	}
407:               
408:               	/* Do the block being inserted, and the block it is being inserted after
409:               	make a contiguous block of memory? */
410:               	puc = ( uint8_t * ) pxIterator;
00440C  78021E     MOV [W14], W4
00440E  980714     MOV W4, [W14+2]
411:               	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
004410  78021E     MOV [W14], W4
004412  900214     MOV [W4+2], W4
004414  90029E     MOV [W14+2], W5
004416  428284     ADD W5, W4, W5
004418  90022E     MOV [W14+4], W4
00441A  528F84     SUB W5, W4, [W15]
00441C  3A0009     BRA NZ, 0x4430
412:               	{
413:               		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
00441E  78021E     MOV [W14], W4
004420  900294     MOV [W4+2], W5
004422  90022E     MOV [W14+4], W4
004424  900214     MOV [W4+2], W4
004426  428284     ADD W5, W4, W5
004428  78021E     MOV [W14], W4
00442A  980215     MOV W5, [W4+2]
414:               		pxBlockToInsert = pxIterator;
00442C  78029E     MOV [W14], W5
00442E  980725     MOV W5, [W14+4]
415:               	}
416:               	else
417:               	{
418:               		mtCOVERAGE_TEST_MARKER();
419:               	}
420:               
421:               	/* Do the block being inserted, and the block it is being inserted before
422:               	make a contiguous block of memory? */
423:               	puc = ( uint8_t * ) pxBlockToInsert;
004430  90022E     MOV [W14+4], W4
004432  980714     MOV W4, [W14+2]
424:               	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
004434  90022E     MOV [W14+4], W4
004436  900214     MOV [W4+2], W4
004438  90029E     MOV [W14+2], W5
00443A  428284     ADD W5, W4, W5
00443C  78021E     MOV [W14], W4
00443E  780214     MOV [W4], W4
004440  528F84     SUB W5, W4, [W15]
004442  3A0017     BRA NZ, 0x4472
425:               	{
426:               		if( pxIterator->pxNextFreeBlock != pxEnd )
004444  78021E     MOV [W14], W4
004446  780294     MOV [W4], W5
004448  82F3A4     MOV pxEnd, W4
00444A  528F84     SUB W5, W4, [W15]
00444C  32000E     BRA Z, 0x446A
427:               		{
428:               			/* Form one big block from the two blocks. */
429:               			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
00444E  90022E     MOV [W14+4], W4
004450  900294     MOV [W4+2], W5
004452  78021E     MOV [W14], W4
004454  780214     MOV [W4], W4
004456  900214     MOV [W4+2], W4
004458  428284     ADD W5, W4, W5
00445A  90022E     MOV [W14+4], W4
00445C  980215     MOV W5, [W4+2]
430:               			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
00445E  78021E     MOV [W14], W4
004460  780214     MOV [W4], W4
004462  780294     MOV [W4], W5
004464  90022E     MOV [W14+4], W4
004466  780A05     MOV W5, [W4]
004468  370008     BRA 0x447A
431:               		}
432:               		else
433:               		{
434:               			pxBlockToInsert->pxNextFreeBlock = pxEnd;
00446A  82F3A5     MOV pxEnd, W5
00446C  90022E     MOV [W14+4], W4
00446E  780A05     MOV W5, [W4]
004470  370004     BRA 0x447A
435:               		}
436:               	}
437:               	else
438:               	{
439:               		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
004472  78021E     MOV [W14], W4
004474  780294     MOV [W4], W5
004476  90022E     MOV [W14+4], W4
004478  780A05     MOV W5, [W4]
440:               	}
441:               
442:               	/* If the block being inserted plugged a gab, so was merged with the block
443:               	before and the block after, then it's pxNextFreeBlock pointer will have
444:               	already been set, and should not be set here as that would make it point
445:               	to itself. */
446:               	if( pxIterator != pxBlockToInsert )
00447A  90022E     MOV [W14+4], W4
00447C  78029E     MOV [W14], W5
00447E  528F84     SUB W5, W4, [W15]
004480  320003     BRA Z, 0x4488
447:               	{
448:               		pxIterator->pxNextFreeBlock = pxBlockToInsert;
004482  78021E     MOV [W14], W4
004484  9002AE     MOV [W14+4], W5
004486  780A05     MOV W5, [W4]
449:               	}
450:               	else
451:               	{
452:               		mtCOVERAGE_TEST_MARKER();
453:               	}
454:               }
004488  FA8000     ULNK
00448A  060000     RETURN
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/FreeRTOS/portable/MPLAB/PIC24_dsPIC/portasm_PIC24.S
                                                  1:     /*
                                                  2:         FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd. 
                                                  3:         All rights reserved
                                                  4:     
                                                  5:         VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
                                                  6:     
                                                  7:         ***************************************************************************
                                                  8:          *                                                                       *
                                                  9:          *    FreeRTOS provides completely free yet professionally developed,    *
                                                  10:         *    robust, strictly quality controlled, supported, and cross          *
                                                  11:         *    platform software that has become a de facto standard.             *
                                                  12:         *                                                                       *
                                                  13:         *    Help yourself get started quickly and support the FreeRTOS         *
                                                  14:         *    project by purchasing a FreeRTOS tutorial book, reference          *
                                                  15:         *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
                                                  16:         *                                                                       *
                                                  17:         *    Thank you!                                                         *
                                                  18:         *                                                                       *
                                                  19:        ***************************************************************************
                                                  20:    
                                                  21:        This file is part of the FreeRTOS distribution.
                                                  22:    
                                                  23:        FreeRTOS is free software; you can redistribute it and/or modify it under
                                                  24:        the terms of the GNU General Public License (version 2) as published by the
                                                  25:        Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
                                                  26:    
                                                  27:        >>! NOTE: The modification to the GPL is included to allow you to distribute
                                                  28:        >>! a combined work that includes FreeRTOS without being obliged to provide
                                                  29:        >>! the source code for proprietary components outside of the FreeRTOS
                                                  30:        >>! kernel.
                                                  31:    
                                                  32:        FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
                                                  33:        WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
                                                  34:        FOR A PARTICULAR PURPOSE.  Full license text is available from the following
                                                  35:        link: http://www.freertos.org/a00114.html
                                                  36:    
                                                  37:        1 tab == 4 spaces!
                                                  38:    
                                                  39:        ***************************************************************************
                                                  40:         *                                                                       *
                                                  41:         *    Having a problem?  Start by reading the FAQ "My application does   *
                                                  42:         *    not run, what could be wrong?"                                     *
                                                  43:         *                                                                       *
                                                  44:         *    http://www.FreeRTOS.org/FAQHelp.html                               *
                                                  45:         *                                                                       *
                                                  46:        ***************************************************************************
                                                  47:    
                                                  48:        http://www.FreeRTOS.org - Documentation, books, training, latest versions,
                                                  49:        license and Real Time Engineers Ltd. contact details.
                                                  50:    
                                                  51:        http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
                                                  52:        including FreeRTOS+Trace - an indispensable productivity tool, a DOS
                                                  53:        compatible FAT file system, and our tiny thread aware UDP/IP stack.
                                                  54:    
                                                  55:        http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
                                                  56:        Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
                                                  57:        licenses offer ticketed support, indemnification and middleware.
                                                  58:    
                                                  59:        http://www.SafeRTOS.com - High Integrity Systems also provide a safety
                                                  60:        engineered and independently SIL3 certified version for use in safety and
                                                  61:        mission critical applications that require provable dependability.
                                                  62:    
                                                  63:        1 tab == 4 spaces!
                                                  64:    */
                                                  65:    
                                                  66:    #if defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ )
                                                  67:    
                                                  68:            .global _vPortYield
                                                  69:    		.extern _vTaskSwitchContext
                                                  70:    		.extern uxCriticalNesting
                                                  71:    
                                                  72:    _vPortYield:
                                                  73:    
004F06  F80042     PUSH SR                        74:    		PUSH	SR						/* Save the SR used by the task.... */
004F08  781F80     MOV W0, [W15++]                75:    		PUSH	W0						/* ....then disable interrupts. */
004F0A  200200     MOV #0x20, W0                  76:    		MOV		#32, W0
004F0C  880210     MOV W0, SR                     77:    		MOV		W0, SR
004F0E  781F81     MOV W1, [W15++]                78:    		PUSH	W1						/* Save registers to the stack. */
004F10  BE9F82     MOV.D W2, [W15++]              79:    		PUSH.D	W2
004F12  BE9F84     MOV.D W4, [W15++]              80:    		PUSH.D	W4
004F14  BE9F86     MOV.D W6, [W15++]              81:    		PUSH.D	W6
004F16  BE9F88     MOV.D W8, [W15++]              82:    		PUSH.D 	W8
004F18  BE9F8A     MOV.D W10, [W15++]             83:    		PUSH.D 	W10
004F1A  BE9F8C     MOV.D W12, [W15++]             84:    		PUSH.D	W12
004F1C  781F8E     MOV W14, [W15++]               85:    		PUSH	W14
004F1E  F80036     PUSH RCOUNT                    86:    		PUSH	RCOUNT
004F20  F80054     PUSH TBLPAG                    87:    		PUSH	TBLPAG
                                                  88:    
004F22  F80044     PUSH CORCON                    89:    		PUSH	CORCON
                                                  90:    		#ifdef __HAS_EDS__
004F24  F80032     PUSH DSRPAG                    91:    			PUSH	DSRPAG
004F26  F80034     PUSH DSWPAG                    92:    			PUSH	DSWPAG
                                                  93:    		#else
                                                  94:    			PUSH	PSVPAG
                                                  95:    		#endif /* __HAS_EDS__ */
004F28  8302F0     MOV 0x605E, W0                 96:    		MOV		_uxCriticalNesting, W0		/* Save the critical nesting counter for the task. */
004F2A  781F80     MOV W0, [W15++]                97:    		PUSH	W0
004F2C  82FA10     MOV 0x5F42, W0                 98:    		MOV		_pxCurrentTCB, W0			/* Save the new top of stack into the TCB. */
004F2E  78080F     MOV W15, [W0]                  99:    		MOV		W15, [W0]
                                                  100:   
004F30  021BB8     CALL 0x1BB8                    101:   		call 	_vTaskSwitchContext
                                                  102:   
004F34  82FA10     MOV 0x5F42, W0                 103:   		MOV		_pxCurrentTCB, W0			/* Restore the stack pointer for the task. */
004F36  780790     MOV [W0], W15                  104:   		MOV		[W0], W15
004F38  78004F     MOV [--W15], W0                105:   		POP		W0							/* Restore the critical nesting counter for the task. */
004F3A  8B02F0     MOV W0, 0x605E                 106:   		MOV		W0, _uxCriticalNesting
                                                  107:   		#ifdef __HAS_EDS__
004F3C  F90034     POP DSWPAG                     108:   			POP		DSWPAG
004F3E  F90032     POP DSRPAG                     109:   			POP		DSRPAG
                                                  110:   		#else
                                                  111:   			POP		PSVPAG
                                                  112:   		#endif /* __HAS_EDS__ */
004F40  F90044     POP CORCON                     113:   		POP		CORCON
004F42  F90054     POP TBLPAG                     114:   		POP		TBLPAG
004F44  F90036     POP RCOUNT                     115:   		POP		RCOUNT						/* Restore the registers from the stack. */
004F46  78074F     MOV [--W15], W14               116:   		POP		W14
004F48  BE064F     MOV.D [--W15], W12             117:   		POP.D	W12
004F4A  BE054F     MOV.D [--W15], W10             118:   		POP.D	W10
004F4C  BE044F     MOV.D [--W15], W8              119:   		POP.D	W8
004F4E  BE034F     MOV.D [--W15], W6              120:   		POP.D	W6
004F50  BE024F     MOV.D [--W15], W4              121:   		POP.D	W4
004F52  BE014F     MOV.D [--W15], W2              122:   		POP.D	W2
004F54  BE004F     MOV.D [--W15], W0              123:   		POP.D	W0
004F56  F90042     POP SR                         124:   		POP		SR
                                                  125:   
004F58  060000     RETURN                         126:           return
                                                  127:   
                                                  128:           .end
                                                  129:   		
                                                  130:   #endif /* defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ ) */
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/FreeRTOS/portable/MPLAB/PIC24_dsPIC/port.c
1:                 /*
2:                     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     ***************************************************************************
8:                      *                                                                       *
9:                      *    FreeRTOS provides completely free yet professionally developed,    *
10:                     *    robust, strictly quality controlled, supported, and cross          *
11:                     *    platform software that has become a de facto standard.             *
12:                     *                                                                       *
13:                     *    Help yourself get started quickly and support the FreeRTOS         *
14:                     *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                     *                                                                       *
17:                     *    Thank you!                                                         *
18:                     *                                                                       *
19:                    ***************************************************************************
20:                
21:                    This file is part of the FreeRTOS distribution.
22:                
23:                    FreeRTOS is free software; you can redistribute it and/or modify it under
24:                    the terms of the GNU General Public License (version 2) as published by the
25:                    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                
27:                    >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                    >>! a combined work that includes FreeRTOS without being obliged to provide
29:                    >>! the source code for proprietary components outside of the FreeRTOS
30:                    >>! kernel.
31:                
32:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                    link: http://www.freertos.org/a00114.html
36:                
37:                    1 tab == 4 spaces!
38:                
39:                    ***************************************************************************
40:                     *                                                                       *
41:                     *    Having a problem?  Start by reading the FAQ "My application does   *
42:                     *    not run, what could be wrong?"                                     *
43:                     *                                                                       *
44:                     *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                     *                                                                       *
46:                    ***************************************************************************
47:                
48:                    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                    license and Real Time Engineers Ltd. contact details.
50:                
51:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                
55:                    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                    licenses offer ticketed support, indemnification and middleware.
58:                
59:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                    engineered and independently SIL3 certified version for use in safety and
61:                    mission critical applications that require provable dependability.
62:                
63:                    1 tab == 4 spaces!
64:                */
65:                
66:                /*
67:                	Changes from V4.2.1
68:                
69:                	+ Introduced the configKERNEL_INTERRUPT_PRIORITY definition.
70:                */
71:                
72:                /*-----------------------------------------------------------
73:                 * Implementation of functions defined in portable.h for the PIC24 port.
74:                 *----------------------------------------------------------*/
75:                
76:                /* Scheduler include files. */
77:                #include "FreeRTOS.h"
78:                #include "task.h"
79:                
80:                /* Hardware specifics. */
81:                #define portBIT_SET 1
82:                #define portTIMER_PRESCALE 8
83:                #define portINITIAL_SR	0
84:                
85:                /* Defined for backward compatability with project created prior to
86:                FreeRTOS.org V4.3.0. */
87:                #ifndef configKERNEL_INTERRUPT_PRIORITY
88:                	#define configKERNEL_INTERRUPT_PRIORITY 1
89:                #endif
90:                
91:                /* Use _T1Interrupt as the interrupt handler name if the application writer has
92:                not provided their own. */
93:                #ifndef configTICK_INTERRUPT_HANDLER
94:                	#define configTICK_INTERRUPT_HANDLER _T1Interrupt
95:                #endif /* configTICK_INTERRUPT_HANDLER */
96:                
97:                /* The program counter is only 23 bits. */
98:                #define portUNUSED_PR_BITS	0x7f
99:                
100:               /* Records the nesting depth of calls to portENTER_CRITICAL(). */
101:               UBaseType_t uxCriticalNesting = 0xef;
102:               
103:               #if configKERNEL_INTERRUPT_PRIORITY != 1
104:               	#error If configKERNEL_INTERRUPT_PRIORITY is not 1 then the #32 in the following macros needs changing to equal the portINTERRUPT_BITS value, which is ( configKERNEL_INTERRUPT_PRIORITY << 5 )
105:               #endif
106:               
107:               #if defined( __PIC24E__ ) || defined ( __PIC24F__ ) || defined( __PIC24FK__ ) || defined( __PIC24H__ )
108:               
109:                   #ifdef __HAS_EDS__
110:               		#define portRESTORE_CONTEXT()																						\
111:               					asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */		\
112:               							"MOV	[W0], W15				\n"																\
113:               							"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
114:               							"MOV	W0, _uxCriticalNesting	\n"																\
115:               							"POP	DSWPAG					\n"																\
116:               							"POP    DSRPAG					\n"																\
117:               							"POP	CORCON					\n"																\
118:               							"POP	TBLPAG					\n"																\
119:               							"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
120:               							"POP	W14						\n"																\
121:               							"POP.D	W12						\n"																\
122:               							"POP.D	W10						\n"																\
123:               							"POP.D	W8						\n"																\
124:               							"POP.D	W6						\n"																\
125:               							"POP.D	W4						\n"																\
126:               							"POP.D	W2						\n"																\
127:               							"POP.D	W0						\n"																\
128:               							"POP	SR						  " );
129:               	#else /* __HAS_EDS__ */
130:               		#define portRESTORE_CONTEXT()																						\
131:               			asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */				\
132:               							"MOV	[W0], W15				\n"																\
133:               							"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
134:               							"MOV	W0, _uxCriticalNesting	\n"																\
135:               							"POP	PSVPAG					\n"																\
136:               							"POP	CORCON					\n"																\
137:               							"POP	TBLPAG					\n"																\
138:               							"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
139:               							"POP	W14						\n"																\
140:               							"POP.D	W12						\n"																\
141:               							"POP.D	W10						\n"																\
142:               							"POP.D	W8						\n"																\
143:               							"POP.D	W6						\n"																\
144:               							"POP.D	W4						\n"																\
145:               							"POP.D	W2						\n"																\
146:               							"POP.D	W0						\n"																\
147:               							"POP	SR						  " );
148:               		#endif /* __HAS_EDS__ */
149:               #endif /* MPLAB_PIC24_PORT */
150:               
151:               #if defined( __dsPIC30F__ ) || defined( __dsPIC33F__ )
152:               
153:               	#define portRESTORE_CONTEXT()																						\
154:               		asm volatile(	"MOV	_pxCurrentTCB, W0		\n"	/* Restore the stack pointer for the task. */				\
155:               						"MOV	[W0], W15				\n"																\
156:               						"POP	W0						\n"	/* Restore the critical nesting counter for the task. */	\
157:               						"MOV	W0, _uxCriticalNesting	\n"																\
158:               						"POP	PSVPAG					\n"																\
159:               						"POP	CORCON					\n"																\
160:               						"POP	DOENDH					\n"																\
161:               						"POP	DOENDL					\n"																\
162:               						"POP	DOSTARTH				\n"																\
163:               						"POP	DOSTARTL				\n"																\
164:               						"POP	DCOUNT					\n"																\
165:               						"POP	ACCBU					\n"																\
166:               						"POP	ACCBH					\n"																\
167:               						"POP	ACCBL					\n"																\
168:               						"POP	ACCAU					\n"																\
169:               						"POP	ACCAH					\n"																\
170:               						"POP	ACCAL					\n"																\
171:               						"POP	TBLPAG					\n"																\
172:               						"POP	RCOUNT					\n"	/* Restore the registers from the stack. */					\
173:               						"POP	W14						\n"																\
174:               						"POP.D	W12						\n"																\
175:               						"POP.D	W10						\n"																\
176:               						"POP.D	W8						\n"																\
177:               						"POP.D	W6						\n"																\
178:               						"POP.D	W4						\n"																\
179:               						"POP.D	W2						\n"																\
180:               						"POP.D	W0						\n"																\
181:               						"POP	SR						  " );
182:               
183:               #endif /* MPLAB_DSPIC_PORT */
184:               
185:               #ifndef portRESTORE_CONTEXT
186:               	#error Unrecognised device selected
187:               #endif
188:               
189:               /*
190:                * Setup the timer used to generate the tick interrupt.
191:                */
192:               void vApplicationSetupTickTimerInterrupt( void );
193:               
194:               /*
195:                * See header file for description.
196:                */
197:               StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
198:               {
004878  FA002A     LNK #0x2A
00487A  981720     MOV W0, [W14+36]
00487C  981731     MOV W1, [W14+38]
00487E  981742     MOV W2, [W14+40]
199:               uint16_t usCode;
200:               UBaseType_t i;
201:               
202:               const StackType_t xInitialStack[] =
004880  470264     ADD W14, #0x4, W4
004882  293C25     MOV #0x93C2, W5
004884  09000F     REPEAT #0xF
004886  781A35     MOV [W5++], [W4++]
203:               {
204:               	0x1111,	/* W1 */
205:               	0x2222, /* W2 */
206:               	0x3333, /* W3 */
207:               	0x4444, /* W4 */
208:               	0x5555, /* W5 */
209:               	0x6666, /* W6 */
210:               	0x7777, /* W7 */
211:               	0x8888, /* W8 */
212:               	0x9999, /* W9 */
213:               	0xaaaa, /* W10 */
214:               	0xbbbb, /* W11 */
215:               	0xcccc, /* W12 */
216:               	0xdddd, /* W13 */
217:               	0xeeee, /* W14 */
218:               	0xcdce, /* RCOUNT */
219:               	0xabac, /* TBLPAG */
220:               
221:               	/* dsPIC specific registers. */
222:               	#ifdef MPLAB_DSPIC_PORT
223:               		0x0202, /* ACCAL */
224:               		0x0303, /* ACCAH */
225:               		0x0404, /* ACCAU */
226:               		0x0505, /* ACCBL */
227:               		0x0606, /* ACCBH */
228:               		0x0707, /* ACCBU */
229:               		0x0808, /* DCOUNT */
230:               		0x090a, /* DOSTARTL */
231:               		0x1010, /* DOSTARTH */
232:               		0x1110, /* DOENDL */
233:               		0x1212, /* DOENDH */
234:               	#endif
235:               };
236:               
237:               	/* Setup the stack as if a yield had occurred.
238:               
239:               	Save the low bytes of the program counter. */
240:               	usCode = ( uint16_t ) pxCode;
004888  90123E     MOV [W14+38], W4
00488A  980714     MOV W4, [W14+2]
241:               	*pxTopOfStack = ( StackType_t ) usCode;
00488C  90122E     MOV [W14+36], W4
00488E  90029E     MOV [W14+2], W5
004890  780A05     MOV W5, [W4]
242:               	pxTopOfStack++;
004892  90122E     MOV [W14+36], W4
004894  E88204     INC2 W4, W4
004896  981724     MOV W4, [W14+36]
243:               
244:               	/* Save the high byte of the program counter.  This will always be zero
245:               	here as it is passed in a 16bit pointer.  If the address is greater than
246:               	16 bits then the pointer will point to a jump table. */
247:               	*pxTopOfStack = ( StackType_t ) 0;
004898  90122E     MOV [W14+36], W4
00489A  EB0280     CLR W5
00489C  780A05     MOV W5, [W4]
248:               	pxTopOfStack++;
00489E  90122E     MOV [W14+36], W4
0048A0  E88204     INC2 W4, W4
0048A2  981724     MOV W4, [W14+36]
249:               
250:               	/* Status register with interrupts enabled. */
251:               	*pxTopOfStack = portINITIAL_SR;
0048A4  90122E     MOV [W14+36], W4
0048A6  EB0280     CLR W5
0048A8  780A05     MOV W5, [W4]
252:               	pxTopOfStack++;
0048AA  90122E     MOV [W14+36], W4
0048AC  E88204     INC2 W4, W4
0048AE  981724     MOV W4, [W14+36]
253:               
254:               	/* Parameters are passed in W0. */
255:               	*pxTopOfStack = ( StackType_t ) pvParameters;
0048B0  9012CE     MOV [W14+40], W5
0048B2  90122E     MOV [W14+36], W4
0048B4  780A05     MOV W5, [W4]
256:               	pxTopOfStack++;
0048B6  90122E     MOV [W14+36], W4
0048B8  E88204     INC2 W4, W4
0048BA  981724     MOV W4, [W14+36]
257:               
258:               	for( i = 0; i < ( sizeof( xInitialStack ) / sizeof( StackType_t ) ); i++ )
0048BC  EB0200     CLR W4
0048BE  780F04     MOV W4, [W14]
0048C0  37000A     BRA 0x48D6
0048D4  E80F1E     INC [W14], [W14]
0048D6  78021E     MOV [W14], W4
0048D8  520FEF     SUB W4, #0xF, [W15]
0048DA  36FFF3     BRA LEU, 0x48C2
259:               	{
260:               		*pxTopOfStack = xInitialStack[ i ];
0048C2  78021E     MOV [W14], W4
0048C4  420204     ADD W4, W4, W4
0048C6  420264     ADD W4, #0x4, W4
0048C8  7A02EE     MOV [W14+W4], W5
0048CA  90122E     MOV [W14+36], W4
0048CC  780A05     MOV W5, [W4]
261:               		pxTopOfStack++;
0048CE  90122E     MOV [W14+36], W4
0048D0  E88204     INC2 W4, W4
0048D2  981724     MOV W4, [W14+36]
262:               	}
263:               
264:               	*pxTopOfStack = CORCON;
0048DC  800225     MOV CORCON, W5
0048DE  90122E     MOV [W14+36], W4
0048E0  780A05     MOV W5, [W4]
265:               	pxTopOfStack++;
0048E2  90122E     MOV [W14+36], W4
0048E4  E88204     INC2 W4, W4
0048E6  981724     MOV W4, [W14+36]
266:               
267:               	#if defined(__HAS_EDS__)
268:               		*pxTopOfStack = DSRPAG;
0048E8  800195     MOV DSRPAG, W5
0048EA  90122E     MOV [W14+36], W4
0048EC  780A05     MOV W5, [W4]
269:               		pxTopOfStack++;
0048EE  90122E     MOV [W14+36], W4
0048F0  E88204     INC2 W4, W4
0048F2  981724     MOV W4, [W14+36]
270:               		*pxTopOfStack = DSWPAG;
0048F4  8001A5     MOV DSWPAG, W5
0048F6  90122E     MOV [W14+36], W4
0048F8  780A05     MOV W5, [W4]
271:               		pxTopOfStack++;
0048FA  90122E     MOV [W14+36], W4
0048FC  E88204     INC2 W4, W4
0048FE  981724     MOV W4, [W14+36]
272:               	#else /* __HAS_EDS__ */
273:               		*pxTopOfStack = PSVPAG;
274:               		pxTopOfStack++;
275:               	#endif /* __HAS_EDS__ */
276:               
277:               	/* Finally the critical nesting depth. */
278:               	*pxTopOfStack = 0x00;
004900  90122E     MOV [W14+36], W4
004902  EB0280     CLR W5
004904  780A05     MOV W5, [W4]
279:               	pxTopOfStack++;
004906  90122E     MOV [W14+36], W4
004908  E88204     INC2 W4, W4
00490A  981724     MOV W4, [W14+36]
280:               
281:               	return pxTopOfStack;
00490C  90122E     MOV [W14+36], W4
282:               }
00490E  780004     MOV W4, W0
004910  FA8000     ULNK
004912  060000     RETURN
283:               /*-----------------------------------------------------------*/
284:               
285:               BaseType_t xPortStartScheduler( void )
286:               {
004914  FA0000     LNK #0x0
287:               	/* Setup a timer for the tick ISR. */
288:               	vApplicationSetupTickTimerInterrupt();
004916  02494E     CALL vApplicationSetupTickTimerInterrupt
004918  000000     NOP
289:               
290:               	/* Restore the context of the first task to run. */
291:               	portRESTORE_CONTEXT();
00491A  82FA10     MOV pxCurrentTCB, W0
00491C  780790     MOV [W0], W15
00491E  78004F     MOV [--W15], W0
004920  8B02F0     MOV W0, uxCriticalNesting
004922  F90034     POP DSWPAG
004924  F90032     POP DSRPAG
004926  F90044     POP CORCON
004928  F90054     POP TBLPAG
00492A  F90036     POP RCOUNT
00492C  78074F     MOV [--W15], W14
00492E  BE064F     MOV.D [--W15], W12
004930  BE054F     MOV.D [--W15], W10
004932  BE044F     MOV.D [--W15], W8
004934  BE034F     MOV.D [--W15], W6
004936  BE024F     MOV.D [--W15], W4
004938  BE014F     MOV.D [--W15], W2
00493A  BE004F     MOV.D [--W15], W0
00493C  F90042     POP SR
292:               
293:               	/* Simulate the end of the yield function. */
294:               	asm volatile ( "return" );
00493E  060000     RETURN
295:               
296:               	/* Should not reach here. */
297:               	return pdTRUE;
004940  200014     MOV #0x1, W4
298:               }
004942  780004     MOV W4, W0
004944  FA8000     ULNK
004946  060000     RETURN
299:               /*-----------------------------------------------------------*/
300:               
301:               void vPortEndScheduler( void )
302:               {
004948  FA0000     LNK #0x0
303:               	/* Not implemented in ports where there is nothing to return to.
304:               	Artificially force an assert. */
305:               	configASSERT( uxCriticalNesting == 1000UL );
306:               }
00494A  FA8000     ULNK
00494C  060000     RETURN
307:               /*-----------------------------------------------------------*/
308:               
309:               /*
310:                * Setup a timer for a regular tick.
311:                */
312:               __attribute__(( weak )) void vApplicationSetupTickTimerInterrupt( void )
313:               {
00494E  FA0004     LNK #0x4
314:               const uint32_t ulCompareMatch = ( ( configCPU_CLOCK_HZ / portTIMER_PRESCALE ) / configTICK_RATE_HZ ) - 1;
004950  21D4B4     MOV #0x1D4B, W4
004952  200005     MOV #0x0, W5
004954  BE8F04     MOV.D W4, [W14]
315:               
316:               	/* Prescale of 8. */
317:               	T1CON = 0;
004956  EB0200     CLR W4
004958  880824     MOV W4, T1CON
318:               	TMR1 = 0;
00495A  EB0200     CLR W4
00495C  880804     MOV W4, TMR1
319:               
320:               	PR1 = ( uint16_t ) ulCompareMatch;
00495E  78021E     MOV [W14], W4
004960  880814     MOV W4, PR1
321:               
322:               	/* Setup timer 1 interrupt priority. */
323:               	IPC0bits.T1IP = configKERNEL_INTERRUPT_PRIORITY;
004962  804204     MOV IPC0, W4
004964  A0C004     BSET W4, #12
004966  A1D004     BCLR W4, #13
004968  A1E004     BCLR W4, #14
00496A  884204     MOV W4, IPC0
324:               
325:               	/* Clear the interrupt as a starting condition. */
326:               	IFS0bits.T1IF = 0;
00496C  A96800     BCLR IFS0, #3
327:               
328:               	/* Enable the interrupt. */
329:               	IEC0bits.T1IE = 1;
00496E  A86820     BSET IEC0, #3
330:               
331:               	/* Setup the prescale value. */
332:               	T1CONbits.TCKPS0 = 1;
004970  A88104     BSET T1CON, #4
333:               	T1CONbits.TCKPS1 = 0;
004972  A9A104     BCLR T1CON, #5
334:               
335:               	/* Start the timer. */
336:               	T1CONbits.TON = 1;
004974  A8E105     BSET 0x105, #7
337:               }
004976  FA8000     ULNK
004978  060000     RETURN
338:               /*-----------------------------------------------------------*/
339:               
340:               void vPortEnterCritical( void )
341:               {
00497A  FA0000     LNK #0x0
342:               	portDISABLE_INTERRUPTS();
00497C  800215     MOV SR, W5
00497E  200204     MOV #0x20, W4
004980  720205     IOR W4, W5, W4
004982  880214     MOV W4, SR
343:               	uxCriticalNesting++;
004984  8302F4     MOV uxCriticalNesting, W4
004986  E80204     INC W4, W4
004988  8B02F4     MOV W4, uxCriticalNesting
344:               }
00498A  FA8000     ULNK
00498C  060000     RETURN
345:               /*-----------------------------------------------------------*/
346:               
347:               void vPortExitCritical( void )
348:               {
00498E  FA0000     LNK #0x0
349:               	configASSERT( uxCriticalNesting );
350:               	uxCriticalNesting--;
004990  8302F4     MOV uxCriticalNesting, W4
004992  E90204     DEC W4, W4
004994  8B02F4     MOV W4, uxCriticalNesting
351:               	if( uxCriticalNesting == 0 )
004996  8302F4     MOV uxCriticalNesting, W4
004998  520FE0     SUB W4, #0x0, [W15]
00499A  3A0004     BRA NZ, 0x49A4
352:               	{
353:               		portENABLE_INTERRUPTS();
00499C  800215     MOV SR, W5
00499E  2FFDF4     MOV #0xFFDF, W4
0049A0  628204     AND W5, W4, W4
0049A2  880214     MOV W4, SR
354:               	}
355:               }
0049A4  FA8000     ULNK
0049A6  060000     RETURN
356:               /*-----------------------------------------------------------*/
357:               
358:               void __attribute__((__interrupt__, auto_psv)) configTICK_INTERRUPT_HANDLER( void )
359:               {
0049A8  F80036     PUSH RCOUNT
0049AA  BE9F80     MOV.D W0, [W15++]
0049AC  BE9F82     MOV.D W2, [W15++]
0049AE  BE9F84     MOV.D W4, [W15++]
0049B0  BE9F86     MOV.D W6, [W15++]
0049B2  F80032     PUSH DSRPAG
0049B4  202000     MOV #0x200, W0
0049B6  880190     MOV W0, DSRPAG
0049B8  000000     NOP
0049BA  FA0000     LNK #0x0
360:               	/* Clear the timer interrupt. */
361:               	IFS0bits.T1IF = 0;
0049BC  A96800     BCLR IFS0, #3
362:               
363:               	if( xTaskIncrementTick() != pdFALSE )
0049BE  021AE0     CALL xTaskIncrementTick
0049C0  000000     NOP
0049C2  780200     MOV W0, W4
0049C4  520FE0     SUB W4, #0x0, [W15]
0049C6  320003     BRA Z, 0x49CE
364:               	{
365:               		portYIELD();
0049C8  024F06     CALL _vPortYield
0049CA  000000     NOP
0049CC  000000     NOP
366:               	}
367:               }
0049CE  FA8000     ULNK
0049D0  F90032     POP DSRPAG
0049D2  BE034F     MOV.D [--W15], W6
0049D4  BE024F     MOV.D [--W15], W4
0049D6  BE014F     MOV.D [--W15], W2
0049D8  BE004F     MOV.D [--W15], W0
0049DA  F90036     POP RCOUNT
0049DC  064000     RETFIE
368:               
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/FreeRTOS/list.c  --
1:                 /*
2:                     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     ***************************************************************************
8:                      *                                                                       *
9:                      *    FreeRTOS provides completely free yet professionally developed,    *
10:                     *    robust, strictly quality controlled, supported, and cross          *
11:                     *    platform software that has become a de facto standard.             *
12:                     *                                                                       *
13:                     *    Help yourself get started quickly and support the FreeRTOS         *
14:                     *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                     *                                                                       *
17:                     *    Thank you!                                                         *
18:                     *                                                                       *
19:                    ***************************************************************************
20:                
21:                    This file is part of the FreeRTOS distribution.
22:                
23:                    FreeRTOS is free software; you can redistribute it and/or modify it under
24:                    the terms of the GNU General Public License (version 2) as published by the
25:                    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                
27:                    >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                    >>! a combined work that includes FreeRTOS without being obliged to provide
29:                    >>! the source code for proprietary components outside of the FreeRTOS
30:                    >>! kernel.
31:                
32:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                    link: http://www.freertos.org/a00114.html
36:                
37:                    1 tab == 4 spaces!
38:                
39:                    ***************************************************************************
40:                     *                                                                       *
41:                     *    Having a problem?  Start by reading the FAQ "My application does   *
42:                     *    not run, what could be wrong?"                                     *
43:                     *                                                                       *
44:                     *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                     *                                                                       *
46:                    ***************************************************************************
47:                
48:                    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                    license and Real Time Engineers Ltd. contact details.
50:                
51:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                
55:                    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                    licenses offer ticketed support, indemnification and middleware.
58:                
59:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                    engineered and independently SIL3 certified version for use in safety and
61:                    mission critical applications that require provable dependability.
62:                
63:                    1 tab == 4 spaces!
64:                */
65:                
66:                
67:                #include <stdlib.h>
68:                #include "FreeRTOS.h"
69:                #include "list.h"
70:                
71:                /*-----------------------------------------------------------
72:                 * PUBLIC LIST API documented in list.h
73:                 *----------------------------------------------------------*/
74:                
75:                void vListInitialise( List_t * const pxList )
76:                {
004B2E  FA0002     LNK #0x2
004B30  780F00     MOV W0, [W14]
77:                	/* The list structure contains a list item which is used to mark the
78:                	end of the list.  To initialise the list the list end is inserted
79:                	as the only list entry. */
80:                	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
004B32  78029E     MOV [W14], W5
004B34  428264     ADD W5, #0x4, W4
004B36  780284     MOV W4, W5
004B38  78021E     MOV [W14], W4
004B3A  980215     MOV W5, [W4+2]
81:                
82:                	/* The list end value is the highest possible value in the list to
83:                	ensure it remains at the end of the list. */
84:                	pxList->xListEnd.xItemValue = portMAX_DELAY;
004B3C  78021E     MOV [W14], W4
004B3E  EB8280     SETM W5
004B40  980225     MOV W5, [W4+4]
85:                
86:                	/* The list end next and previous pointers point to itself so we know
87:                	when the list is empty. */
88:                	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
004B42  78029E     MOV [W14], W5
004B44  428264     ADD W5, #0x4, W4
004B46  780284     MOV W4, W5
004B48  78021E     MOV [W14], W4
004B4A  980235     MOV W5, [W4+6]
89:                	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
004B4C  78029E     MOV [W14], W5
004B4E  428264     ADD W5, #0x4, W4
004B50  780284     MOV W4, W5
004B52  78021E     MOV [W14], W4
004B54  980245     MOV W5, [W4+8]
90:                
91:                	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
004B56  78021E     MOV [W14], W4
004B58  EB0280     CLR W5
004B5A  780A05     MOV W5, [W4]
92:                }
004B5C  FA8000     ULNK
004B5E  060000     RETURN
93:                /*-----------------------------------------------------------*/
94:                
95:                void vListInitialiseItem( ListItem_t * const pxItem )
96:                {
004B60  FA0002     LNK #0x2
004B62  780F00     MOV W0, [W14]
97:                	/* Make sure the list item is not recorded as being on a list. */
98:                	pxItem->pvContainer = NULL;
004B64  78021E     MOV [W14], W4
004B66  EB0280     CLR W5
004B68  980245     MOV W5, [W4+8]
99:                }
004B6A  FA8000     ULNK
004B6C  060000     RETURN
100:               /*-----------------------------------------------------------*/
101:               
102:               void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
103:               {
004B6E  FA0006     LNK #0x6
004B70  980710     MOV W0, [W14+2]
004B72  980721     MOV W1, [W14+4]
104:               ListItem_t * const pxIndex = pxList->pxIndex;
004B74  90021E     MOV [W14+2], W4
004B76  900294     MOV [W4+2], W5
004B78  780F05     MOV W5, [W14]
105:               
106:               	/* Insert a new list item into pxList, but rather than sort the list,
107:               	makes the new list item the last item to be removed by a call to
108:               	listGET_OWNER_OF_NEXT_ENTRY(). */
109:               	pxNewListItem->pxNext = pxIndex;
004B7A  90022E     MOV [W14+4], W4
004B7C  78029E     MOV [W14], W5
004B7E  980215     MOV W5, [W4+2]
110:               	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
004B80  78021E     MOV [W14], W4
004B82  9002A4     MOV [W4+4], W5
004B84  90022E     MOV [W14+4], W4
004B86  980225     MOV W5, [W4+4]
111:               	pxIndex->pxPrevious->pxNext = pxNewListItem;
004B88  78021E     MOV [W14], W4
004B8A  900224     MOV [W4+4], W4
004B8C  9002AE     MOV [W14+4], W5
004B8E  980215     MOV W5, [W4+2]
112:               	pxIndex->pxPrevious = pxNewListItem;
004B90  78021E     MOV [W14], W4
004B92  9002AE     MOV [W14+4], W5
004B94  980225     MOV W5, [W4+4]
113:               
114:               	/* Remember which list the item is in. */
115:               	pxNewListItem->pvContainer = ( void * ) pxList;
004B96  90022E     MOV [W14+4], W4
004B98  90029E     MOV [W14+2], W5
004B9A  980245     MOV W5, [W4+8]
116:               
117:               	( pxList->uxNumberOfItems )++;
004B9C  90021E     MOV [W14+2], W4
004B9E  780214     MOV [W4], W4
004BA0  E80284     INC W4, W5
004BA2  90021E     MOV [W14+2], W4
004BA4  780A05     MOV W5, [W4]
118:               }
004BA6  FA8000     ULNK
004BA8  060000     RETURN
119:               /*-----------------------------------------------------------*/
120:               
121:               void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
122:               {
004BAA  FA0008     LNK #0x8
004BAC  980720     MOV W0, [W14+4]
004BAE  980731     MOV W1, [W14+6]
123:               ListItem_t *pxIterator;
124:               const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
004BB0  90023E     MOV [W14+6], W4
004BB2  780294     MOV [W4], W5
004BB4  980715     MOV W5, [W14+2]
125:               
126:               	/* Insert the new list item into the list, sorted in xItemValue order.
127:               
128:               	If the list already contains a list item with the same item value then
129:               	the new list item should be placed after it.  This ensures that TCB's which
130:               	are stored in ready lists (all of which have the same xItemValue value)
131:               	get an equal share of the CPU.  However, if the xItemValue is the same as
132:               	the back marker the iteration loop below will not end.  This means we need
133:               	to guard against this by checking the value first and modifying the
134:               	algorithm slightly if necessary. */
135:               	if( xValueOfInsertion == portMAX_DELAY )
004BB6  90021E     MOV [W14+2], W4
004BB8  420FE1     ADD W4, #0x1, [W15]
004BBA  3A0004     BRA NZ, 0x4BC4
136:               	{
137:               		pxIterator = pxList->xListEnd.pxPrevious;
004BBC  90022E     MOV [W14+4], W4
004BBE  9002C4     MOV [W4+8], W5
004BC0  780F05     MOV W5, [W14]
004BC2  37000D     BRA 0x4BDE
138:               	}
139:               	else
140:               	{
141:               		/* *** NOTE ***********************************************************
142:               		If you find your application is crashing here then likely causes are:
143:               			1) Stack overflow -
144:               			   see http://www.freertos.org/Stacks-and-stack-overflow-checking.html
145:               			2) Incorrect interrupt priority assignment, especially on Cortex-M3
146:               			   parts where numerically high priority values denote low actual
147:               			   interrupt priories, which can seem counter intuitive.  See
148:               			   configMAX_SYSCALL_INTERRUPT_PRIORITY on http://www.freertos.org/a00110.html
149:               			3) Calling an API function from within a critical section or when
150:               			   the scheduler is suspended, or calling an API function that does
151:               			   not end in "FromISR" from an interrupt.
152:               			4) Using a queue or semaphore before it has been initialised or
153:               			   before the scheduler has been started (are interrupts firing
154:               			   before vTaskStartScheduler() has been called?).
155:               		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
156:               		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
157:               		**********************************************************************/
158:               
159:               		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
004BC4  90022E     MOV [W14+4], W4
004BC6  420264     ADD W4, #0x4, W4
004BC8  780F04     MOV W4, [W14]
004BCA  370003     BRA 0x4BD2
004BCC  78021E     MOV [W14], W4
004BCE  900294     MOV [W4+2], W5
004BD0  780F05     MOV W5, [W14]
004BD2  78021E     MOV [W14], W4
004BD4  900214     MOV [W4+2], W4
004BD6  780294     MOV [W4], W5
004BD8  90021E     MOV [W14+2], W4
004BDA  528F84     SUB W5, W4, [W15]
004BDC  36FFF7     BRA LEU, 0x4BCC
160:               		{
161:               			/* There is nothing to do here, we are just iterating to the
162:               			wanted insertion position. */
163:               		}
164:               	}
165:               
166:               	pxNewListItem->pxNext = pxIterator->pxNext;
004BDE  78021E     MOV [W14], W4
004BE0  900294     MOV [W4+2], W5
004BE2  90023E     MOV [W14+6], W4
004BE4  980215     MOV W5, [W4+2]
167:               	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
004BE6  90023E     MOV [W14+6], W4
004BE8  900214     MOV [W4+2], W4
004BEA  9002BE     MOV [W14+6], W5
004BEC  980225     MOV W5, [W4+4]
168:               	pxNewListItem->pxPrevious = pxIterator;
004BEE  90023E     MOV [W14+6], W4
004BF0  78029E     MOV [W14], W5
004BF2  980225     MOV W5, [W4+4]
169:               	pxIterator->pxNext = pxNewListItem;
004BF4  78021E     MOV [W14], W4
004BF6  9002BE     MOV [W14+6], W5
004BF8  980215     MOV W5, [W4+2]
170:               
171:               	/* Remember which list the item is in.  This allows fast removal of the
172:               	item later. */
173:               	pxNewListItem->pvContainer = ( void * ) pxList;
004BFA  90023E     MOV [W14+6], W4
004BFC  9002AE     MOV [W14+4], W5
004BFE  980245     MOV W5, [W4+8]
174:               
175:               	( pxList->uxNumberOfItems )++;
004C00  90022E     MOV [W14+4], W4
004C02  780214     MOV [W4], W4
004C04  E80284     INC W4, W5
004C06  90022E     MOV [W14+4], W4
004C08  780A05     MOV W5, [W4]
176:               }
004C0A  FA8000     ULNK
004C0C  060000     RETURN
177:               /*-----------------------------------------------------------*/
178:               
179:               UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
180:               {
004C0E  FA0004     LNK #0x4
004C10  980710     MOV W0, [W14+2]
181:               /* The list item knows which list it is in.  Obtain the list from the list
182:               item. */
183:               List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
004C12  90021E     MOV [W14+2], W4
004C14  900244     MOV [W4+8], W4
004C16  780F04     MOV W4, [W14]
184:               
185:               	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
004C18  90021E     MOV [W14+2], W4
004C1A  900214     MOV [W4+2], W4
004C1C  90029E     MOV [W14+2], W5
004C1E  9002A5     MOV [W5+4], W5
004C20  980225     MOV W5, [W4+4]
186:               	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
004C22  90021E     MOV [W14+2], W4
004C24  900224     MOV [W4+4], W4
004C26  90029E     MOV [W14+2], W5
004C28  900295     MOV [W5+2], W5
004C2A  980215     MOV W5, [W4+2]
187:               
188:               	/* Make sure the index is left pointing to a valid item. */
189:               	if( pxList->pxIndex == pxItemToRemove )
004C2C  78021E     MOV [W14], W4
004C2E  900294     MOV [W4+2], W5
004C30  90021E     MOV [W14+2], W4
004C32  528F84     SUB W5, W4, [W15]
004C34  3A0004     BRA NZ, 0x4C3E
190:               	{
191:               		pxList->pxIndex = pxItemToRemove->pxPrevious;
004C36  90021E     MOV [W14+2], W4
004C38  9002A4     MOV [W4+4], W5
004C3A  78021E     MOV [W14], W4
004C3C  980215     MOV W5, [W4+2]
192:               	}
193:               	else
194:               	{
195:               		mtCOVERAGE_TEST_MARKER();
196:               	}
197:               
198:               	pxItemToRemove->pvContainer = NULL;
004C3E  90021E     MOV [W14+2], W4
004C40  EB0280     CLR W5
004C42  980245     MOV W5, [W4+8]
199:               	( pxList->uxNumberOfItems )--;
004C44  78021E     MOV [W14], W4
004C46  780214     MOV [W4], W4
004C48  E90284     DEC W4, W5
004C4A  78021E     MOV [W14], W4
004C4C  780A05     MOV W5, [W4]
200:               
201:               	return pxList->uxNumberOfItems;
004C4E  78021E     MOV [W14], W4
004C50  780214     MOV [W4], W4
202:               }
004C52  780004     MOV W4, W0
004C54  FA8000     ULNK
004C56  060000     RETURN
203:               /*-----------------------------------------------------------*/
204:               
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/FreeRTOS/event_groups.c
1:                 /*
2:                     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     ***************************************************************************
8:                      *                                                                       *
9:                      *    FreeRTOS provides completely free yet professionally developed,    *
10:                     *    robust, strictly quality controlled, supported, and cross          *
11:                     *    platform software that has become a de facto standard.             *
12:                     *                                                                       *
13:                     *    Help yourself get started quickly and support the FreeRTOS         *
14:                     *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                     *                                                                       *
17:                     *    Thank you!                                                         *
18:                     *                                                                       *
19:                    ***************************************************************************
20:                
21:                    This file is part of the FreeRTOS distribution.
22:                
23:                    FreeRTOS is free software; you can redistribute it and/or modify it under
24:                    the terms of the GNU General Public License (version 2) as published by the
25:                    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                
27:                    >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                    >>! a combined work that includes FreeRTOS without being obliged to provide
29:                    >>! the source code for proprietary components outside of the FreeRTOS
30:                    >>! kernel.
31:                
32:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                    link: http://www.freertos.org/a00114.html
36:                
37:                    1 tab == 4 spaces!
38:                
39:                    ***************************************************************************
40:                     *                                                                       *
41:                     *    Having a problem?  Start by reading the FAQ "My application does   *
42:                     *    not run, what could be wrong?"                                     *
43:                     *                                                                       *
44:                     *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                     *                                                                       *
46:                    ***************************************************************************
47:                
48:                    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                    license and Real Time Engineers Ltd. contact details.
50:                
51:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                
55:                    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                    licenses offer ticketed support, indemnification and middleware.
58:                
59:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                    engineered and independently SIL3 certified version for use in safety and
61:                    mission critical applications that require provable dependability.
62:                
63:                    1 tab == 4 spaces!
64:                */
65:                
66:                /* Standard includes. */
67:                #include <stdlib.h>
68:                
69:                /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
70:                all the API functions to use the MPU wrappers.  That should only be done when
71:                task.h is included from an application file. */
72:                #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
73:                
74:                /* FreeRTOS includes. */
75:                #include "FreeRTOS.h"
76:                #include "task.h"
77:                #include "timers.h"
78:                #include "event_groups.h"
79:                
80:                /* Lint e961 and e750 are suppressed as a MISRA exception justified because the
81:                MPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
82:                header files above, but not in this file, in order to generate the correct
83:                privileged Vs unprivileged linkage and placement. */
84:                #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
85:                
86:                #if ( INCLUDE_xEventGroupSetBitFromISR == 1 ) && ( configUSE_TIMERS == 0 )
87:                	#error configUSE_TIMERS must be set to 1 to make the xEventGroupSetBitFromISR() function available.
88:                #endif
89:                
90:                #if ( INCLUDE_xEventGroupSetBitFromISR == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 0 )
91:                	#error INCLUDE_xTimerPendFunctionCall must also be set to one to make the xEventGroupSetBitFromISR() function available.
92:                #endif
93:                
94:                /* The following bit fields convey control information in a task's event list
95:                item value.  It is important they don't clash with the
96:                taskEVENT_LIST_ITEM_VALUE_IN_USE definition. */
97:                #if configUSE_16_BIT_TICKS == 1
98:                	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x0100U
99:                	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x0200U
100:               	#define eventWAIT_FOR_ALL_BITS			0x0400U
101:               	#define eventEVENT_BITS_CONTROL_BYTES	0xff00U
102:               #else
103:               	#define eventCLEAR_EVENTS_ON_EXIT_BIT	0x01000000UL
104:               	#define eventUNBLOCKED_DUE_TO_BIT_SET	0x02000000UL
105:               	#define eventWAIT_FOR_ALL_BITS			0x04000000UL
106:               	#define eventEVENT_BITS_CONTROL_BYTES	0xff000000UL
107:               #endif
108:               
109:               typedef struct xEventGroupDefinition
110:               {
111:               	EventBits_t uxEventBits;
112:               	List_t xTasksWaitingForBits;		/*< List of tasks waiting for a bit to be set. */
113:               
114:               	#if( configUSE_TRACE_FACILITY == 1 )
115:               		UBaseType_t uxEventGroupNumber;
116:               	#endif
117:               
118:               } EventGroup_t;
119:               
120:               /*-----------------------------------------------------------*/
121:               
122:               /*
123:                * Test the bits set in uxCurrentEventBits to see if the wait condition is met.
124:                * The wait condition is defined by xWaitForAllBits.  If xWaitForAllBits is
125:                * pdTRUE then the wait condition is met if all the bits set in uxBitsToWaitFor
126:                * are also set in uxCurrentEventBits.  If xWaitForAllBits is pdFALSE then the
127:                * wait condition is met if any of the bits set in uxBitsToWait for are also set
128:                * in uxCurrentEventBits.
129:                */
130:               static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits );
131:               
132:               /*-----------------------------------------------------------*/
133:               
134:               EventGroupHandle_t xEventGroupCreate( void )
135:               {
003634  FA0002     LNK #0x2
136:               EventGroup_t *pxEventBits;
137:               
138:               	pxEventBits = pvPortMalloc( sizeof( EventGroup_t ) );
003636  2000E0     MOV #0xE, W0
003638  024240     CALL pvPortMalloc
00363A  000000     NOP
00363C  780200     MOV W0, W4
00363E  780F04     MOV W4, [W14]
139:               	if( pxEventBits != NULL )
003640  78021E     MOV [W14], W4
003642  520FE0     SUB W4, #0x0, [W15]
003644  320007     BRA Z, 0x3654
140:               	{
141:               		pxEventBits->uxEventBits = 0;
003646  78021E     MOV [W14], W4
003648  EB0280     CLR W5
00364A  780A05     MOV W5, [W4]
142:               		vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
00364C  E8821E     INC2 [W14], W4
00364E  780004     MOV W4, W0
003650  024B2E     CALL vListInitialise
003652  000000     NOP
143:               		traceEVENT_GROUP_CREATE( pxEventBits );
144:               	}
145:               	else
146:               	{
147:               		traceEVENT_GROUP_CREATE_FAILED();
148:               	}
149:               
150:               	return ( EventGroupHandle_t ) pxEventBits;
003654  78021E     MOV [W14], W4
151:               }
003656  780004     MOV W4, W0
003658  FA8000     ULNK
00365A  060000     RETURN
152:               /*-----------------------------------------------------------*/
153:               
154:               EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
155:               {
00365C  FA0012     LNK #0x12
00365E  980750     MOV W0, [W14+10]
003660  980761     MOV W1, [W14+12]
003662  980772     MOV W2, [W14+14]
003664  980F03     MOV W3, [W14+16]
156:               EventBits_t uxOriginalBitValue, uxReturn;
157:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
003666  90025E     MOV [W14+10], W4
003668  980714     MOV W4, [W14+2]
158:               BaseType_t xAlreadyYielded;
159:               BaseType_t xTimeoutOccurred = pdFALSE;
00366A  EB0200     CLR W4
00366C  980724     MOV W4, [W14+4]
160:               
161:               	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
162:               	configASSERT( uxBitsToWaitFor != 0 );
163:               	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
164:               	{
165:               		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
166:               	}
167:               	#endif
168:               
169:               	vTaskSuspendAll();
00366E  021928     CALL vTaskSuspendAll
003670  000000     NOP
170:               	{
171:               		uxOriginalBitValue = pxEventBits->uxEventBits;
003672  90021E     MOV [W14+2], W4
003674  780294     MOV [W4], W5
003676  980735     MOV W5, [W14+6]
172:               
173:               		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
003678  9000EE     MOV [W14+12], W1
00367A  90005E     MOV [W14+10], W0
00367C  070106     RCALL xEventGroupSetBits
174:               
175:               		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
00367E  9002BE     MOV [W14+6], W5
003680  90026E     MOV [W14+12], W4
003682  780304     MOV W4, W6
003684  730305     IOR W6, W5, W6
003686  780286     MOV W6, W5
003688  90027E     MOV [W14+14], W4
00368A  628284     AND W5, W4, W5
00368C  90027E     MOV [W14+14], W4
00368E  528F84     SUB W5, W4, [W15]
003690  3A000C     BRA NZ, 0x36AA
176:               		{
177:               			/* All the rendezvous bits are now set - no need to block. */
178:               			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
003692  9002BE     MOV [W14+6], W5
003694  90026E     MOV [W14+12], W4
003696  728F04     IOR W5, W4, [W14]
179:               
180:               			/* Rendezvous always clear the bits.  They will have been cleared
181:               			already unless this is the only task in the rendezvous. */
182:               			pxEventBits->uxEventBits &= uxBitsToWaitFor;
003698  90021E     MOV [W14+2], W4
00369A  780294     MOV [W4], W5
00369C  90027E     MOV [W14+14], W4
00369E  628284     AND W5, W4, W5
0036A0  90021E     MOV [W14+2], W4
0036A2  780A05     MOV W5, [W4]
183:               
184:               			xTicksToWait = 0;
0036A4  EB0200     CLR W4
0036A6  980F04     MOV W4, [W14+16]
0036A8  370014     BRA 0x36D2
185:               		}
186:               		else
187:               		{
188:               			if( xTicksToWait != ( TickType_t ) 0 )
0036AA  900A0E     MOV [W14+16], W4
0036AC  520FE0     SUB W4, #0x0, [W15]
0036AE  32000F     BRA Z, 0x36CE
189:               			{
190:               				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
191:               
192:               				/* Store the bits that the calling task is waiting for in the
193:               				task's event list item so the kernel knows when a match is
194:               				found.  Then enter the blocked state. */
195:               				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
0036B0  9002FE     MOV [W14+14], W5
0036B2  205004     MOV #0x500, W4
0036B4  780304     MOV W4, W6
0036B6  730305     IOR W6, W5, W6
0036B8  780286     MOV W6, W5
0036BA  90021E     MOV [W14+2], W4
0036BC  E88204     INC2 W4, W4
0036BE  90090E     MOV [W14+16], W2
0036C0  780085     MOV W5, W1
0036C2  780004     MOV W4, W0
0036C4  021C56     CALL vTaskPlaceOnUnorderedEventList
0036C6  000000     NOP
196:               
197:               				/* This assignment is obsolete as uxReturn will get set after
198:               				the task unblocks, but some compilers mistakenly generate a
199:               				warning about uxReturn being returned without being set if the
200:               				assignment is omitted. */
201:               				uxReturn = 0;
0036C8  EB0200     CLR W4
0036CA  780F04     MOV W4, [W14]
0036CC  370002     BRA 0x36D2
202:               			}
203:               			else
204:               			{
205:               				/* The rendezvous bits were not set, but no block time was
206:               				specified - just return the current event bit value. */
207:               				uxReturn = pxEventBits->uxEventBits;
0036CE  90021E     MOV [W14+2], W4
0036D0  780F14     MOV [W4], [W14]
208:               			}
209:               		}
210:               	}
211:               	xAlreadyYielded = xTaskResumeAll();
0036D2  021934     CALL xTaskResumeAll
0036D4  000000     NOP
0036D6  780200     MOV W0, W4
0036D8  980744     MOV W4, [W14+8]
212:               
213:               	if( xTicksToWait != ( TickType_t ) 0 )
0036DA  900A0E     MOV [W14+16], W4
0036DC  520FE0     SUB W4, #0x0, [W15]
0036DE  320025     BRA Z, 0x372A
214:               	{
215:               		if( xAlreadyYielded == pdFALSE )
0036E0  90024E     MOV [W14+8], W4
0036E2  520FE0     SUB W4, #0x0, [W15]
0036E4  3A0003     BRA NZ, 0x36EC
216:               		{
217:               			portYIELD_WITHIN_API();
0036E6  024F06     CALL _vPortYield
0036E8  000000     NOP
0036EA  000000     NOP
218:               		}
219:               		else
220:               		{
221:               			mtCOVERAGE_TEST_MARKER();
222:               		}
223:               
224:               		/* The task blocked to wait for its required bits to be set - at this
225:               		point either the required bits were set or the block time expired.  If
226:               		the required bits were set they will have been stored in the task's
227:               		event list item, and they should now be retrieved then cleared. */
228:               		uxReturn = uxTaskResetEventItemValue();
0036EC  0223EE     CALL uxTaskResetEventItemValue
0036EE  000000     NOP
0036F0  780200     MOV W0, W4
0036F2  780F04     MOV W4, [W14]
229:               
230:               		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
0036F4  202004     MOV #0x200, W4
0036F6  62021E     AND W4, [W14], W4
0036F8  520FE0     SUB W4, #0x0, [W15]
0036FA  3A0015     BRA NZ, 0x3726
231:               		{
232:               			/* The task timed out, just return the current event bit value. */
233:               			taskENTER_CRITICAL();
0036FC  02497A     CALL vPortEnterCritical
0036FE  000000     NOP
234:               			{
235:               				uxReturn = pxEventBits->uxEventBits;
003700  90021E     MOV [W14+2], W4
003702  780F14     MOV [W4], [W14]
236:               
237:               				/* Although the task got here because it timed out before the
238:               				bits it was waiting for were set, it is possible that since it
239:               				unblocked another task has set the bits.  If this is the case
240:               				then it may be required to clear the bits before exiting. */
241:               				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
003704  90027E     MOV [W14+14], W4
003706  62029E     AND W4, [W14], W5
003708  90027E     MOV [W14+14], W4
00370A  528F84     SUB W5, W4, [W15]
00370C  3A0007     BRA NZ, 0x371C
242:               				{
243:               					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00370E  90021E     MOV [W14+2], W4
003710  780294     MOV [W4], W5
003712  90027E     MOV [W14+14], W4
003714  EA8204     COM W4, W4
003716  628284     AND W5, W4, W5
003718  90021E     MOV [W14+2], W4
00371A  780A05     MOV W5, [W4]
244:               				}
245:               				else
246:               				{
247:               					mtCOVERAGE_TEST_MARKER();
248:               				}
249:               			}
250:               			taskEXIT_CRITICAL();
00371C  02498E     CALL vPortExitCritical
00371E  000000     NOP
251:               
252:               			xTimeoutOccurred = pdTRUE;
003720  200014     MOV #0x1, W4
003722  980724     MOV W4, [W14+4]
003724  370002     BRA 0x372A
253:               		}
254:               		else
255:               		{
256:               			/* The task unblocked because the bits were set.  Clear the control
257:               			bits before returning the value. */
258:               			uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
003726  200FF4     MOV #0xFF, W4
003728  620F1E     AND W4, [W14], [W14]
259:               		}
260:               	}
261:               
262:               	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
263:               	return uxReturn;
00372A  78021E     MOV [W14], W4
264:               }
00372C  780004     MOV W4, W0
00372E  FA8000     ULNK
003730  060000     RETURN
265:               /*-----------------------------------------------------------*/
266:               
267:               EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
268:               {
003732  FA0018     LNK #0x18
003734  980770     MOV W0, [W14+14]
003736  980F01     MOV W1, [W14+16]
003738  980F12     MOV W2, [W14+18]
00373A  980F23     MOV W3, [W14+20]
00373C  980F34     MOV W4, [W14+22]
269:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
00373E  90027E     MOV [W14+14], W4
003740  980724     MOV W4, [W14+4]
270:               EventBits_t uxReturn, uxControlBits = 0;
003742  EB0200     CLR W4
003744  980714     MOV W4, [W14+2]
271:               BaseType_t xWaitConditionMet, xAlreadyYielded;
272:               BaseType_t xTimeoutOccurred = pdFALSE;
003746  EB0200     CLR W4
003748  980734     MOV W4, [W14+6]
273:               
274:               	/* Check the user is not attempting to wait on the bits used by the kernel
275:               	itself, and that at least one bit is being requested. */
276:               	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
277:               	configASSERT( uxBitsToWaitFor != 0 );
278:               	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
279:               	{
280:               		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
281:               	}
282:               	#endif
283:               
284:               	vTaskSuspendAll();
00374A  021928     CALL vTaskSuspendAll
00374C  000000     NOP
285:               	{
286:               		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
00374E  90022E     MOV [W14+4], W4
003750  780294     MOV [W4], W5
003752  980745     MOV W5, [W14+8]
287:               
288:               		/* Check to see if the wait condition is already met or not. */
289:               		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
003754  90092E     MOV [W14+20], W2
003756  90088E     MOV [W14+16], W1
003758  90004E     MOV [W14+8], W0
00375A  070127     RCALL _prvTestWaitCondition
00375C  780200     MOV W0, W4
00375E  980754     MOV W4, [W14+10]
290:               
291:               		if( xWaitConditionMet != pdFALSE )
003760  90025E     MOV [W14+10], W4
003762  520FE0     SUB W4, #0x0, [W15]
003764  32000F     BRA Z, 0x3784
292:               		{
293:               			/* The wait condition has already been met so there is no need to
294:               			block. */
295:               			uxReturn = uxCurrentEventBits;
003766  90034E     MOV [W14+8], W6
003768  780F06     MOV W6, [W14]
296:               			xTicksToWait = ( TickType_t ) 0;
00376A  EB0200     CLR W4
00376C  980F34     MOV W4, [W14+22]
297:               
298:               			/* Clear the wait bits if requested to do so. */
299:               			if( xClearOnExit != pdFALSE )
00376E  900A1E     MOV [W14+18], W4
003770  520FE0     SUB W4, #0x0, [W15]
003772  32002A     BRA Z, 0x37C8
300:               			{
301:               				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
003774  90022E     MOV [W14+4], W4
003776  780294     MOV [W4], W5
003778  900A0E     MOV [W14+16], W4
00377A  EA8204     COM W4, W4
00377C  628284     AND W5, W4, W5
00377E  90022E     MOV [W14+4], W4
003780  780A05     MOV W5, [W4]
003782  370022     BRA 0x37C8
302:               			}
303:               			else
304:               			{
305:               				mtCOVERAGE_TEST_MARKER();
306:               			}
307:               		}
308:               		else if( xTicksToWait == ( TickType_t ) 0 )
003784  900A3E     MOV [W14+22], W4
003786  520FE0     SUB W4, #0x0, [W15]
003788  3A0003     BRA NZ, 0x3790
309:               		{
310:               			/* The wait condition has not been met, but no block time was
311:               			specified, so just return the current value. */
312:               			uxReturn = uxCurrentEventBits;
00378A  90024E     MOV [W14+8], W4
00378C  780F04     MOV W4, [W14]
00378E  37001C     BRA 0x37C8
313:               		}
314:               		else
315:               		{
316:               			/* The task is going to block to wait for its required bits to be
317:               			set.  uxControlBits are used to remember the specified behaviour of
318:               			this call to xEventGroupWaitBits() - for use when the event bits
319:               			unblock the task. */
320:               			if( xClearOnExit != pdFALSE )
003790  900A1E     MOV [W14+18], W4
003792  520FE0     SUB W4, #0x0, [W15]
003794  320004     BRA Z, 0x379E
321:               			{
322:               				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
003796  90029E     MOV [W14+2], W5
003798  201004     MOV #0x100, W4
00379A  720205     IOR W4, W5, W4
00379C  980714     MOV W4, [W14+2]
323:               			}
324:               			else
325:               			{
326:               				mtCOVERAGE_TEST_MARKER();
327:               			}
328:               
329:               			if( xWaitForAllBits != pdFALSE )
00379E  900A2E     MOV [W14+20], W4
0037A0  520FE0     SUB W4, #0x0, [W15]
0037A2  320004     BRA Z, 0x37AC
330:               			{
331:               				uxControlBits |= eventWAIT_FOR_ALL_BITS;
0037A4  90029E     MOV [W14+2], W5
0037A6  204004     MOV #0x400, W4
0037A8  720205     IOR W4, W5, W4
0037AA  980714     MOV W4, [W14+2]
332:               			}
333:               			else
334:               			{
335:               				mtCOVERAGE_TEST_MARKER();
336:               			}
337:               
338:               			/* Store the bits that the calling task is waiting for in the
339:               			task's event list item so the kernel knows when a match is
340:               			found.  Then enter the blocked state. */
341:               			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
0037AC  900A8E     MOV [W14+16], W5
0037AE  90021E     MOV [W14+2], W4
0037B0  780304     MOV W4, W6
0037B2  730305     IOR W6, W5, W6
0037B4  780286     MOV W6, W5
0037B6  90022E     MOV [W14+4], W4
0037B8  E88204     INC2 W4, W4
0037BA  90093E     MOV [W14+22], W2
0037BC  780085     MOV W5, W1
0037BE  780004     MOV W4, W0
0037C0  021C56     CALL vTaskPlaceOnUnorderedEventList
0037C2  000000     NOP
342:               
343:               			/* This is obsolete as it will get set after the task unblocks, but
344:               			some compilers mistakenly generate a warning about the variable
345:               			being returned without being set if it is not done. */
346:               			uxReturn = 0;
0037C4  EB0200     CLR W4
0037C6  780F04     MOV W4, [W14]
347:               
348:               			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
349:               		}
350:               	}
351:               	xAlreadyYielded = xTaskResumeAll();
0037C8  021934     CALL xTaskResumeAll
0037CA  000000     NOP
0037CC  780200     MOV W0, W4
0037CE  980764     MOV W4, [W14+12]
352:               
353:               	if( xTicksToWait != ( TickType_t ) 0 )
0037D0  900A3E     MOV [W14+22], W4
0037D2  520FE0     SUB W4, #0x0, [W15]
0037D4  32002A     BRA Z, 0x382A
354:               	{
355:               		if( xAlreadyYielded == pdFALSE )
0037D6  90026E     MOV [W14+12], W4
0037D8  520FE0     SUB W4, #0x0, [W15]
0037DA  3A0003     BRA NZ, 0x37E2
356:               		{
357:               			portYIELD_WITHIN_API();
0037DC  024F06     CALL _vPortYield
0037DE  000000     NOP
0037E0  000000     NOP
358:               		}
359:               		else
360:               		{
361:               			mtCOVERAGE_TEST_MARKER();
362:               		}
363:               
364:               		/* The task blocked to wait for its required bits to be set - at this
365:               		point either the required bits were set or the block time expired.  If
366:               		the required bits were set they will have been stored in the task's
367:               		event list item, and they should now be retrieved then cleared. */
368:               		uxReturn = uxTaskResetEventItemValue();
0037E2  0223EE     CALL uxTaskResetEventItemValue
0037E4  000000     NOP
0037E6  780200     MOV W0, W4
0037E8  780F04     MOV W4, [W14]
369:               
370:               		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
0037EA  202004     MOV #0x200, W4
0037EC  62021E     AND W4, [W14], W4
0037EE  520FE0     SUB W4, #0x0, [W15]
0037F0  3A001A     BRA NZ, 0x3826
371:               		{
372:               			taskENTER_CRITICAL();
0037F2  02497A     CALL vPortEnterCritical
0037F4  000000     NOP
373:               			{
374:               				/* The task timed out, just return the current event bit value. */
375:               				uxReturn = pxEventBits->uxEventBits;
0037F6  90022E     MOV [W14+4], W4
0037F8  780F14     MOV [W4], [W14]
376:               
377:               				/* It is possible that the event bits were updated between this
378:               				task leaving the Blocked state and running again. */
379:               				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
0037FA  90092E     MOV [W14+20], W2
0037FC  90088E     MOV [W14+16], W1
0037FE  78001E     MOV [W14], W0
003800  0700D4     RCALL _prvTestWaitCondition
003802  780200     MOV W0, W4
003804  520FE0     SUB W4, #0x0, [W15]
003806  32000A     BRA Z, 0x381C
380:               				{
381:               					if( xClearOnExit != pdFALSE )
003808  900A1E     MOV [W14+18], W4
00380A  520FE0     SUB W4, #0x0, [W15]
00380C  320007     BRA Z, 0x381C
382:               					{
383:               						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00380E  90022E     MOV [W14+4], W4
003810  780294     MOV [W4], W5
003812  900A0E     MOV [W14+16], W4
003814  EA8204     COM W4, W4
003816  628284     AND W5, W4, W5
003818  90022E     MOV [W14+4], W4
00381A  780A05     MOV W5, [W4]
384:               					}
385:               					else
386:               					{
387:               						mtCOVERAGE_TEST_MARKER();
388:               					}
389:               				}
390:               				else
391:               				{
392:               					mtCOVERAGE_TEST_MARKER();
393:               				}
394:               			}
395:               			taskEXIT_CRITICAL();
00381C  02498E     CALL vPortExitCritical
00381E  000000     NOP
396:               
397:               			xTimeoutOccurred = pdFALSE;
003820  EB0200     CLR W4
003822  980734     MOV W4, [W14+6]
003824  370002     BRA 0x382A
398:               		}
399:               		else
400:               		{
401:               			/* The task unblocked because the bits were set.  Clear the control
402:               			bits before returning the value. */
403:               			uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
003826  200FF4     MOV #0xFF, W4
003828  620F1E     AND W4, [W14], [W14]
404:               		}
405:               	}
406:               	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
407:               	return uxReturn;
00382A  78021E     MOV [W14], W4
408:               }
00382C  780004     MOV W4, W0
00382E  FA8000     ULNK
003830  060000     RETURN
409:               /*-----------------------------------------------------------*/
410:               
411:               EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
412:               {
003832  FA0008     LNK #0x8
003834  980720     MOV W0, [W14+4]
003836  980731     MOV W1, [W14+6]
413:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
003838  90022E     MOV [W14+4], W4
00383A  780F04     MOV W4, [W14]
414:               EventBits_t uxReturn;
415:               
416:               	/* Check the user is not attempting to clear the bits used by the kernel
417:               	itself. */
418:               	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
419:               
420:               	taskENTER_CRITICAL();
00383C  02497A     CALL vPortEnterCritical
00383E  000000     NOP
421:               	{
422:               		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
423:               
424:               		/* The value returned is the event group value prior to the bits being
425:               		cleared. */
426:               		uxReturn = pxEventBits->uxEventBits;
003840  78021E     MOV [W14], W4
003842  780294     MOV [W4], W5
003844  980715     MOV W5, [W14+2]
427:               
428:               		/* Clear the bits. */
429:               		pxEventBits->uxEventBits &= ~uxBitsToClear;
003846  78021E     MOV [W14], W4
003848  780294     MOV [W4], W5
00384A  90023E     MOV [W14+6], W4
00384C  EA8204     COM W4, W4
00384E  628284     AND W5, W4, W5
003850  78021E     MOV [W14], W4
003852  780A05     MOV W5, [W4]
430:               	}
431:               	taskEXIT_CRITICAL();
003854  02498E     CALL vPortExitCritical
003856  000000     NOP
432:               
433:               	return uxReturn;
003858  90021E     MOV [W14+2], W4
434:               }
00385A  780004     MOV W4, W0
00385C  FA8000     ULNK
00385E  060000     RETURN
435:               /*-----------------------------------------------------------*/
436:               
437:               EventBits_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
438:               {
003860  FA000A     LNK #0xA
003862  980730     MOV W0, [W14+6]
003864  980741     MOV W1, [W14+8]
439:               UBaseType_t uxSavedInterruptStatus;
440:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
003866  90023E     MOV [W14+6], W4
003868  780F04     MOV W4, [W14]
441:               EventBits_t uxReturn;
442:               
443:               	/* Check the user is not attempting to clear the bits used by the kernel
444:               	itself. */
445:               	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
446:               
447:               	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00386A  EB0200     CLR W4
00386C  980714     MOV W4, [W14+2]
448:               	{
449:               		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
450:               
451:               		/* The value returned is the event group value prior to the bits being
452:               		cleared. */
453:               		uxReturn = pxEventBits->uxEventBits;
00386E  78021E     MOV [W14], W4
003870  780294     MOV [W4], W5
003872  980725     MOV W5, [W14+4]
454:               
455:               		/* Clear the bits. */
456:               		pxEventBits->uxEventBits &= ~uxBitsToClear;
003874  78021E     MOV [W14], W4
003876  780294     MOV [W4], W5
003878  90024E     MOV [W14+8], W4
00387A  EA8204     COM W4, W4
00387C  628284     AND W5, W4, W5
00387E  78021E     MOV [W14], W4
003880  780A05     MOV W5, [W4]
457:               	}
458:               	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
459:               
460:               	return uxReturn;
003882  90022E     MOV [W14+4], W4
461:               }
003884  780004     MOV W4, W0
003886  FA8000     ULNK
003888  060000     RETURN
462:               /*-----------------------------------------------------------*/
463:               
464:               EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
465:               {
00388A  FA0016     LNK #0x16
00388C  980F10     MOV W0, [W14+18]
00388E  980F21     MOV W1, [W14+20]
466:               ListItem_t *pxListItem, *pxNext;
467:               ListItem_t const *pxListEnd;
468:               List_t *pxList;
469:               EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
003890  EB0200     CLR W4
003892  980714     MOV W4, [W14+2]
470:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
003894  900A1E     MOV [W14+18], W4
003896  980734     MOV W4, [W14+6]
471:               BaseType_t xMatchFound = pdFALSE;
003898  EB0200     CLR W4
00389A  980724     MOV W4, [W14+4]
472:               
473:               	/* Check the user is not attempting to set the bits used by the kernel
474:               	itself. */
475:               	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
476:               
477:               	pxList = &( pxEventBits->xTasksWaitingForBits );
00389C  90023E     MOV [W14+6], W4
00389E  E88204     INC2 W4, W4
0038A0  980744     MOV W4, [W14+8]
478:               	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
0038A2  90024E     MOV [W14+8], W4
0038A4  420264     ADD W4, #0x4, W4
0038A6  980754     MOV W4, [W14+10]
479:               	vTaskSuspendAll();
0038A8  021928     CALL vTaskSuspendAll
0038AA  000000     NOP
480:               	{
481:               		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
482:               
483:               		pxListItem = listGET_HEAD_ENTRY( pxList );
0038AC  90024E     MOV [W14+8], W4
0038AE  9002B4     MOV [W4+6], W5
0038B0  780F05     MOV W5, [W14]
484:               
485:               		/* Set the bits. */
486:               		pxEventBits->uxEventBits |= uxBitsToSet;
0038B2  90023E     MOV [W14+6], W4
0038B4  780294     MOV [W4], W5
0038B6  900A2E     MOV [W14+20], W4
0038B8  780304     MOV W4, W6
0038BA  730305     IOR W6, W5, W6
0038BC  780286     MOV W6, W5
0038BE  90023E     MOV [W14+6], W4
0038C0  780A05     MOV W5, [W4]
487:               
488:               		/* See if the new bit value should unblock any tasks. */
489:               		while( pxListItem != pxListEnd )
0038C2  37003D     BRA 0x393E
00393E  90025E     MOV [W14+10], W4
003940  78029E     MOV [W14], W5
003942  528F84     SUB W5, W4, [W15]
003944  3AFFBF     BRA NZ, 0x38C4
490:               		{
491:               			pxNext = listGET_NEXT( pxListItem );
0038C4  78021E     MOV [W14], W4
0038C6  900294     MOV [W4+2], W5
0038C8  980765     MOV W5, [W14+12]
492:               			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
0038CA  78021E     MOV [W14], W4
0038CC  780314     MOV [W4], W6
0038CE  980776     MOV W6, [W14+14]
493:               			xMatchFound = pdFALSE;
0038D0  EB0200     CLR W4
0038D2  980724     MOV W4, [W14+4]
494:               
495:               			/* Split the bits waited for from the control bits. */
496:               			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
0038D4  9002FE     MOV [W14+14], W5
0038D6  2FF004     MOV #0xFF00, W4
0038D8  628204     AND W5, W4, W4
0038DA  980F04     MOV W4, [W14+16]
497:               			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
0038DC  9002FE     MOV [W14+14], W5
0038DE  200FF4     MOV #0xFF, W4
0038E0  628204     AND W5, W4, W4
0038E2  980774     MOV W4, [W14+14]
498:               
499:               			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
0038E4  900A8E     MOV [W14+16], W5
0038E6  204004     MOV #0x400, W4
0038E8  628204     AND W5, W4, W4
0038EA  520FE0     SUB W4, #0x0, [W15]
0038EC  3A0009     BRA NZ, 0x3900
500:               			{
501:               				/* Just looking for single bit being set. */
502:               				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
0038EE  90023E     MOV [W14+6], W4
0038F0  780294     MOV [W4], W5
0038F2  90027E     MOV [W14+14], W4
0038F4  628204     AND W5, W4, W4
0038F6  520FE0     SUB W4, #0x0, [W15]
0038F8  32000C     BRA Z, 0x3912
503:               				{
504:               					xMatchFound = pdTRUE;
0038FA  200014     MOV #0x1, W4
0038FC  980724     MOV W4, [W14+4]
0038FE  370009     BRA 0x3912
505:               				}
506:               				else
507:               				{
508:               					mtCOVERAGE_TEST_MARKER();
509:               				}
510:               			}
511:               			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
003900  90023E     MOV [W14+6], W4
003902  780294     MOV [W4], W5
003904  90027E     MOV [W14+14], W4
003906  628284     AND W5, W4, W5
003908  90027E     MOV [W14+14], W4
00390A  528F84     SUB W5, W4, [W15]
00390C  3A0002     BRA NZ, 0x3912
512:               			{
513:               				/* All bits are set. */
514:               				xMatchFound = pdTRUE;
00390E  200014     MOV #0x1, W4
003910  980724     MOV W4, [W14+4]
515:               			}
516:               			else
517:               			{
518:               				/* Need all bits to be set, but not all the bits were set. */
519:               			}
520:               
521:               			if( xMatchFound != pdFALSE )
003912  90022E     MOV [W14+4], W4
003914  520FE0     SUB W4, #0x0, [W15]
003916  320011     BRA Z, 0x393A
522:               			{
523:               				/* The bits match.  Should the bits be cleared on exit? */
524:               				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
003918  900A8E     MOV [W14+16], W5
00391A  201004     MOV #0x100, W4
00391C  628204     AND W5, W4, W4
00391E  520FE0     SUB W4, #0x0, [W15]
003920  320004     BRA Z, 0x392A
525:               				{
526:               					uxBitsToClear |= uxBitsWaitedFor;
003922  90029E     MOV [W14+2], W5
003924  90027E     MOV [W14+14], W4
003926  720205     IOR W4, W5, W4
003928  980714     MOV W4, [W14+2]
527:               				}
528:               				else
529:               				{
530:               					mtCOVERAGE_TEST_MARKER();
531:               				}
532:               
533:               				/* Store the actual event flag value in the task's event list
534:               				item before removing the task from the event list.  The
535:               				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
536:               				that is was unblocked due to its required bits matching, rather
537:               				than because it timed out. */
538:               				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
00392A  90023E     MOV [W14+6], W4
00392C  780294     MOV [W4], W5
00392E  202004     MOV #0x200, W4
003930  720205     IOR W4, W5, W4
003932  780084     MOV W4, W1
003934  78001E     MOV [W14], W0
003936  021D46     CALL xTaskRemoveFromUnorderedEventList
003938  000000     NOP
539:               			}
540:               
541:               			/* Move onto the next list item.  Note pxListItem->pxNext is not
542:               			used here as the list item may have been removed from the event list
543:               			and inserted into the ready/pending reading list. */
544:               			pxListItem = pxNext;
00393A  90026E     MOV [W14+12], W4
00393C  780F04     MOV W4, [W14]
545:               		}
546:               
547:               		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
548:               		bit was set in the control word. */
549:               		pxEventBits->uxEventBits &= ~uxBitsToClear;
003946  90023E     MOV [W14+6], W4
003948  780294     MOV [W4], W5
00394A  90021E     MOV [W14+2], W4
00394C  EA8204     COM W4, W4
00394E  628284     AND W5, W4, W5
003950  90023E     MOV [W14+6], W4
003952  780A05     MOV W5, [W4]
550:               	}
551:               	( void ) xTaskResumeAll();
003954  021934     CALL xTaskResumeAll
003956  000000     NOP
552:               
553:               	return pxEventBits->uxEventBits;
003958  90023E     MOV [W14+6], W4
00395A  780214     MOV [W4], W4
554:               }
00395C  780004     MOV W4, W0
00395E  FA8000     ULNK
003960  060000     RETURN
555:               /*-----------------------------------------------------------*/
556:               
557:               void vEventGroupDelete( EventGroupHandle_t xEventGroup )
558:               {
003962  FA0006     LNK #0x6
003964  980720     MOV W0, [W14+4]
559:               EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
003966  90022E     MOV [W14+4], W4
003968  780F04     MOV W4, [W14]
560:               const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
00396A  E8821E     INC2 [W14], W4
00396C  980714     MOV W4, [W14+2]
561:               
562:               	vTaskSuspendAll();
00396E  021928     CALL vTaskSuspendAll
003970  000000     NOP
563:               	{
564:               		traceEVENT_GROUP_DELETE( xEventGroup );
565:               
566:               		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
003972  370006     BRA 0x3980
003980  90021E     MOV [W14+2], W4
003982  780214     MOV [W4], W4
003984  520FE0     SUB W4, #0x0, [W15]
003986  3AFFF6     BRA NZ, 0x3974
567:               		{
568:               			/* Unblock the task, returning 0 as the event list is being deleted
569:               			and	cannot therefore have any bits set. */
570:               			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
571:               			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
003974  90021E     MOV [W14+2], W4
003976  900234     MOV [W4+6], W4
003978  202001     MOV #0x200, W1
00397A  780004     MOV W4, W0
00397C  021D46     CALL xTaskRemoveFromUnorderedEventList
00397E  000000     NOP
572:               		}
573:               
574:               		vPortFree( pxEventBits );
003988  78001E     MOV [W14], W0
00398A  024330     CALL vPortFree
00398C  000000     NOP
575:               	}
576:               	( void ) xTaskResumeAll();
00398E  021934     CALL xTaskResumeAll
003990  000000     NOP
577:               }
003992  FA8000     ULNK
003994  060000     RETURN
578:               /*-----------------------------------------------------------*/
579:               
580:               /* For internal use only - execute a 'set bits' command that was pended from
581:               an interrupt. */
582:               void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
583:               {
003996  FA0006     LNK #0x6
003998  780F00     MOV W0, [W14]
00399A  980712     MOV W2, [W14+2]
00399C  980723     MOV W3, [W14+4]
584:               	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
00399E  90021E     MOV [W14+2], W4
0039A0  780084     MOV W4, W1
0039A2  78001E     MOV [W14], W0
0039A4  07FF72     RCALL xEventGroupSetBits
585:               }
0039A6  FA8000     ULNK
0039A8  060000     RETURN
586:               /*-----------------------------------------------------------*/
587:               
588:               static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
589:               {
0039AA  FA0008     LNK #0x8
0039AC  980710     MOV W0, [W14+2]
0039AE  980721     MOV W1, [W14+4]
0039B0  980732     MOV W2, [W14+6]
590:               BaseType_t xWaitConditionMet = pdFALSE;
0039B2  EB0200     CLR W4
0039B4  780F04     MOV W4, [W14]
591:               
592:               	if( xWaitForAllBits == pdFALSE )
0039B6  90023E     MOV [W14+6], W4
0039B8  520FE0     SUB W4, #0x0, [W15]
0039BA  3A0008     BRA NZ, 0x39CC
593:               	{
594:               		/* Task only has to wait for one bit within uxBitsToWaitFor to be
595:               		set.  Is one already set? */
596:               		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
0039BC  90029E     MOV [W14+2], W5
0039BE  90022E     MOV [W14+4], W4
0039C0  628204     AND W5, W4, W4
0039C2  520FE0     SUB W4, #0x0, [W15]
0039C4  32000B     BRA Z, 0x39DC
597:               		{
598:               			xWaitConditionMet = pdTRUE;
0039C6  200014     MOV #0x1, W4
0039C8  780F04     MOV W4, [W14]
0039CA  370008     BRA 0x39DC
599:               		}
600:               		else
601:               		{
602:               			mtCOVERAGE_TEST_MARKER();
603:               		}
604:               	}
605:               	else
606:               	{
607:               		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
608:               		Are they set already? */
609:               		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
0039CC  90029E     MOV [W14+2], W5
0039CE  90022E     MOV [W14+4], W4
0039D0  628284     AND W5, W4, W5
0039D2  90022E     MOV [W14+4], W4
0039D4  528F84     SUB W5, W4, [W15]
0039D6  3A0002     BRA NZ, 0x39DC
610:               		{
611:               			xWaitConditionMet = pdTRUE;
0039D8  200014     MOV #0x1, W4
0039DA  780F04     MOV W4, [W14]
612:               		}
613:               		else
614:               		{
615:               			mtCOVERAGE_TEST_MARKER();
616:               		}
617:               	}
618:               
619:               	return xWaitConditionMet;
0039DC  78021E     MOV [W14], W4
620:               }
0039DE  780004     MOV W4, W0
0039E0  FA8000     ULNK
0039E2  060000     RETURN
621:               /*-----------------------------------------------------------*/
622:               
623:               #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) )
624:               	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
625:               	{
626:               	BaseType_t xReturn;
627:               
628:               		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
629:               		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
630:               
631:               		return xReturn;
632:               	}
633:               #endif
634:               /*-----------------------------------------------------------*/
635:               
636:               #if (configUSE_TRACE_FACILITY == 1)
637:               	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
638:               	{
0039E4  FA0006     LNK #0x6
0039E6  980720     MOV W0, [W14+4]
639:               	UBaseType_t xReturn;
640:               	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
0039E8  90022E     MOV [W14+4], W4
0039EA  980714     MOV W4, [W14+2]
641:               
642:               		if( xEventGroup == NULL )
0039EC  90022E     MOV [W14+4], W4
0039EE  520FE0     SUB W4, #0x0, [W15]
0039F0  3A0003     BRA NZ, 0x39F8
643:               		{
644:               			xReturn = 0;
0039F2  EB0200     CLR W4
0039F4  780F04     MOV W4, [W14]
0039F6  370003     BRA 0x39FE
645:               		}
646:               		else
647:               		{
648:               			xReturn = pxEventBits->uxEventGroupNumber;
0039F8  90021E     MOV [W14+2], W4
0039FA  9002E4     MOV [W4+12], W5
0039FC  780F05     MOV W5, [W14]
649:               		}
650:               
651:               		return xReturn;
0039FE  78021E     MOV [W14], W4
652:               	}
003A00  780004     MOV W4, W0
003A02  FA8000     ULNK
003A04  060000     RETURN
653:               #endif
654:               
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Projects/BearAlarm.X/source/FreeRTOS/croutine.c
1:                 /*
2:                     FreeRTOS V8.0.0 - Copyright (C) 2014 Real Time Engineers Ltd.
3:                     All rights reserved
4:                 
5:                     VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION.
6:                 
7:                     ***************************************************************************
8:                      *                                                                       *
9:                      *    FreeRTOS provides completely free yet professionally developed,    *
10:                     *    robust, strictly quality controlled, supported, and cross          *
11:                     *    platform software that has become a de facto standard.             *
12:                     *                                                                       *
13:                     *    Help yourself get started quickly and support the FreeRTOS         *
14:                     *    project by purchasing a FreeRTOS tutorial book, reference          *
15:                     *    manual, or both from: http://www.FreeRTOS.org/Documentation        *
16:                     *                                                                       *
17:                     *    Thank you!                                                         *
18:                     *                                                                       *
19:                    ***************************************************************************
20:                
21:                    This file is part of the FreeRTOS distribution.
22:                
23:                    FreeRTOS is free software; you can redistribute it and/or modify it under
24:                    the terms of the GNU General Public License (version 2) as published by the
25:                    Free Software Foundation >>!AND MODIFIED BY!<< the FreeRTOS exception.
26:                
27:                    >>! NOTE: The modification to the GPL is included to allow you to distribute
28:                    >>! a combined work that includes FreeRTOS without being obliged to provide
29:                    >>! the source code for proprietary components outside of the FreeRTOS
30:                    >>! kernel.
31:                
32:                    FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY
33:                    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
34:                    FOR A PARTICULAR PURPOSE.  Full license text is available from the following
35:                    link: http://www.freertos.org/a00114.html
36:                
37:                    1 tab == 4 spaces!
38:                
39:                    ***************************************************************************
40:                     *                                                                       *
41:                     *    Having a problem?  Start by reading the FAQ "My application does   *
42:                     *    not run, what could be wrong?"                                     *
43:                     *                                                                       *
44:                     *    http://www.FreeRTOS.org/FAQHelp.html                               *
45:                     *                                                                       *
46:                    ***************************************************************************
47:                
48:                    http://www.FreeRTOS.org - Documentation, books, training, latest versions,
49:                    license and Real Time Engineers Ltd. contact details.
50:                
51:                    http://www.FreeRTOS.org/plus - A selection of FreeRTOS ecosystem products,
52:                    including FreeRTOS+Trace - an indispensable productivity tool, a DOS
53:                    compatible FAT file system, and our tiny thread aware UDP/IP stack.
54:                
55:                    http://www.OpenRTOS.com - Real Time Engineers ltd license FreeRTOS to High
56:                    Integrity Systems to sell under the OpenRTOS brand.  Low cost OpenRTOS
57:                    licenses offer ticketed support, indemnification and middleware.
58:                
59:                    http://www.SafeRTOS.com - High Integrity Systems also provide a safety
60:                    engineered and independently SIL3 certified version for use in safety and
61:                    mission critical applications that require provable dependability.
62:                
63:                    1 tab == 4 spaces!
64:                */
65:                
66:                #include "FreeRTOS.h"
67:                #include "task.h"
68:                #include "croutine.h"
69:                
70:                /*
71:                 * Some kernel aware debuggers require data to be viewed to be global, rather
72:                 * than file scope.
73:                 */
74:                #ifdef portREMOVE_STATIC_QUALIFIER
75:                	#define static
76:                #endif
77:                
78:                
79:                /* Lists for ready and blocked co-routines. --------------------*/
80:                static List_t pxReadyCoRoutineLists[ configMAX_CO_ROUTINE_PRIORITIES ];	/*< Prioritised ready co-routines. */
81:                static List_t xDelayedCoRoutineList1;									/*< Delayed co-routines. */
82:                static List_t xDelayedCoRoutineList2;									/*< Delayed co-routines (two lists are used - one for delays that have overflowed the current tick count. */
83:                static List_t * pxDelayedCoRoutineList;									/*< Points to the delayed co-routine list currently being used. */
84:                static List_t * pxOverflowDelayedCoRoutineList;							/*< Points to the delayed co-routine list currently being used to hold co-routines that have overflowed the current tick count. */
85:                static List_t xPendingReadyCoRoutineList;								/*< Holds co-routines that have been readied by an external event.  They cannot be added directly to the ready lists as the ready lists cannot be accessed by interrupts. */
86:                
87:                /* Other file private variables. --------------------------------*/
88:                CRCB_t * pxCurrentCoRoutine = NULL;
89:                static UBaseType_t uxTopCoRoutineReadyPriority = 0;
90:                static TickType_t xCoRoutineTickCount = 0, xLastTickCount = 0, xPassedTicks = 0;
91:                
92:                /* The initial state of the co-routine when it is created. */
93:                #define corINITIAL_STATE	( 0 )
94:                
95:                /*
96:                 * Place the co-routine represented by pxCRCB into the appropriate ready queue
97:                 * for the priority.  It is inserted at the end of the list.
98:                 *
99:                 * This macro accesses the co-routine ready lists and therefore must not be
100:                * used from within an ISR.
101:                */
102:               #define prvAddCoRoutineToReadyQueue( pxCRCB )																		\
103:               {																													\
104:               	if( pxCRCB->uxPriority > uxTopCoRoutineReadyPriority )															\
105:               	{																												\
106:               		uxTopCoRoutineReadyPriority = pxCRCB->uxPriority;															\
107:               	}																												\
108:               	vListInsertEnd( ( List_t * ) &( pxReadyCoRoutineLists[ pxCRCB->uxPriority ] ), &( pxCRCB->xGenericListItem ) );	\
109:               }
110:               
111:               /*
112:                * Utility to ready all the lists used by the scheduler.  This is called
113:                * automatically upon the creation of the first co-routine.
114:                */
115:               static void prvInitialiseCoRoutineLists( void );
116:               
117:               /*
118:                * Co-routines that are readied by an interrupt cannot be placed directly into
119:                * the ready lists (there is no mutual exclusion).  Instead they are placed in
120:                * in the pending ready list in order that they can later be moved to the ready
121:                * list by the co-routine scheduler.
122:                */
123:               static void prvCheckPendingReadyList( void );
124:               
125:               /*
126:                * Macro that looks at the list of co-routines that are currently delayed to
127:                * see if any require waking.
128:                *
129:                * Co-routines are stored in the queue in the order of their wake time -
130:                * meaning once one co-routine has been found whose timer has not expired
131:                * we need not look any further down the list.
132:                */
133:               static void prvCheckDelayedList( void );
134:               
135:               /*-----------------------------------------------------------*/
136:               
137:               BaseType_t xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, UBaseType_t uxPriority, UBaseType_t uxIndex )
138:               {
003A06  FA000A     LNK #0xA
003A08  980720     MOV W0, [W14+4]
003A0A  980731     MOV W1, [W14+6]
003A0C  980742     MOV W2, [W14+8]
139:               BaseType_t xReturn;
140:               CRCB_t *pxCoRoutine;
141:               
142:               	/* Allocate the memory that will store the co-routine control block. */
143:               	pxCoRoutine = ( CRCB_t * ) pvPortMalloc( sizeof( CRCB_t ) );
003A0E  2001C0     MOV #0x1C, W0
003A10  024240     CALL pvPortMalloc
003A12  000000     NOP
003A14  780200     MOV W0, W4
003A16  980714     MOV W4, [W14+2]
144:               	if( pxCoRoutine )
003A18  90021E     MOV [W14+2], W4
003A1A  520FE0     SUB W4, #0x0, [W15]
003A1C  320041     BRA Z, 0x3AA0
145:               	{
146:               		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
147:               		be created and the co-routine data structures need initialising. */
148:               		if( pxCurrentCoRoutine == NULL )
003A1E  82FFB4     MOV pxCurrentCoRoutine, W4
003A20  520FE0     SUB W4, #0x0, [W15]
003A22  3A0003     BRA NZ, 0x3A2A
149:               		{
150:               			pxCurrentCoRoutine = pxCoRoutine;
003A24  90021E     MOV [W14+2], W4
003A26  8AFFB4     MOV W4, pxCurrentCoRoutine
151:               			prvInitialiseCoRoutineLists();
003A28  07012B     RCALL prvInitialiseCoRoutineLists
152:               		}
153:               
154:               		/* Check the priority is within limits. */
155:               		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
003A2A  90023E     MOV [W14+6], W4
003A2C  520FE1     SUB W4, #0x1, [W15]
003A2E  360002     BRA LEU, 0x3A34
156:               		{
157:               			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
003A30  200014     MOV #0x1, W4
003A32  980734     MOV W4, [W14+6]
158:               		}
159:               
160:               		/* Fill out the co-routine control block from the function parameters. */
161:               		pxCoRoutine->uxState = corINITIAL_STATE;
003A34  90021E     MOV [W14+2], W4
003A36  EB0280     CLR W5
003A38  980A55     MOV W5, [W4+26]
162:               		pxCoRoutine->uxPriority = uxPriority;
003A3A  90021E     MOV [W14+2], W4
003A3C  9002BE     MOV [W14+6], W5
003A3E  980A35     MOV W5, [W4+22]
163:               		pxCoRoutine->uxIndex = uxIndex;
003A40  90021E     MOV [W14+2], W4
003A42  9002CE     MOV [W14+8], W5
003A44  980A45     MOV W5, [W4+24]
164:               		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
003A46  90021E     MOV [W14+2], W4
003A48  9002AE     MOV [W14+4], W5
003A4A  780A05     MOV W5, [W4]
165:               
166:               		/* Initialise all the other co-routine control block parameters. */
167:               		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
003A4C  90021E     MOV [W14+2], W4
003A4E  E88204     INC2 W4, W4
003A50  780004     MOV W4, W0
003A52  024B60     CALL vListInitialiseItem
003A54  000000     NOP
168:               		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
003A56  90021E     MOV [W14+2], W4
003A58  42026C     ADD W4, #0xC, W4
003A5A  780004     MOV W4, W0
003A5C  024B60     CALL vListInitialiseItem
003A5E  000000     NOP
169:               
170:               		/* Set the co-routine control block as a link back from the ListItem_t.
171:               		This is so we can get back to the containing CRCB from a generic item
172:               		in a list. */
173:               		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
003A60  90021E     MOV [W14+2], W4
003A62  90029E     MOV [W14+2], W5
003A64  980245     MOV W5, [W4+8]
174:               		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
003A66  90021E     MOV [W14+2], W4
003A68  90029E     MOV [W14+2], W5
003A6A  980A15     MOV W5, [W4+18]
175:               
176:               		/* Event lists are always in priority order. */
177:               		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), ( ( TickType_t ) configMAX_CO_ROUTINE_PRIORITIES - ( TickType_t ) uxPriority ) );
003A6C  90023E     MOV [W14+6], W4
003A6E  1202E2     SUBR W4, #0x2, W5
003A70  90021E     MOV [W14+2], W4
003A72  980265     MOV W5, [W4+12]
178:               
179:               		/* Now the co-routine has been initialised it can be added to the ready
180:               		list at the correct priority. */
181:               		prvAddCoRoutineToReadyQueue( pxCoRoutine );
003A74  90021E     MOV [W14+2], W4
003A76  900AB4     MOV [W4+22], W5
003A78  82FFC4     MOV uxTopCoRoutineReadyPriority, W4
003A7A  528F84     SUB W5, W4, [W15]
003A7C  360003     BRA LEU, 0x3A84
003A7E  90021E     MOV [W14+2], W4
003A80  900A34     MOV [W4+22], W4
003A82  8AFFC4     MOV W4, uxTopCoRoutineReadyPriority
003A84  90021E     MOV [W14+2], W4
003A86  E88284     INC2 W4, W5
003A88  90021E     MOV [W14+2], W4
003A8A  900A34     MOV [W4+22], W4
003A8C  B923EA     MUL.SU W4, #10, W6
003A8E  25FC04     MOV #0x5FC0, W4
003A90  430204     ADD W6, W4, W4
003A92  780085     MOV W5, W1
003A94  780004     MOV W4, W0
003A96  024B6E     CALL vListInsertEnd
003A98  000000     NOP
182:               
183:               		xReturn = pdPASS;
003A9A  200014     MOV #0x1, W4
003A9C  780F04     MOV W4, [W14]
003A9E  370002     BRA 0x3AA4
184:               	}
185:               	else
186:               	{
187:               		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
003AA0  EB8200     SETM W4
003AA2  780F04     MOV W4, [W14]
188:               	}
189:               
190:               	return xReturn;
003AA4  78021E     MOV [W14], W4
191:               }
003AA6  780004     MOV W4, W0
003AA8  FA8000     ULNK
003AAA  060000     RETURN
192:               /*-----------------------------------------------------------*/
193:               
194:               void vCoRoutineAddToDelayedList( TickType_t xTicksToDelay, List_t *pxEventList )
195:               {
003AAC  FA0006     LNK #0x6
003AAE  980710     MOV W0, [W14+2]
003AB0  980721     MOV W1, [W14+4]
196:               TickType_t xTimeToWake;
197:               
198:               	/* Calculate the time to wake - this may overflow but this is
199:               	not a problem. */
200:               	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
003AB2  82FFD5     MOV xCoRoutineTickCount, W5
003AB4  90021E     MOV [W14+2], W4
003AB6  428F04     ADD W5, W4, [W14]
201:               
202:               	/* We must remove ourselves from the ready list before adding
203:               	ourselves to the blocked list as the same list item is used for
204:               	both lists. */
205:               	( void ) uxListRemove( ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
003AB8  82FFB4     MOV pxCurrentCoRoutine, W4
003ABA  E88204     INC2 W4, W4
003ABC  780004     MOV W4, W0
003ABE  024C0E     CALL uxListRemove
003AC0  000000     NOP
206:               
207:               	/* The list item will be inserted in wake time order. */
208:               	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
003AC2  82FFB4     MOV pxCurrentCoRoutine, W4
003AC4  78029E     MOV [W14], W5
003AC6  980215     MOV W5, [W4+2]
209:               
210:               	if( xTimeToWake < xCoRoutineTickCount )
003AC8  82FFD4     MOV xCoRoutineTickCount, W4
003ACA  78029E     MOV [W14], W5
003ACC  528F84     SUB W5, W4, [W15]
003ACE  310008     BRA C, 0x3AE0
211:               	{
212:               		/* Wake time has overflowed.  Place this item in the
213:               		overflow list. */
214:               		vListInsert( ( List_t * ) pxOverflowDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
003AD0  82FFB4     MOV pxCurrentCoRoutine, W4
003AD2  E88284     INC2 W4, W5
003AD4  82FF54     MOV pxOverflowDelayedCoRoutineList, W4
003AD6  780085     MOV W5, W1
003AD8  780004     MOV W4, W0
003ADA  024BAA     CALL vListInsert
003ADC  000000     NOP
003ADE  370007     BRA 0x3AEE
215:               	}
216:               	else
217:               	{
218:               		/* The wake time has not overflowed, so we can use the
219:               		current block list. */
220:               		vListInsert( ( List_t * ) pxDelayedCoRoutineList, ( ListItem_t * ) &( pxCurrentCoRoutine->xGenericListItem ) );
003AE0  82FFB4     MOV pxCurrentCoRoutine, W4
003AE2  E88284     INC2 W4, W5
003AE4  82FF44     MOV pxDelayedCoRoutineList, W4
003AE6  780085     MOV W5, W1
003AE8  780004     MOV W4, W0
003AEA  024BAA     CALL vListInsert
003AEC  000000     NOP
221:               	}
222:               
223:               	if( pxEventList )
003AEE  90022E     MOV [W14+4], W4
003AF0  520FE0     SUB W4, #0x0, [W15]
003AF2  320006     BRA Z, 0x3B00
224:               	{
225:               		/* Also add the co-routine to an event list.  If this is done then the
226:               		function must be called with interrupts disabled. */
227:               		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
003AF4  82FFB4     MOV pxCurrentCoRoutine, W4
003AF6  42026C     ADD W4, #0xC, W4
003AF8  780084     MOV W4, W1
003AFA  90002E     MOV [W14+4], W0
003AFC  024BAA     CALL vListInsert
003AFE  000000     NOP
228:               	}
229:               }
003B00  FA8000     ULNK
003B02  060000     RETURN
230:               /*-----------------------------------------------------------*/
231:               
232:               static void prvCheckPendingReadyList( void )
233:               {
003B04  FA0002     LNK #0x2
234:               	/* Are there any co-routines waiting to get moved to the ready list?  These
235:               	are co-routines that have been readied by an ISR.  The ISR cannot access
236:               	the	ready lists itself. */
237:               	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
003B06  370026     BRA 0x3B54
003B54  82FF64     MOV xPendingReadyCoRoutineList, W4
003B56  520FE0     SUB W4, #0x0, [W15]
003B58  3AFFD7     BRA NZ, 0x3B08
238:               	{
239:               		CRCB_t *pxUnblockedCRCB;
240:               
241:               		/* The pending ready list can be accessed by an ISR. */
242:               		portDISABLE_INTERRUPTS();
003B08  800215     MOV SR, W5
003B0A  200204     MOV #0x20, W4
003B0C  720205     IOR W4, W5, W4
003B0E  880214     MOV W4, SR
243:               		{
244:               			pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
003B10  82FF94     MOV 0x5FF2, W4
003B12  900234     MOV [W4+6], W4
003B14  780F04     MOV W4, [W14]
245:               			( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
003B16  78029E     MOV [W14], W5
003B18  42826C     ADD W5, #0xC, W4
003B1A  780004     MOV W4, W0
003B1C  024C0E     CALL uxListRemove
003B1E  000000     NOP
246:               		}
247:               		portENABLE_INTERRUPTS();
003B20  800215     MOV SR, W5
003B22  2FFDF4     MOV #0xFFDF, W4
003B24  628204     AND W5, W4, W4
003B26  880214     MOV W4, SR
248:               
249:               		( void ) uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
003B28  E8821E     INC2 [W14], W4
003B2A  780004     MOV W4, W0
003B2C  024C0E     CALL uxListRemove
003B2E  000000     NOP
250:               		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
003B30  78021E     MOV [W14], W4
003B32  900AB4     MOV [W4+22], W5
003B34  82FFC4     MOV uxTopCoRoutineReadyPriority, W4
003B36  528F84     SUB W5, W4, [W15]
003B38  360003     BRA LEU, 0x3B40
003B3A  78021E     MOV [W14], W4
003B3C  900A34     MOV [W4+22], W4
003B3E  8AFFC4     MOV W4, uxTopCoRoutineReadyPriority
003B40  E8829E     INC2 [W14], W5
003B42  78021E     MOV [W14], W4
003B44  900A34     MOV [W4+22], W4
003B46  B923EA     MUL.SU W4, #10, W6
003B48  25FC04     MOV #0x5FC0, W4
003B4A  430204     ADD W6, W4, W4
003B4C  780085     MOV W5, W1
003B4E  780004     MOV W4, W0
003B50  024B6E     CALL vListInsertEnd
003B52  000000     NOP
251:               	}
252:               }
003B5A  FA8000     ULNK
003B5C  060000     RETURN
253:               /*-----------------------------------------------------------*/
254:               
255:               static void prvCheckDelayedList( void )
256:               {
003B5E  FA0004     LNK #0x4
257:               CRCB_t *pxCRCB;
258:               
259:               	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
003B60  0219E4     CALL xTaskGetTickCount
003B62  000000     NOP
003B64  780200     MOV W0, W4
003B66  82FFE5     MOV xLastTickCount, W5
003B68  520205     SUB W4, W5, W4
003B6A  8AFFF4     MOV W4, xPassedTicks
260:               	while( xPassedTicks )
003B6C  37004A     BRA 0x3C02
003C02  82FFF4     MOV xPassedTicks, W4
003C04  520FE0     SUB W4, #0x0, [W15]
003C06  3AFFB3     BRA NZ, 0x3B6E
261:               	{
262:               		xCoRoutineTickCount++;
003B6E  82FFD4     MOV xCoRoutineTickCount, W4
003B70  E80204     INC W4, W4
003B72  8AFFD4     MOV W4, xCoRoutineTickCount
263:               		xPassedTicks--;
003B74  82FFF4     MOV xPassedTicks, W4
003B76  E90204     DEC W4, W4
003B78  8AFFF4     MOV W4, xPassedTicks
264:               
265:               		/* If the tick count has overflowed we need to swap the ready lists. */
266:               		if( xCoRoutineTickCount == 0 )
003B7A  82FFD4     MOV xCoRoutineTickCount, W4
003B7C  520FE0     SUB W4, #0x0, [W15]
003B7E  3A003A     BRA NZ, 0x3BF4
267:               		{
268:               			List_t * pxTemp;
269:               
270:               			/* Tick count has overflowed so we need to swap the delay lists.  If there are
271:               			any items in pxDelayedCoRoutineList here then there is an error! */
272:               			pxTemp = pxDelayedCoRoutineList;
003B80  82FF44     MOV pxDelayedCoRoutineList, W4
003B82  780F04     MOV W4, [W14]
273:               			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
003B84  82FF54     MOV pxOverflowDelayedCoRoutineList, W4
003B86  8AFF44     MOV W4, pxDelayedCoRoutineList
274:               			pxOverflowDelayedCoRoutineList = pxTemp;
003B88  78021E     MOV [W14], W4
003B8A  8AFF54     MOV W4, pxOverflowDelayedCoRoutineList
275:               		}
276:               
277:               		/* See if this tick has made a timeout expire. */
278:               		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
003B8C  370034     BRA 0x3BF6
003BF4  000000     NOP
003BF6  82FF44     MOV pxDelayedCoRoutineList, W4
003BF8  780214     MOV [W4], W4
003BFA  520FE0     SUB W4, #0x0, [W15]
003BFC  3AFFC8     BRA NZ, 0x3B8E
003BFE  370001     BRA 0x3C02
279:               		{
280:               			pxCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
003B8E  82FF44     MOV pxDelayedCoRoutineList, W4
003B90  900234     MOV [W4+6], W4
003B92  900234     MOV [W4+6], W4
003B94  980714     MOV W4, [W14+2]
281:               
282:               			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
003B96  90021E     MOV [W14+2], W4
003B98  900294     MOV [W4+2], W5
003B9A  82FFD4     MOV xCoRoutineTickCount, W4
003B9C  528F84     SUB W5, W4, [W15]
003B9E  3E0030     BRA GTU, 0x3C00
283:               			{
284:               				/* Timeout not yet expired. */
285:               				break;
003C00  000000     NOP
286:               			}
287:               
288:               			portDISABLE_INTERRUPTS();
003BA0  800215     MOV SR, W5
003BA2  200204     MOV #0x20, W4
003BA4  720205     IOR W4, W5, W4
003BA6  880214     MOV W4, SR
289:               			{
290:               				/* The event could have occurred just before this critical
291:               				section.  If this is the case then the generic list item will
292:               				have been moved to the pending ready list and the following
293:               				line is still valid.  Also the pvContainer parameter will have
294:               				been set to NULL so the following lines are also valid. */
295:               				uxListRemove( &( pxCRCB->xGenericListItem ) );
003BA8  90021E     MOV [W14+2], W4
003BAA  E88204     INC2 W4, W4
003BAC  780004     MOV W4, W0
003BAE  024C0E     CALL uxListRemove
003BB0  000000     NOP
296:               
297:               				/* Is the co-routine waiting on an event also? */
298:               				if( pxCRCB->xEventListItem.pvContainer )
003BB2  90021E     MOV [W14+2], W4
003BB4  900A24     MOV [W4+20], W4
003BB6  520FE0     SUB W4, #0x0, [W15]
003BB8  320005     BRA Z, 0x3BC4
299:               				{
300:               					( void ) uxListRemove( &( pxCRCB->xEventListItem ) );
003BBA  90021E     MOV [W14+2], W4
003BBC  42026C     ADD W4, #0xC, W4
003BBE  780004     MOV W4, W0
003BC0  024C0E     CALL uxListRemove
003BC2  000000     NOP
301:               				}
302:               			}
303:               			portENABLE_INTERRUPTS();
003BC4  800215     MOV SR, W5
003BC6  2FFDF4     MOV #0xFFDF, W4
003BC8  628204     AND W5, W4, W4
003BCA  880214     MOV W4, SR
304:               
305:               			prvAddCoRoutineToReadyQueue( pxCRCB );
003BCC  90021E     MOV [W14+2], W4
003BCE  900AB4     MOV [W4+22], W5
003BD0  82FFC4     MOV uxTopCoRoutineReadyPriority, W4
003BD2  528F84     SUB W5, W4, [W15]
003BD4  360003     BRA LEU, 0x3BDC
003BD6  90021E     MOV [W14+2], W4
003BD8  900A34     MOV [W4+22], W4
003BDA  8AFFC4     MOV W4, uxTopCoRoutineReadyPriority
003BDC  90021E     MOV [W14+2], W4
003BDE  E88284     INC2 W4, W5
003BE0  90021E     MOV [W14+2], W4
003BE2  900A34     MOV [W4+22], W4
003BE4  B923EA     MUL.SU W4, #10, W6
003BE6  25FC04     MOV #0x5FC0, W4
003BE8  430204     ADD W6, W4, W4
003BEA  780085     MOV W5, W1
003BEC  780004     MOV W4, W0
003BEE  024B6E     CALL vListInsertEnd
003BF0  000000     NOP
003BF2  370001     BRA 0x3BF6
306:               		}
307:               	}
308:               
309:               	xLastTickCount = xCoRoutineTickCount;
003C08  82FFD4     MOV xCoRoutineTickCount, W4
003C0A  8AFFE4     MOV W4, xLastTickCount
310:               }
003C0C  FA8000     ULNK
003C0E  060000     RETURN
311:               /*-----------------------------------------------------------*/
312:               
313:               void vCoRoutineSchedule( void )
314:               {
003C10  FA0002     LNK #0x2
315:               	/* See if any co-routines readied by events need moving to the ready lists. */
316:               	prvCheckPendingReadyList();
003C12  07FF78     RCALL prvCheckPendingReadyList
317:               
318:               	/* See if any delayed co-routines have timed out. */
319:               	prvCheckDelayedList();
003C14  07FFA4     RCALL prvCheckDelayedList
320:               
321:               	/* Find the highest priority queue that contains ready co-routines. */
322:               	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
003C16  370006     BRA 0x3C24
003C24  82FFC4     MOV uxTopCoRoutineReadyPriority, W4
003C26  B922EA     MUL.SU W4, #10, W4
003C28  780284     MOV W4, W5
003C2A  25FC04     MOV #0x5FC0, W4
003C2C  428204     ADD W5, W4, W4
003C2E  780214     MOV [W4], W4
003C30  520FE0     SUB W4, #0x0, [W15]
003C32  32FFF2     BRA Z, 0x3C18
323:               	{
324:               		if( uxTopCoRoutineReadyPriority == 0 )
003C18  82FFC4     MOV uxTopCoRoutineReadyPriority, W4
003C1A  520FE0     SUB W4, #0x0, [W15]
003C1C  32002E     BRA Z, 0x3C7A
325:               		{
326:               			/* No more co-routines to check. */
327:               			return;
003C7A  000000     NOP
328:               		}
329:               		--uxTopCoRoutineReadyPriority;
003C1E  82FFC4     MOV uxTopCoRoutineReadyPriority, W4
003C20  E90204     DEC W4, W4
003C22  8AFFC4     MOV W4, uxTopCoRoutineReadyPriority
330:               	}
331:               
332:               	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
333:               	 of the	same priority get an equal share of the processor time. */
334:               	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
003C34  82FFC4     MOV uxTopCoRoutineReadyPriority, W4
003C36  B922EA     MUL.SU W4, #10, W4
003C38  780284     MOV W4, W5
003C3A  25FC04     MOV #0x5FC0, W4
003C3C  428F04     ADD W5, W4, [W14]
003C3E  78021E     MOV [W14], W4
003C40  900214     MOV [W4+2], W4
003C42  900294     MOV [W4+2], W5
003C44  78021E     MOV [W14], W4
003C46  980215     MOV W5, [W4+2]
003C48  78021E     MOV [W14], W4
003C4A  900294     MOV [W4+2], W5
003C4C  78031E     MOV [W14], W6
003C4E  430264     ADD W6, #0x4, W4
003C50  528F84     SUB W5, W4, [W15]
003C52  3A0005     BRA NZ, 0x3C5E
003C54  78021E     MOV [W14], W4
003C56  900214     MOV [W4+2], W4
003C58  900294     MOV [W4+2], W5
003C5A  78021E     MOV [W14], W4
003C5C  980215     MOV W5, [W4+2]
003C5E  78021E     MOV [W14], W4
003C60  900214     MOV [W4+2], W4
003C62  900234     MOV [W4+6], W4
003C64  8AFFB4     MOV W4, pxCurrentCoRoutine
335:               
336:               	/* Call the co-routine. */
337:               	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
003C66  82FFB4     MOV pxCurrentCoRoutine, W4
003C68  780314     MOV [W4], W6
003C6A  82FFB4     MOV pxCurrentCoRoutine, W4
003C6C  900AC4     MOV [W4+24], W5
003C6E  82FFB4     MOV pxCurrentCoRoutine, W4
003C70  780085     MOV W5, W1
003C72  780004     MOV W4, W0
003C74  010006     CALL W6
338:               
339:               	return;
003C76  000000     NOP
003C78  370001     BRA 0x3C7C
340:               }
003C7C  FA8000     ULNK
003C7E  060000     RETURN
341:               /*-----------------------------------------------------------*/
342:               
343:               static void prvInitialiseCoRoutineLists( void )
344:               {
003C80  FA0002     LNK #0x2
345:               UBaseType_t uxPriority;
346:               
347:               	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
003C82  EB0200     CLR W4
003C84  780F04     MOV W4, [W14]
003C86  370009     BRA 0x3C9A
003C98  E80F1E     INC [W14], [W14]
003C9A  78021E     MOV [W14], W4
003C9C  520FE1     SUB W4, #0x1, [W15]
003C9E  36FFF4     BRA LEU, 0x3C88
348:               	{
349:               		vListInitialise( ( List_t * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
003C88  78021E     MOV [W14], W4
003C8A  B922EA     MUL.SU W4, #10, W4
003C8C  780284     MOV W4, W5
003C8E  25FC04     MOV #0x5FC0, W4
003C90  428204     ADD W5, W4, W4
003C92  780004     MOV W4, W0
003C94  024B2E     CALL vListInitialise
003C96  000000     NOP
350:               	}
351:               
352:               	vListInitialise( ( List_t * ) &xDelayedCoRoutineList1 );
003CA0  25FD40     MOV #0x5FD4, W0
003CA2  024B2E     CALL vListInitialise
003CA4  000000     NOP
353:               	vListInitialise( ( List_t * ) &xDelayedCoRoutineList2 );
003CA6  25FDE0     MOV #0x5FDE, W0
003CA8  024B2E     CALL vListInitialise
003CAA  000000     NOP
354:               	vListInitialise( ( List_t * ) &xPendingReadyCoRoutineList );
003CAC  25FEC0     MOV #0x5FEC, W0
003CAE  024B2E     CALL vListInitialise
003CB0  000000     NOP
355:               
356:               	/* Start with pxDelayedCoRoutineList using list1 and the
357:               	pxOverflowDelayedCoRoutineList using list2. */
358:               	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
003CB2  25FD44     MOV #0x5FD4, W4
003CB4  8AFF44     MOV W4, pxDelayedCoRoutineList
359:               	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
003CB6  25FDE4     MOV #0x5FDE, W4
003CB8  8AFF54     MOV W4, pxOverflowDelayedCoRoutineList
360:               }
003CBA  FA8000     ULNK
003CBC  060000     RETURN
361:               /*-----------------------------------------------------------*/
362:               
363:               BaseType_t xCoRoutineRemoveFromEventList( const List_t *pxEventList )
364:               {
003CBE  FA0006     LNK #0x6
003CC0  980720     MOV W0, [W14+4]
365:               CRCB_t *pxUnblockedCRCB;
366:               BaseType_t xReturn;
367:               
368:               	/* This function is called from within an interrupt.  It can only access
369:               	event lists and the pending ready list.  This function assumes that a
370:               	check has already been made to ensure pxEventList is not empty. */
371:               	pxUnblockedCRCB = ( CRCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
003CC2  90022E     MOV [W14+4], W4
003CC4  900234     MOV [W4+6], W4
003CC6  900234     MOV [W4+6], W4
003CC8  980714     MOV W4, [W14+2]
372:               	( void ) uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
003CCA  90021E     MOV [W14+2], W4
003CCC  42026C     ADD W4, #0xC, W4
003CCE  780004     MOV W4, W0
003CD0  024C0E     CALL uxListRemove
003CD2  000000     NOP
373:               	vListInsertEnd( ( List_t * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
003CD4  90021E     MOV [W14+2], W4
003CD6  42026C     ADD W4, #0xC, W4
003CD8  780084     MOV W4, W1
003CDA  25FEC0     MOV #0x5FEC, W0
003CDC  024B6E     CALL vListInsertEnd
003CDE  000000     NOP
374:               
375:               	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
003CE0  90021E     MOV [W14+2], W4
003CE2  900AB4     MOV [W4+22], W5
003CE4  82FFB4     MOV pxCurrentCoRoutine, W4
003CE6  900A34     MOV [W4+22], W4
003CE8  528F84     SUB W5, W4, [W15]
003CEA  390003     BRA NC, 0x3CF2
376:               	{
377:               		xReturn = pdTRUE;
003CEC  200014     MOV #0x1, W4
003CEE  780F04     MOV W4, [W14]
003CF0  370002     BRA 0x3CF6
378:               	}
379:               	else
380:               	{
381:               		xReturn = pdFALSE;
003CF2  EB0200     CLR W4
003CF4  780F04     MOV W4, [W14]
382:               	}
383:               
384:               	return xReturn;
003CF6  78021E     MOV [W14], W4
385:               }
003CF8  780004     MOV W4, W0
003CFA  FA8000     ULNK
003CFC  060000     RETURN
386:               
---  C:/Users/dom/Google Drive/SCC/Perforce/dom_home_test/Code Modules/CC2500/CC2500.X/source/c/CC2500.c  
1:                 #include "CC2500.h"
2:                 
3:                 
4:                 /**
5:                  * Configures the module use. Sets center frequency, frequency deviation,
6:                  * channel number, packet screening, data rate and channel bw settings
7:                  * @param chipNumber
8:                  * @return
9:                  */
10:                int CC2500_ConfigForUse(CC2500_Session session)
11:                {
002C1A  FA0004     LNK #0x4
002C1C  980710     MOV W0, [W14+2]
12:                    int error = 0;
002C1E  EB0200     CLR W4
002C20  780F04     MOV W4, [W14]
13:                    //reset the device
14:                    error = CC2500_WriteStrobe(session, CC2500_SRES);
002C22  B3C301     MOV.B #0x30, W1
002C24  90001E     MOV [W14+2], W0
002C26  07016D     RCALL CC2500_WriteStrobe
002C28  780200     MOV W0, W4
002C2A  780F04     MOV W4, [W14]
15:                
16:                    //RFStudio RECOMMENDATIONS FOR HIGH SENSITIVITY 500kb/s MSK
17:                    error = CC2500_WriteRegister(session, CC2500_PKTCTRL0,0x05,error);
002C2C  78019E     MOV [W14], W3
002C2E  B3C052     MOV.B #0x5, W2
002C30  200081     MOV #0x8, W1
002C32  90001E     MOV [W14+2], W0
002C34  070134     RCALL CC2500_WriteRegister
002C36  780200     MOV W0, W4
002C38  780F04     MOV W4, [W14]
18:                    error = CC2500_WriteRegister(session, CC2500_FSCTRL1, 0x0C,error);
002C3A  78019E     MOV [W14], W3
002C3C  B3C0C2     MOV.B #0xC, W2
002C3E  2000B1     MOV #0xB, W1
002C40  90001E     MOV [W14+2], W0
002C42  07012D     RCALL CC2500_WriteRegister
002C44  780200     MOV W0, W4
002C46  780F04     MOV W4, [W14]
19:                    error = CC2500_WriteRegister(session, CC2500_FREQ2,   0x5D,error);
002C48  78019E     MOV [W14], W3
002C4A  B3C5D2     MOV.B #0x5D, W2
002C4C  2000D1     MOV #0xD, W1
002C4E  90001E     MOV [W14+2], W0
002C50  070126     RCALL CC2500_WriteRegister
002C52  780200     MOV W0, W4
002C54  780F04     MOV W4, [W14]
20:                    error = CC2500_WriteRegister(session, CC2500_FREQ1,   0x93,error);
002C56  78019E     MOV [W14], W3
002C58  B3C932     MOV.B #0x93, W2
002C5A  2000E1     MOV #0xE, W1
002C5C  90001E     MOV [W14+2], W0
002C5E  07011F     RCALL CC2500_WriteRegister
002C60  780200     MOV W0, W4
002C62  780F04     MOV W4, [W14]
21:                    error = CC2500_WriteRegister(session, CC2500_FREQ0,   0xB1,error);
002C64  78019E     MOV [W14], W3
002C66  B3CB12     MOV.B #0xB1, W2
002C68  2000F1     MOV #0xF, W1
002C6A  90001E     MOV [W14+2], W0
002C6C  070118     RCALL CC2500_WriteRegister
002C6E  780200     MOV W0, W4
002C70  780F04     MOV W4, [W14]
22:                    error = CC2500_WriteRegister(session, CC2500_MDMCFG4, 0x0E,error);
002C72  78019E     MOV [W14], W3
002C74  B3C0E2     MOV.B #0xE, W2
002C76  200101     MOV #0x10, W1
002C78  90001E     MOV [W14+2], W0
002C7A  070111     RCALL CC2500_WriteRegister
002C7C  780200     MOV W0, W4
002C7E  780F04     MOV W4, [W14]
23:                    error = CC2500_WriteRegister(session, CC2500_MDMCFG3, 0x3B,error);
002C80  78019E     MOV [W14], W3
002C82  B3C3B2     MOV.B #0x3B, W2
002C84  200111     MOV #0x11, W1
002C86  90001E     MOV [W14+2], W0
002C88  07010A     RCALL CC2500_WriteRegister
002C8A  780200     MOV W0, W4
002C8C  780F04     MOV W4, [W14]
24:                    error = CC2500_WriteRegister(session, CC2500_MDMCFG2, 0x73,error);
002C8E  78019E     MOV [W14], W3
002C90  B3C732     MOV.B #0x73, W2
002C92  200121     MOV #0x12, W1
002C94  90001E     MOV [W14+2], W0
002C96  070103     RCALL CC2500_WriteRegister
002C98  780200     MOV W0, W4
002C9A  780F04     MOV W4, [W14]
25:                    error = CC2500_WriteRegister(session, CC2500_MDMCFG1, 0x42,error);
002C9C  78019E     MOV [W14], W3
002C9E  B3C422     MOV.B #0x42, W2
002CA0  200131     MOV #0x13, W1
002CA2  90001E     MOV [W14+2], W0
002CA4  0700FC     RCALL CC2500_WriteRegister
002CA6  780200     MOV W0, W4
002CA8  780F04     MOV W4, [W14]
26:                    error = CC2500_WriteRegister(session, CC2500_DEVIATN, 0x00,error);
002CAA  78019E     MOV [W14], W3
002CAC  EB4100     CLR.B W2
002CAE  200151     MOV #0x15, W1
002CB0  90001E     MOV [W14+2], W0
002CB2  0700F5     RCALL CC2500_WriteRegister
002CB4  780200     MOV W0, W4
002CB6  780F04     MOV W4, [W14]
27:                    error = CC2500_WriteRegister(session, CC2500_MCSM0,   0x18,error);
002CB8  78019E     MOV [W14], W3
002CBA  B3C182     MOV.B #0x18, W2
002CBC  200181     MOV #0x18, W1
002CBE  90001E     MOV [W14+2], W0
002CC0  0700EE     RCALL CC2500_WriteRegister
002CC2  780200     MOV W0, W4
002CC4  780F04     MOV W4, [W14]
28:                    error = CC2500_WriteRegister(session, CC2500_FOCCFG,  0x1D,error);
002CC6  78019E     MOV [W14], W3
002CC8  B3C1D2     MOV.B #0x1D, W2
002CCA  200191     MOV #0x19, W1
002CCC  90001E     MOV [W14+2], W0
002CCE  0700E7     RCALL CC2500_WriteRegister
002CD0  780200     MOV W0, W4
002CD2  780F04     MOV W4, [W14]
29:                    error = CC2500_WriteRegister(session, CC2500_BSCFG,   0x1C,error);
002CD4  78019E     MOV [W14], W3
002CD6  B3C1C2     MOV.B #0x1C, W2
002CD8  2001A1     MOV #0x1A, W1
002CDA  90001E     MOV [W14+2], W0
002CDC  0700E0     RCALL CC2500_WriteRegister
002CDE  780200     MOV W0, W4
002CE0  780F04     MOV W4, [W14]
30:                    error = CC2500_WriteRegister(session, CC2500_AGCCTRL2,0xC7,error);
002CE2  78019E     MOV [W14], W3
002CE4  B3CC72     MOV.B #0xC7, W2
002CE6  2001B1     MOV #0x1B, W1
002CE8  90001E     MOV [W14+2], W0
002CEA  0700D9     RCALL CC2500_WriteRegister
002CEC  780200     MOV W0, W4
002CEE  780F04     MOV W4, [W14]
31:                    error = CC2500_WriteRegister(session, CC2500_AGCCTRL0,0xB0,error);
002CF0  78019E     MOV [W14], W3
002CF2  B3CB02     MOV.B #0xB0, W2
002CF4  2001D1     MOV #0x1D, W1
002CF6  90001E     MOV [W14+2], W0
002CF8  0700D2     RCALL CC2500_WriteRegister
002CFA  780200     MOV W0, W4
002CFC  780F04     MOV W4, [W14]
32:                    error = CC2500_WriteRegister(session, CC2500_FREND1,  0xB6,error);
002CFE  78019E     MOV [W14], W3
002D00  B3CB62     MOV.B #0xB6, W2
002D02  200211     MOV #0x21, W1
002D04  90001E     MOV [W14+2], W0
002D06  0700CB     RCALL CC2500_WriteRegister
002D08  780200     MOV W0, W4
002D0A  780F04     MOV W4, [W14]
33:                    error = CC2500_WriteRegister(session, CC2500_FSCAL3,  0xEA,error);
002D0C  78019E     MOV [W14], W3
002D0E  B3CEA2     MOV.B #0xEA, W2
002D10  200231     MOV #0x23, W1
002D12  90001E     MOV [W14+2], W0
002D14  0700C4     RCALL CC2500_WriteRegister
002D16  780200     MOV W0, W4
002D18  780F04     MOV W4, [W14]
34:                    error = CC2500_WriteRegister(session, CC2500_FSCAL1,  0x00,error);
002D1A  78019E     MOV [W14], W3
002D1C  EB4100     CLR.B W2
002D1E  200251     MOV #0x25, W1
002D20  90001E     MOV [W14+2], W0
002D22  0700BD     RCALL CC2500_WriteRegister
002D24  780200     MOV W0, W4
002D26  780F04     MOV W4, [W14]
35:                    error = CC2500_WriteRegister(session, CC2500_FSCAL0,  0x19,error);
002D28  78019E     MOV [W14], W3
002D2A  B3C192     MOV.B #0x19, W2
002D2C  200261     MOV #0x26, W1
002D2E  90001E     MOV [W14+2], W0
002D30  0700B6     RCALL CC2500_WriteRegister
002D32  780200     MOV W0, W4
002D34  780F04     MOV W4, [W14]
36:                
37:                    //USER OVERRIDES
38:                
39:                    //0x2E HiZ
40:                    //0x08 preamble quality reached
41:                    //0x09 clear channel assessment
42:                    //0x06 "sent/received sync word"
43:                    //0x01 RX FIFO full or packet received
44:                
45:                    //set output pins to HiZ. GD02 is the "packet received" signal
46:                    error = CC2500_WriteRegister(session, CC2500_IOCFG0,0x09,error);
002D36  78019E     MOV [W14], W3
002D38  B3C092     MOV.B #0x9, W2
002D3A  200021     MOV #0x2, W1
002D3C  90001E     MOV [W14+2], W0
002D3E  0700AF     RCALL CC2500_WriteRegister
002D40  780200     MOV W0, W4
002D42  780F04     MOV W4, [W14]
47:                    error = CC2500_WriteRegister(session, CC2500_IOCFG1,0x2E,error);
002D44  78019E     MOV [W14], W3
002D46  B3C2E2     MOV.B #0x2E, W2
002D48  200011     MOV #0x1, W1
002D4A  90001E     MOV [W14+2], W0
002D4C  0700A8     RCALL CC2500_WriteRegister
002D4E  780200     MOV W0, W4
002D50  780F04     MOV W4, [W14]
48:                    error = CC2500_WriteRegister(session, CC2500_IOCFG2,0x01,error);
002D52  78019E     MOV [W14], W3
002D54  B3C012     MOV.B #0x1, W2
002D56  EB0080     CLR W1
002D58  90001E     MOV [W14+2], W0
002D5A  0700A1     RCALL CC2500_WriteRegister
002D5C  780200     MOV W0, W4
002D5E  780F04     MOV W4, [W14]
49:                
50:                    //set the FIFO threshold to 1 in TX, 63 in RX
51:                    error = CC2500_WriteRegister(session, CC2500_FIFOTHR,0x0F,error);
002D60  78019E     MOV [W14], W3
002D62  B3C0F2     MOV.B #0xF, W2
002D64  200031     MOV #0x3, W1
002D66  90001E     MOV [W14+2], W0
002D68  07009A     RCALL CC2500_WriteRegister
002D6A  780200     MOV W0, W4
002D6C  780F04     MOV W4, [W14]
52:                
53:                    //turn on whitening
54:                    error = CC2500_WriteRegister(session, CC2500_PKTCTRL0,0x41,error);
002D6E  78019E     MOV [W14], W3
002D70  B3C412     MOV.B #0x41, W2
002D72  200081     MOV #0x8, W1
002D74  90001E     MOV [W14+2], W0
002D76  070093     RCALL CC2500_WriteRegister
002D78  780200     MOV W0, W4
002D7A  780F04     MOV W4, [W14]
55:                    //set PQT threshold, append status, enable address checking and 
56:                    //0x00 0xff broadcast addresses
57:                    error = CC2500_WriteRegister(session, CC2500_PKTCTRL1,0xD7,error);
002D7C  78019E     MOV [W14], W3
002D7E  B3CD72     MOV.B #0xD7, W2
002D80  200071     MOV #0x7, W1
002D82  90001E     MOV [W14+2], W0
002D84  07008C     RCALL CC2500_WriteRegister
002D86  780200     MOV W0, W4
002D88  780F04     MOV W4, [W14]
58:                    //set receiver address, consider moving this to set up RX function
59:                    error = CC2500_WriteRegister(session, CC2500_ADDR,session->Address,error);
002D8A  90021E     MOV [W14+2], W4
002D8C  904224     MOV.B [W4+2], W4
002D8E  78019E     MOV [W14], W3
002D90  784104     MOV.B W4, W2
002D92  200091     MOV #0x9, W1
002D94  90001E     MOV [W14+2], W0
002D96  070083     RCALL CC2500_WriteRegister
002D98  780200     MOV W0, W4
002D9A  780F04     MOV W4, [W14]
60:                    //increase the number of preamble bytes to 24
61:                    error = CC2500_WriteRegister(session, CC2500_MDMCFG1,0x72,error);
002D9C  78019E     MOV [W14], W3
002D9E  B3C722     MOV.B #0x72, W2
002DA0  200131     MOV #0x13, W1
002DA2  90001E     MOV [W14+2], W0
002DA4  07007C     RCALL CC2500_WriteRegister
002DA6  780200     MOV W0, W4
002DA8  780F04     MOV W4, [W14]
62:                    //remove CCA assessment for TX mode, go to idle after RX/TX
63:                    error = CC2500_WriteRegister(session, CC2500_MCSM1,0x00,error);
002DAA  78019E     MOV [W14], W3
002DAC  EB4100     CLR.B W2
002DAE  200171     MOV #0x17, W1
002DB0  90001E     MOV [W14+2], W0
002DB2  070075     RCALL CC2500_WriteRegister
002DB4  780200     MOV W0, W4
002DB6  780F04     MOV W4, [W14]
64:                
65:                    return error;
002DB8  78021E     MOV [W14], W4
66:                }
002DBA  780004     MOV W4, W0
002DBC  FA8000     ULNK
002DBE  060000     RETURN
67:                
68:                /**
69:                 * Initializes the CC2500 session. This is the first function that needs to be
70:                 * called before the module can be used.
71:                 * @param ChipSelect The function used to control the chip select line
72:                 * @param Address The address to be assigned to this module
73:                 * @param ConfigSPI If false, no SPI settings/lines are changed
74:                 * @return Returns the configured session
75:                 */
76:                CC2500_Session CC2500_Init(void (*ChipSelect)(char Active), char Address,
77:                        char ConfigSPI)
78:                {
002DC0  FA0006     LNK #0x6
002DC2  980710     MOV W0, [W14+2]
002DC4  984741     MOV.B W1, [W14+4]
002DC6  984752     MOV.B W2, [W14+5]
79:                    CC2500_Session session = malloc(sizeof(CC2500_Session_t));
002DC8  200040     MOV #0x4, W0
002DCA  07EC56     RCALL _malloc
002DCC  780200     MOV W0, W4
002DCE  780F04     MOV W4, [W14]
80:                    session->ChipSelect = ChipSelect;
002DD0  78021E     MOV [W14], W4
002DD2  90029E     MOV [W14+2], W5
002DD4  780A05     MOV W5, [W4]
81:                    session->Address = Address;
002DD6  78021E     MOV [W14], W4
002DD8  9042CE     MOV.B [W14+4], W5
002DDA  984225     MOV.B W5, [W4+2]
82:                    if(ConfigSPI)
002DDC  90425E     MOV.B [W14+5], W4
002DDE  524FE0     SUB.B W4, #0x0, [W15]
002DE0  320017     BRA Z, 0x2E10
83:                    {
84:                        //RPI44 PIN 23  RB 12   SDI
85:                        //RP43  PIN 22  RB 11   SDO
86:                        //RP42  PIN 21  RB 10   SCLK
87:                        RPINR22bits.SDI2R = 0x2C;   //assign SDI to RP44
002DE2  803665     MOV RPINR22, W5
002DE4  2FF804     MOV #0xFF80, W4
002DE6  628284     AND W5, W4, W5
002DE8  2002C4     MOV #0x2C, W4
002DEA  720205     IOR W4, W5, W4
002DEC  883664     MOV W4, RPINR22
88:                        RPOR4bits.RP43R = 0x08;     //SDO
002DEE  803445     MOV RPOR4, W5
002DF0  2C0FF4     MOV #0xC0FF, W4
002DF2  628284     AND W5, W4, W5
002DF4  208004     MOV #0x800, W4
002DF6  720205     IOR W4, W5, W4
002DF8  883444     MOV W4, RPOR4
89:                        RPOR4bits.RP42R = 0x09;     //SCLK
002DFA  803445     MOV RPOR4, W5
002DFC  2FFC04     MOV #0xFFC0, W4
002DFE  628204     AND W5, W4, W4
002E00  B30094     IOR #0x9, W4
002E02  883444     MOV W4, RPOR4
90:                
91:                        //configure the SPI bus
92:                        SPICON1 = 0x0132;               //0000 0001 0011 0010 Mode (0,0)
002E04  201324     MOV #0x132, W4
002E06  881314     MOV W4, SPI2CON1
93:                                                        //1:2x4x prescaler
94:                        SPICON2 = 0x0001;               //Enhanced buffer mode
002E08  200014     MOV #0x1, W4
002E0A  881324     MOV W4, SPI2CON2
95:                        SPISTAT = 0xC004;               //1010 0000 0000 0100
002E0C  2C0044     MOV #0xC004, W4
002E0E  881304     MOV W4, SPI2STAT
96:                    }
97:                    CC2500_ChipSelect(session,1);
002E10  B3C011     MOV.B #0x1, W1
002E12  78001E     MOV [W14], W0
002E14  07001C     RCALL CC2500_ChipSelect
98:                    CC2500_ConfigForUse(session);
002E16  78001E     MOV [W14], W0
002E18  07FF00     RCALL CC2500_ConfigForUse
99:                    
100:                   return session;
002E1A  78021E     MOV [W14], W4
101:               }
002E1C  780004     MOV W4, W0
002E1E  FA8000     ULNK
002E20  060000     RETURN
102:               
103:               /**
104:                * Reads a byte from the SPI buffer. Blocks until it receives one
105:                * @param data
106:                * @return
107:                */
108:               int CC2500_SPIReadByte(__eds__ char * data)
109:               {
002E22  FA0004     LNK #0x4
002E24  BE8F00     MOV.D W0, [W14]
110:               
111:                   while(CC2500_SPI_RX_EMPTY == 0x1)
002E26  370001     BRA 0x2E2A
002E2A  801305     MOV SPI2STAT, W5
002E2C  200204     MOV #0x20, W4
002E2E  628204     AND W5, W4, W4
002E30  520FE0     SUB W4, #0x0, [W15]
002E32  3AFFFA     BRA NZ, 0x2E28
112:                       Nop();
002E28  000000     NOP
113:               
114:                   *data = CC2500_SPI_READ_BUFFER;
002E34  801344     MOV SPI2BUF, W4
002E36  784304     MOV.B W4, W6
002E38  BE021E     MOV.D [W14], W4
002E3A  8001A7     MOV DSWPAG, W7
002E3C  780005     MOV W5, W0
002E3E  780204     MOV W4, W4
002E40  8801A0     MOV W0, DSWPAG
002E42  784A06     MOV.B W6, [W4]
002E44  8801A7     MOV W7, DSWPAG
115:               
116:                   return CC2500_NO_ERROR;
002E46  EB0200     CLR W4
117:               
118:               }
002E48  780004     MOV W4, W0
002E4A  FA8000     ULNK
002E4C  060000     RETURN
119:               
120:               int CC2500_ChipSelect(CC2500_Session session, char state)
121:               {
002E4E  FA0004     LNK #0x4
002E50  780F00     MOV W0, [W14]
002E52  984721     MOV.B W1, [W14+2]
122:                   if(session->ChipSelect != 0)
002E54  78021E     MOV [W14], W4
002E56  780214     MOV [W4], W4
002E58  520FE0     SUB W4, #0x0, [W15]
002E5A  320006     BRA Z, 0x2E68
123:                   {
124:                       session->ChipSelect(state);
002E5C  78021E     MOV [W14], W4
002E5E  780214     MOV [W4], W4
002E60  90402E     MOV.B [W14+2], W0
002E62  010004     CALL W4
125:                       return CC2500_NO_ERROR;
002E64  EB0200     CLR W4
002E66  370001     BRA 0x2E6A
126:                   }
127:                   else
128:                       return CC2500_ERROR_INVALID_SESSION;
002E68  20FA34     MOV #0xFA3, W4
129:               }
002E6A  780004     MOV W4, W0
002E6C  FA8000     ULNK
002E6E  060000     RETURN
130:               
131:               /**
132:                * Clears out the SPI receive buffer
133:                * @param error
134:                * @return
135:                */
136:               void CC2500_FlushRx()
137:               {
002E70  FA0002     LNK #0x2
138:                   char temp;
139:                   while((CC2500_SPI_RX_EMPTY) == 0x0)
002E72  370002     BRA 0x2E78
002E78  801305     MOV SPI2STAT, W5
002E7A  200204     MOV #0x20, W4
002E7C  628204     AND W5, W4, W4
002E7E  520FE0     SUB W4, #0x0, [W15]
002E80  32FFF9     BRA Z, 0x2E74
140:                       temp = CC2500_SPI_READ_BUFFER;
002E74  801344     MOV SPI2BUF, W4
002E76  784F04     MOV.B W4, [W14]
141:               
142:               }
002E82  FA8000     ULNK
002E84  060000     RETURN
143:               
144:               int CC2500_WaitForReady()
145:               {
002E86  FA0000     LNK #0x0
146:                       while((CC2500_SPI_SDI))
002E88  370001     BRA 0x2E8C
002E8C  807095     MOV PORTB, W5
002E8E  210004     MOV #0x1000, W4
002E90  628204     AND W5, W4, W4
002E92  520FE0     SUB W4, #0x0, [W15]
002E94  3AFFFA     BRA NZ, 0x2E8A
147:                           Nop();
002E8A  000000     NOP
148:               
149:                   return CC2500_NO_ERROR;
002E96  EB0200     CLR W4
150:               }
002E98  780004     MOV W4, W0
002E9A  FA8000     ULNK
002E9C  060000     RETURN
151:               
152:               /**
153:                *
154:                * @param address the register to write to
155:                * @param data the data to be written
156:                * @param error if > 0, this function simply returns the error
157:                * @return
158:                */
159:               int CC2500_WriteRegister(CC2500_Session session, unsigned int address,
160:                       char data, int error)
161:               {
002E9E  FA0008     LNK #0x8
002EA0  780F00     MOV W0, [W14]
002EA2  980711     MOV W1, [W14+2]
002EA4  984742     MOV.B W2, [W14+4]
002EA6  980733     MOV W3, [W14+6]
162:               
163:                   if(error <= 0){
002EA8  90023E     MOV [W14+6], W4
002EAA  520FE0     SUB W4, #0x0, [W15]
002EAC  3C0026     BRA GT, 0x2EFA
164:               
165:                       CC2500_ChipSelect(session,0);
002EAE  EB4080     CLR.B W1
002EB0  78001E     MOV [W14], W0
002EB2  07FFCD     RCALL CC2500_ChipSelect
166:                       CC2500_FlushRx();
002EB4  07FFDD     RCALL CC2500_FlushRx
167:               
168:                       //wait for the SDI line to be pulled low by the chip signaling
169:                       //that it is ready.
170:                       error = CC2500_WaitForReady(error);
002EB6  90003E     MOV [W14+6], W0
002EB8  07FFE6     RCALL CC2500_WaitForReady
002EBA  780200     MOV W0, W4
002EBC  980734     MOV W4, [W14+6]
171:               
172:                       if(error <= 0)
002EBE  90023E     MOV [W14+6], W4
002EC0  520FE0     SUB W4, #0x0, [W15]
002EC2  3C0016     BRA GT, 0x2EF0
173:                       {
174:                           //[R/nW  B A5-A0]
175:                           //set upper two bits to not burst and write mode
176:                           address &= 0x3F;
002EC4  90029E     MOV [W14+2], W5
002EC6  2003F4     MOV #0x3F, W4
002EC8  628204     AND W5, W4, W4
002ECA  980714     MOV W4, [W14+2]
177:               
178:                           CC2500_SPI_WRITE_BUFFER = address;
002ECC  90021E     MOV [W14+2], W4
002ECE  881344     MOV W4, SPI2BUF
179:                           CC2500_SPI_WRITE_BUFFER = data;
002ED0  90424E     MOV.B [W14+4], W4
002ED2  FB0204     SE W4, W4
002ED4  881344     MOV W4, SPI2BUF
180:               
181:                           //first byte returned will be the status byte. Discard it
182:                           error = CC2500_SPIReadByte(&data);
002ED6  470264     ADD W14, #0x4, W4
002ED8  B92261     MUL.SU W4, #1, W4
002EDA  BE0004     MOV.D W4, W0
002EDC  07FFA2     RCALL CC2500_SPIReadByte
002EDE  780200     MOV W0, W4
002EE0  980734     MOV W4, [W14+6]
183:                           //second byte returned also be data byte. Discard it.
184:                           //these two steps are necessary so the CS line doesn't
185:                           //go high until the SPI engine is done shifting out data
186:                           error = CC2500_SPIReadByte(&data);
002EE2  470264     ADD W14, #0x4, W4
002EE4  B92261     MUL.SU W4, #1, W4
002EE6  BE0004     MOV.D W4, W0
002EE8  07FF9C     RCALL CC2500_SPIReadByte
002EEA  780200     MOV W0, W4
002EEC  980734     MOV W4, [W14+6]
002EEE  370002     BRA 0x2EF4
187:                       }
188:                       else
189:                       {
190:                           error = CC2500_ERROR_DEVICE_NOT_READY;
002EF0  20FA24     MOV #0xFA2, W4
002EF2  980734     MOV W4, [W14+6]
191:                       }
192:               
193:                       CC2500_ChipSelect(session,1);
002EF4  B3C011     MOV.B #0x1, W1
002EF6  78001E     MOV [W14], W0
002EF8  07FFAA     RCALL CC2500_ChipSelect
194:                   }
195:                   return error;
002EFA  90023E     MOV [W14+6], W4
196:               
197:               }
002EFC  780004     MOV W4, W0
002EFE  FA8000     ULNK
002F00  060000     RETURN
198:               int CC2500_WriteStrobe(CC2500_Session session, char strobe)
199:               {
002F02  FA0006     LNK #0x6
002F04  980710     MOV W0, [W14+2]
002F06  984741     MOV.B W1, [W14+4]
200:                   int error = 0;
002F08  EB0200     CLR W4
002F0A  780F04     MOV W4, [W14]
201:                   CC2500_ChipSelect(session,0);
002F0C  EB4080     CLR.B W1
002F0E  90001E     MOV [W14+2], W0
002F10  07FF9E     RCALL CC2500_ChipSelect
202:                   CC2500_FlushRx();
002F12  07FFAE     RCALL CC2500_FlushRx
203:               
204:                   //wait for the SDI line to be pulled low by the chip signaling
205:                   //that it is ready.
206:                   error = CC2500_WaitForReady();
002F14  07FFB8     RCALL CC2500_WaitForReady
002F16  780200     MOV W0, W4
002F18  780F04     MOV W4, [W14]
207:               
208:                   if(error <= 0)
002F1A  78021E     MOV [W14], W4
002F1C  520FE0     SUB W4, #0x0, [W15]
002F1E  3C000A     BRA GT, 0x2F34
209:                   {
210:                       //[R/nW  B A5-A0] <<byte format, B for burst, A is address
211:                       //set upper two bits to not burst and write mode
212:                       CC2500_SPI_WRITE_BUFFER = strobe;
002F20  90424E     MOV.B [W14+4], W4
002F22  FB0204     SE W4, W4
002F24  881344     MOV W4, SPI2BUF
213:               
214:                       //first byte returned will be the status byte. Discard it
215:                       error = CC2500_SPIReadByte(&strobe);
002F26  470264     ADD W14, #0x4, W4
002F28  B92261     MUL.SU W4, #1, W4
002F2A  BE0004     MOV.D W4, W0
002F2C  07FF7A     RCALL CC2500_SPIReadByte
002F2E  780200     MOV W0, W4
002F30  780F04     MOV W4, [W14]
002F32  370002     BRA 0x2F38
216:                       //this step is necessary so the CS line doesnt
217:                       //go high until the SPI engine is done shifting out data
218:                   }
219:                   else
220:                   {
221:                       error = CC2500_ERROR_DEVICE_NOT_READY;
002F34  20FA24     MOV #0xFA2, W4
002F36  780F04     MOV W4, [W14]
222:                   }
223:                   //release chip select
224:                   CC2500_ChipSelect(session,1);
002F38  B3C011     MOV.B #0x1, W1
002F3A  90001E     MOV [W14+2], W0
002F3C  07FF88     RCALL CC2500_ChipSelect
225:                   return error;
002F3E  78021E     MOV [W14], W4
226:               }
002F40  780004     MOV W4, W0
002F42  FA8000     ULNK
002F44  060000     RETURN
227:               
228:               /**
229:                *
230:                * @param address
231:                * @param data
232:                * @param error
233:                * @return
234:                */
235:               int CC2500_ReadRegister(CC2500_Session session, unsigned char address, 
236:                       __eds__ char * data, int error)
237:               {
002F46  FA000A     LNK #0xA
002F48  780F00     MOV W0, [W14]
002F4A  984721     MOV.B W1, [W14+2]
002F4C  980722     MOV W2, [W14+4]
002F4E  980733     MOV W3, [W14+6]
002F50  980744     MOV W4, [W14+8]
238:               
239:                   if(error <= 0){
002F52  90024E     MOV [W14+8], W4
002F54  520FE0     SUB W4, #0x0, [W15]
002F56  3C0027     BRA GT, 0x2FA6
240:               
241:                       CC2500_ChipSelect(session,0);
002F58  EB4080     CLR.B W1
002F5A  78001E     MOV [W14], W0
002F5C  07FF78     RCALL CC2500_ChipSelect
242:                       CC2500_FlushRx();
002F5E  07FF88     RCALL CC2500_FlushRx
243:               
244:                       //wait for the SDI line to be pulled low by the chip signaling
245:                       //that it is ready.
246:                       error = CC2500_WaitForReady(error);
002F60  90004E     MOV [W14+8], W0
002F62  07FF91     RCALL CC2500_WaitForReady
002F64  780200     MOV W0, W4
002F66  980744     MOV W4, [W14+8]
247:               
248:                       if(error <= 0)
002F68  90024E     MOV [W14+8], W4
002F6A  520FE0     SUB W4, #0x0, [W15]
002F6C  3C0017     BRA GT, 0x2F9C
249:                       {
250:                           //[R/nW  B A5-A0]
251:                           //set upper two bits to not burst and read mode
252:                           address &= 0x3F;
002F6E  90422E     MOV.B [W14+2], W4
002F70  B243F4     AND.B #0x3F, W4
002F72  984724     MOV.B W4, [W14+2]
253:                           address |= 0x80;
002F74  9042AE     MOV.B [W14+2], W5
002F76  B3C804     MOV.B #0x80, W4
002F78  72C204     IOR.B W5, W4, W4
002F7A  984724     MOV.B W4, [W14+2]
254:                           CC2500_SPI_WRITE_BUFFER = address;
002F7C  90422E     MOV.B [W14+2], W4
002F7E  FB8204     ZE W4, W4
002F80  881344     MOV W4, SPI2BUF
255:               
256:                           //send dummy byte to shift out the "read" value
257:                           CC2500_SPI_WRITE_BUFFER = 0x0;
002F82  EB0200     CLR W4
002F84  881344     MOV W4, SPI2BUF
258:               
259:                           //first byte returned will be the status byte. Discard it
260:                           error = CC2500_SPIReadByte(data);
002F86  90002E     MOV [W14+4], W0
002F88  9000BE     MOV [W14+6], W1
002F8A  07FF4B     RCALL CC2500_SPIReadByte
002F8C  780200     MOV W0, W4
002F8E  980744     MOV W4, [W14+8]
261:                           //second byte returned will be the data
262:                           error = CC2500_SPIReadByte(data);
002F90  90002E     MOV [W14+4], W0
002F92  9000BE     MOV [W14+6], W1
002F94  07FF46     RCALL CC2500_SPIReadByte
002F96  780200     MOV W0, W4
002F98  980744     MOV W4, [W14+8]
002F9A  370002     BRA 0x2FA0
263:                       }
264:                       else
265:                       {
266:                           error = CC2500_ERROR_DEVICE_NOT_READY;
002F9C  20FA24     MOV #0xFA2, W4
002F9E  980744     MOV W4, [W14+8]
267:                       }
268:               
269:                       CC2500_ChipSelect(session,1);
002FA0  B3C011     MOV.B #0x1, W1
002FA2  78001E     MOV [W14], W0
002FA4  07FF54     RCALL CC2500_ChipSelect
270:                   }
271:                   return error;
002FA6  90024E     MOV [W14+8], W4
272:               }
002FA8  780004     MOV W4, W0
002FAA  FA8000     ULNK
002FAC  060000     RETURN
273:               
274:               /**
275:                * Reads the status byte from the CC2500 module
276:                * @param status
277:                * @param error
278:                * @return
279:                */
280:               int CC2500_ReadStatusRegister(CC2500_Session session, 
281:                       __eds__ char * status, int error)
282:               {
002FAE  FA0008     LNK #0x8
002FB0  780F00     MOV W0, [W14]
002FB2  980712     MOV W2, [W14+2]
002FB4  980723     MOV W3, [W14+4]
002FB6  980731     MOV W1, [W14+6]
283:                   if(error <= 0){
002FB8  90023E     MOV [W14+6], W4
002FBA  520FE0     SUB W4, #0x0, [W15]
002FBC  3C0017     BRA GT, 0x2FEC
284:               
285:                       CC2500_ChipSelect(session,0);
002FBE  EB4080     CLR.B W1
002FC0  78001E     MOV [W14], W0
002FC2  07FF45     RCALL CC2500_ChipSelect
286:                       CC2500_FlushRx();
002FC4  07FF55     RCALL CC2500_FlushRx
287:                       error = CC2500_WaitForReady();
002FC6  07FF5F     RCALL CC2500_WaitForReady
002FC8  780200     MOV W0, W4
002FCA  980734     MOV W4, [W14+6]
288:                       //send write command
289:                       if(error <= 0)
002FCC  90023E     MOV [W14+6], W4
002FCE  520FE0     SUB W4, #0x0, [W15]
002FD0  3C0008     BRA GT, 0x2FE2
290:                       {
291:                           //send the NOP query and get the status byte
292:                           CC2500_SPI_WRITE_BUFFER = CC2500_SNOP;
002FD2  2003D4     MOV #0x3D, W4
002FD4  881344     MOV W4, SPI2BUF
293:                           error = CC2500_SPIReadByte(status);
002FD6  90001E     MOV [W14+2], W0
002FD8  9000AE     MOV [W14+4], W1
002FDA  07FF23     RCALL CC2500_SPIReadByte
002FDC  780200     MOV W0, W4
002FDE  980734     MOV W4, [W14+6]
002FE0  370002     BRA 0x2FE6
294:                       }else{
295:                           //timeout has occurred
296:                           error = CC2500_ERROR_DEVICE_NOT_READY;
002FE2  20FA24     MOV #0xFA2, W4
002FE4  980734     MOV W4, [W14+6]
297:                       }
298:                       CC2500_ChipSelect(session,1);
002FE6  B3C011     MOV.B #0x1, W1
002FE8  78001E     MOV [W14], W0
002FEA  07FF31     RCALL CC2500_ChipSelect
299:                   }
300:               
301:                   //rx fifo overflow, flush the fifo
302:                   if((*status & 0x07) == 0x06)
002FEC  90021E     MOV [W14+2], W4
002FEE  9002AE     MOV [W14+4], W5
002FF0  800196     MOV DSRPAG, W6
002FF2  780385     MOV W5, W7
002FF4  880197     MOV W7, DSRPAG
002FF6  000000     NOP
002FF8  780204     MOV W4, W4
002FFA  784214     MOV.B [W4], W4
002FFC  880196     MOV W6, DSRPAG
002FFE  000000     NOP
003000  FB0204     SE W4, W4
003002  620267     AND W4, #0x7, W4
003004  520FE6     SUB W4, #0x6, [W15]
003006  3A0005     BRA NZ, 0x3012
303:                   {
304:                       error = CC2500_WriteStrobe(session, CC2500_SFRX);
003008  B3C3A1     MOV.B #0x3A, W1
00300A  78001E     MOV [W14], W0
00300C  07FF7A     RCALL CC2500_WriteStrobe
00300E  780200     MOV W0, W4
003010  980734     MOV W4, [W14+6]
305:                   }
306:                   //tx fifo underflow, flush the fifo
307:                   if((*status & 0x07) == 0x07)
003012  90021E     MOV [W14+2], W4
003014  9002AE     MOV [W14+4], W5
003016  800196     MOV DSRPAG, W6
003018  780385     MOV W5, W7
00301A  880197     MOV W7, DSRPAG
00301C  000000     NOP
00301E  780204     MOV W4, W4
003020  784214     MOV.B [W4], W4
003022  880196     MOV W6, DSRPAG
003024  000000     NOP
003026  FB0204     SE W4, W4
003028  620267     AND W4, #0x7, W4
00302A  520FE7     SUB W4, #0x7, [W15]
00302C  3A0005     BRA NZ, 0x3038
308:                   {
309:                       error = CC2500_WriteStrobe(session, CC2500_SFTX);
00302E  B3C3B1     MOV.B #0x3B, W1
003030  78001E     MOV [W14], W0
003032  07FF67     RCALL CC2500_WriteStrobe
003034  780200     MOV W0, W4
003036  980734     MOV W4, [W14+6]
310:                   }
311:               
312:                   return error;
003038  90023E     MOV [W14+6], W4
313:               }
00303A  780004     MOV W4, W0
00303C  FA8000     ULNK
00303E  060000     RETURN
314:               
315:               int CC2500_ReadPacket(CC2500_Session session, __eds__ char * data,
316:                       unsigned char * count)
317:               {
003040  FA000E     LNK #0xE
003042  980730     MOV W0, [W14+6]
003044  980742     MOV W2, [W14+8]
003046  980753     MOV W3, [W14+10]
003048  980761     MOV W1, [W14+12]
318:               /*
319:                * 0x3F: Single byte access to TX FIFO
320:                * 0x7F: Burst access to TX FIFO
321:                * 0xBF: Single byte access to RX FIFO
322:                * 0xFF: Burst access to RX FIFO
323:                */
324:                   char temp;
325:                   char size = 0;
00304A  EB4200     CLR.B W4
00304C  984734     MOV.B W4, [W14+3]
326:                   __eds__ char RSSI;
327:                   __eds__ char LQI;
328:                   int error = 0;
00304E  EB0200     CLR W4
003050  780F04     MOV W4, [W14]
329:                   CC2500_ChipSelect(session,0);
003052  EB4080     CLR.B W1
003054  90003E     MOV [W14+6], W0
003056  07FEFB     RCALL CC2500_ChipSelect
330:                   CC2500_FlushRx();
003058  07FF0B     RCALL CC2500_FlushRx
331:               
332:                   //wait for the SDI line to be pulled low by the chip signaling
333:                   //that it is ready.
334:                   error = CC2500_WaitForReady();
00305A  07FF15     RCALL CC2500_WaitForReady
00305C  780200     MOV W0, W4
00305E  780F04     MOV W4, [W14]
335:               
336:                   if(error <= 0)
003060  78021E     MOV [W14], W4
003062  520FE0     SUB W4, #0x0, [W15]
003064  3C0050     BRA GT, 0x3106
337:                   {
338:                       //[R/nW  B A5-A0]
339:                       //set upper two bits to not burst and write mode
340:               
341:               
342:                       CC2500_SPI_WRITE_BUFFER = 0xFF; //burst access to RX FIFO
003066  200FF4     MOV #0xFF, W4
003068  881344     MOV W4, SPI2BUF
343:                       //these steps are necessary so the CS line doesn't
344:                       //go high until the SPI engine is done shifting out data
345:                       //failure to do this will cause an RX overflow
346:                       error = CC2500_SPIReadByte(&temp);
00306A  E8820E     INC2 W14, W4
00306C  B82261     MUL.UU W4, #1, W4
00306E  D28F84     RLC W4, [W15]
003070  D28285     RLC W5, W5
003072  BE0004     MOV.D W4, W0
003074  07FED6     RCALL CC2500_SPIReadByte
003076  780200     MOV W0, W4
003078  780F04     MOV W4, [W14]
347:                       if((temp & 0x0f)>0)
00307A  90422E     MOV.B [W14+2], W4
00307C  FB0204     SE W4, W4
00307E  62026F     AND W4, #0xF, W4
003080  520FE0     SUB W4, #0x0, [W15]
003082  340014     BRA LE, 0x30AC
348:                       {
349:                           //if there is data in the RX FIFO, read it into the size variable
350:                           //the first byte returned is the size of the packet as per
351:                           //the configuration of the CC2500
352:                           CC2500_SPI_WRITE_BUFFER = 0x00; //this byte is irrelevant
003084  EB0200     CLR W4
003086  881344     MOV W4, SPI2BUF
353:                           error = CC2500_SPIReadByte(&size);
003088  470263     ADD W14, #0x3, W4
00308A  B82261     MUL.UU W4, #1, W4
00308C  D28F84     RLC W4, [W15]
00308E  D28285     RLC W5, W5
003090  BE0004     MOV.D W4, W0
003092  07FEC7     RCALL CC2500_SPIReadByte
003094  780200     MOV W0, W4
003096  780F04     MOV W4, [W14]
354:                           CC2500_SPI_WRITE_BUFFER = 0x00; //this byte is irrelevant
003098  EB0200     CLR W4
00309A  881344     MOV W4, SPI2BUF
355:                           //this next byte should be the address
356:                           error = CC2500_SPIReadByte(data);
00309C  90004E     MOV [W14+8], W0
00309E  9000DE     MOV [W14+10], W1
0030A0  07FEC0     RCALL CC2500_SPIReadByte
0030A2  780200     MOV W0, W4
0030A4  780F04     MOV W4, [W14]
357:                           //decrement since address was included in size calculation
358:                           size--;
0030A6  90423E     MOV.B [W14+3], W4
0030A8  E94204     DEC.B W4, W4
0030AA  984734     MOV.B W4, [W14+3]
359:                       }
360:                       *count = size;
0030AC  90423E     MOV.B [W14+3], W4
0030AE  9002EE     MOV [W14+12], W5
0030B0  784A84     MOV.B W4, [W5]
361:                       while(size)
0030B2  370015     BRA 0x30DE
0030DE  90423E     MOV.B [W14+3], W4
0030E0  524FE0     SUB.B W4, #0x0, [W15]
0030E2  3AFFE8     BRA NZ, 0x30B4
362:                       {
363:                           //write to the buffer
364:                           CC2500_SPI_WRITE_BUFFER = 0x00; //this byte is irrelevant
0030B4  EB0200     CLR W4
0030B6  881344     MOV W4, SPI2BUF
365:               
366:                           //wait for SPI engine to finish sending the byte
367:                           error = CC2500_SPIReadByte(data);
0030B8  90004E     MOV [W14+8], W0
0030BA  9000DE     MOV [W14+10], W1
0030BC  07FEB2     RCALL CC2500_SPIReadByte
0030BE  780200     MOV W0, W4
0030C0  780F04     MOV W4, [W14]
368:               
369:                           //store the return value in data buffer, advance pointer
370:                           data++;
0030C2  90024E     MOV [W14+8], W4
0030C4  9002DE     MOV [W14+10], W5
0030C6  D00204     SL W4, W4
0030C8  B00024     ADD #0x2, W4
0030CA  A82042     BSET SR, #1
0030CC  4A82E0     ADDC W5, #0x0, W5
0030CE  AE2042     BTSS SR, #1
0030D0  A80042     BSET SR, #0
0030D2  D38204     RRC W4, W4
0030D4  980744     MOV W4, [W14+8]
0030D6  980755     MOV W5, [W14+10]
371:                           //TODO: right now the reads only support up to 63 bytes
372:                           //we would need to loop on the status byte to ensure everything is read
373:                           size--;
0030D8  90423E     MOV.B [W14+3], W4
0030DA  E94204     DEC.B W4, W4
0030DC  984734     MOV.B W4, [W14+3]
374:                       }
375:                       CC2500_SPI_WRITE_BUFFER = 0x00; //this byte is irrelevant
0030E4  EB0200     CLR W4
0030E6  881344     MOV W4, SPI2BUF
376:                       CC2500_SPI_WRITE_BUFFER = 0x00; //this byte is irrelevant
0030E8  EB0200     CLR W4
0030EA  881344     MOV W4, SPI2BUF
377:               
378:                       CC2500_SPIReadByte(&RSSI);
0030EC  470264     ADD W14, #0x4, W4
0030EE  DE22CF     LSR W4, #15, W5
0030F0  780204     MOV W4, W4
0030F2  A1F004     BCLR W4, #15
0030F4  BE0004     MOV.D W4, W0
0030F6  07FE95     RCALL CC2500_SPIReadByte
379:                       CC2500_SPIReadByte(&LQI);
0030F8  470265     ADD W14, #0x5, W4
0030FA  DE22CF     LSR W4, #15, W5
0030FC  780204     MOV W4, W4
0030FE  A1F004     BCLR W4, #15
003100  BE0004     MOV.D W4, W0
003102  07FE8F     RCALL CC2500_SPIReadByte
003104  370002     BRA 0x310A
380:                       
381:               
382:                   }
383:                   else
384:                   {
385:                       error = CC2500_ERROR_DEVICE_NOT_READY;
003106  20FA24     MOV #0xFA2, W4
003108  780F04     MOV W4, [W14]
386:                   }
387:               
388:                   CC2500_ChipSelect(session,1);
00310A  B3C011     MOV.B #0x1, W1
00310C  90003E     MOV [W14+6], W0
00310E  07FE9F     RCALL CC2500_ChipSelect
389:               
390:                   return error;
003110  78021E     MOV [W14], W4
391:               }
003112  780004     MOV W4, W0
003114  FA8000     ULNK
003116  060000     RETURN
392:               
393:               int CC2500_TransmitSmallPacket(CC2500_Session session, char * data, 
394:                       unsigned char size)
395:               {
003118  FA000A     LNK #0xA
00311A  980720     MOV W0, [W14+4]
00311C  980731     MOV W1, [W14+6]
00311E  984F02     MOV.B W2, [W14+8]
396:               /*
397:                * 0x3F: Single byte access to TX FIFO
398:                * 0x7F: Burst access to TX FIFO
399:                * 0xBF: Single byte access to RX FIFO
400:                * 0xFF: Burst access to RX FIFO
401:                */
402:                   char temp;
403:                   int error = 0;
003120  EB0200     CLR W4
003122  780F04     MOV W4, [W14]
404:                   CC2500_ChipSelect(session,0);
003124  EB4080     CLR.B W1
003126  90002E     MOV [W14+4], W0
003128  07FE92     RCALL CC2500_ChipSelect
405:                   CC2500_FlushRx();
00312A  07FEA2     RCALL CC2500_FlushRx
406:               
407:                   //wait for the SDI line to be pulled low by the chip signaling
408:                   //that it is ready.
409:                   error = CC2500_WaitForReady();
00312C  07FEAC     RCALL CC2500_WaitForReady
00312E  780200     MOV W0, W4
003130  780F04     MOV W4, [W14]
410:               
411:                   if(error <= 0)
003132  78021E     MOV [W14], W4
003134  520FE0     SUB W4, #0x0, [W15]
003136  3C0044     BRA GT, 0x31C0
412:                   {
413:                       //[R/nW  B A5-A0]
414:                       //set upper two bits to not burst and write mode
415:               
416:               
417:                       CC2500_SPI_WRITE_BUFFER = 0x7F; //burst acces to TX FIFO
003138  2007F4     MOV #0x7F, W4
00313A  881344     MOV W4, SPI2BUF
418:                       CC2500_SPI_WRITE_BUFFER = (size+1);
00313C  904A0E     MOV.B [W14+8], W4
00313E  FB8204     ZE W4, W4
003140  E80204     INC W4, W4
003142  881344     MOV W4, SPI2BUF
419:                       CC2500_SPI_WRITE_BUFFER = 0x00; //address of the RX
003144  EB0200     CLR W4
003146  881344     MOV W4, SPI2BUF
420:                       //read the last 3 bytes out of the SPI buffer
421:                       //these steps are necessary so the CS line doesnt
422:                       //go high until the SPI engine is done shifting out data
423:                       //failure to do this will cause an RX overflow
424:                       error = CC2500_SPIReadByte(&temp);
003148  E8820E     INC2 W14, W4
00314A  B82261     MUL.UU W4, #1, W4
00314C  D28F84     RLC W4, [W15]
00314E  D28285     RLC W5, W5
003150  BE0004     MOV.D W4, W0
003152  07FE67     RCALL CC2500_SPIReadByte
003154  780200     MOV W0, W4
003156  780F04     MOV W4, [W14]
425:                       error = CC2500_SPIReadByte(&temp);
003158  E8820E     INC2 W14, W4
00315A  B82261     MUL.UU W4, #1, W4
00315C  D28F84     RLC W4, [W15]
00315E  D28285     RLC W5, W5
003160  BE0004     MOV.D W4, W0
003162  07FE5F     RCALL CC2500_SPIReadByte
003164  780200     MOV W0, W4
003166  780F04     MOV W4, [W14]
426:                       error = CC2500_SPIReadByte(&temp);
003168  E8820E     INC2 W14, W4
00316A  B82261     MUL.UU W4, #1, W4
00316C  D28F84     RLC W4, [W15]
00316E  D28285     RLC W5, W5
003170  BE0004     MOV.D W4, W0
003172  07FE57     RCALL CC2500_SPIReadByte
003174  780200     MOV W0, W4
003176  780F04     MOV W4, [W14]
427:               
428:                       while(size)
003178  370012     BRA 0x319E
00319E  904A0E     MOV.B [W14+8], W4
0031A0  524FE0     SUB.B W4, #0x0, [W15]
0031A2  3AFFEB     BRA NZ, 0x317A
429:                       {
430:                           //write to the buffer
431:                           CC2500_SPI_WRITE_BUFFER = *data;
00317A  90023E     MOV [W14+6], W4
00317C  784214     MOV.B [W4], W4
00317E  FB0204     SE W4, W4
003180  881344     MOV W4, SPI2BUF
432:                           data++;
003182  90023E     MOV [W14+6], W4
003184  E80204     INC W4, W4
003186  980734     MOV W4, [W14+6]
433:                           //wait for SPI engine to finish sending the byte
434:                           error = CC2500_SPIReadByte(&temp);
003188  E8820E     INC2 W14, W4
00318A  B82261     MUL.UU W4, #1, W4
00318C  D28F84     RLC W4, [W15]
00318E  D28285     RLC W5, W5
003190  BE0004     MOV.D W4, W0
003192  07FE47     RCALL CC2500_SPIReadByte
003194  780200     MOV W0, W4
003196  780F04     MOV W4, [W14]
435:                           size--;
003198  904A0E     MOV.B [W14+8], W4
00319A  E94204     DEC.B W4, W4
00319C  984F04     MOV.B W4, [W14+8]
436:                       }
437:                       error = CC2500_WriteStrobe(session, CC2500_SCAL);
0031A4  B3C331     MOV.B #0x33, W1
0031A6  90002E     MOV [W14+4], W0
0031A8  07FEAC     RCALL CC2500_WriteStrobe
0031AA  780200     MOV W0, W4
0031AC  780F04     MOV W4, [W14]
438:                       __delay_ms(5);
0031AE  293E00     MOV #0x93E0, W0
0031B0  200041     MOV #0x4, W1
0031B2  070ED3     RCALL ___delay32
439:                       error = CC2500_WriteStrobe(session, CC2500_STX);
0031B4  B3C351     MOV.B #0x35, W1
0031B6  90002E     MOV [W14+4], W0
0031B8  07FEA4     RCALL CC2500_WriteStrobe
0031BA  780200     MOV W0, W4
0031BC  780F04     MOV W4, [W14]
0031BE  370002     BRA 0x31C4
440:                   }
441:                   else
442:                   {
443:                       error = CC2500_ERROR_DEVICE_NOT_READY;
0031C0  20FA24     MOV #0xFA2, W4
0031C2  780F04     MOV W4, [W14]
444:                   }
445:               
446:                   CC2500_ChipSelect(session,1);
0031C4  B3C011     MOV.B #0x1, W1
0031C6  90002E     MOV [W14+4], W0
0031C8  07FE42     RCALL CC2500_ChipSelect
447:               
448:                   return error;
0031CA  78021E     MOV [W14], W4
449:               }
0031CC  780004     MOV W4, W0
0031CE  FA8000     ULNK
0031D0  060000     RETURN
450:               
451:               
452:               
